[["index.html", "R을 이용한 퀀트 투자 포트폴리오 만들기(개정판) Welcome 지은이 소개 머리말 이 책의 구성 이 책에서 다루지 않은 주제 도움이 될 만한 자료들 이 책의 지원 페이지 종목과 관련된 유의사항 세션정보", " R을 이용한 퀀트 투자 포트폴리오 만들기(개정판) 이현열 2021-11-05 Welcome R을 이용한 퀀트 투자 포트폴리오 만들기 구매 링크 본 페이지는 R을 이용한 퀀트 투자 포트폴리오 만들기의 웹사이트 입니다. 책의 수정 사항이 있을시 즉시 반영할 예정이며, 책에서 다루지 못했던 추가적인 내용도 지속적으로 업데이트 할 예정입니다. 제로베이스 본 책의 내용을 바탕으로 강의가 진행중이니, 수강을 원하시는 분은 참조하시기 바랍니다. 책 발간 이후 업데이트 내용은 다음과 같습니다. 2021년 11월 5일: R을 사용하지 모르는 분들을 위해 R 기초 배우기 항목을 추가했습니다. 2021년 5월 22일: 크롤링 관련 패키지가 업데이트 되면서, 테이블이 데이터프레임 형태가 아닌 티블 형태로 다운로드 됩니다. 이에 따라 6장 재무제표 및 가치지표 크롤링 부분을 수정하였습니다. 2021년 1월 28일: 개정판이 발간되어 아래 내용이 모두 적용되었습니다. 2021년 1월 24일: 네이버증권의 차트가 플래쉬를 사용하지 않음에 따라, 해당 부분을 새롭게 작성했습니다. 2021년 1월 17일: 한국거래소가 사이트를 개편함에 따라 5장 한국거래소의 산업별 현황 및 개별지표 크롤링 부분을 새롭게 작성했습니다. 2020년 1월 17일: 9장 퀀트 전략을 이용한 종목선정 (기본)과 10장 퀀트 전략을 이용한 종목선정 (심화)에서 재무제표를 이용한 전략의 경우, 1~4월에는 최근년도 데이터가 일부 종목에 대해서만 들어옵니다. 따라서 해당 기간에는 전전년도 데이터를 사용해야 하며, 이를 고려하도록 코드를 변경하였습니다. 2020년 9월 26일: 4장 기업공시채널에서 오늘의 공시 불러오기에서 POST 부분의 url이 기존 http://kind.krx.co.kr/disclosure/todaydisclosure.do 에서 https://dev-kind.krx.co.kr/disclosure/todaydisclosure.do 로 변경되었습니다. 2020년 4월 27일: 9장 금융 데이터 수집하기 (심화)에 DART의 Open API를 이용한 데이터 수집하기 챕터를 추가하였습니다. 이를 통해 더욱 다양한 데이터를 수집할 수 있습니다. 2020년 4월 7일: 각 페이지 하단에 질문/답변 기능을 추가하였습니다. 이제 블로그나 이메일, SNS 보다는 웹북에 질문을 남겨주시기 바랍니다. 2020년 3월 22일: 11장 포트폴리오 구성에 실무에서 많이 사용되는 인덱스 포트폴리오 및 인핸스드 인덱스 포트폴리오 구성 방법을 추가하였습니다. 2020년 3월 22일: 8장 데이터 분석 및 시각화하기에서 종목정보 시각화 이전에 ggplot() 기초 챕터를 추가하였습니다. 이로써 기존에 해당 패키지를 모르던 분도 쉽게 배울수 있도록 하였습니다. 2020년 3월 15일: 6장 금융 데이터 수집하기 (심화)에 재무제표 및 가치지표 크롤링에서 사용하는 페이지가 크롤러의 접근을 막음에 따라, user_agent() 를 이용하여 웹브라우저 인자를 추가해 주었습니다. 2020년 1월 19일: 5장의 거래소 데이터 정리하기 부분에서 substr() 함수 대신 stringr 패키지의 str_sub() 함수를 사용하여 코드를 훨씬 간결하게 표현했습니다. 또한 종목코드 끝이 0이 아닐 경우 우선주인 점을 이용하여 더욱 쉽게 클렌징 처리를 하였습니다. 2020년 1월 18일: 야후 파이낸스 웹페이지의 구조가 바뀌어 동적 크롤링을 통해서만 데이터 수집이 가능하게 되었습니다. 이는 본 책에서는 다루지 않으므로, 6장 금융 데이터 수집하기 (심화)에서 해당 부분을 삭제하였습니다. 지은이 소개 이현열 한양대학교에서 경영학을 전공하고, 카이스트 대학원에서 금융공학 석사 학위를 받았다. 졸업 후 증권사에서 주식운용, 자산운용사에서 퀀트 포트폴리오 매니저, 보험사에서 데이터 분석 업무를 거쳐, 현재 핀테크 스타트업에서 퀀트 및 자산배분 리서치 업무를 하고 있다. 평소 꾸준한 SNS와 블로그 활동으로 퀀트 아이디어 및 백테스트 결과 등을 공유하면서 퀀트 투자의 대중화를 위해 노력하고 있다. 한양대학교 재무금융 박사 과정을 수료했으며, 패스트캠퍼스에서 R과 퀀트 투자 강의를 맡고 있다. 지은 책으로는 《스마트베타》(2017)가 있다. 머리말 퀀트 투자 중 팩터에 관한 이론적 내용을 다룬 《SMART BETA(스마트 베타): 감정을 이기는 퀀트 투자》(김병규, 이현열, 워터베어프레스, 2017) 출간 이후 강의와 세미나를 통해많은 분들을 만났고, 공통적인 어려움을 느낄 수 있었습니다. 기관 투자자들이 손쉽게 데이터를 구할 수 있는 것과는 다르게, 일반 투자자들은 퀀트 투자를 하기 위한 데이터를 구하는 시작점부터 어려움을 겪는다는 것이었습니다. 그러나 프로그래밍을 이용하면 일반 투자자들도 얼마든지 금융 데이터 수집 및 처리, 퀀트 모델 개발, 포트폴리오 분석 및 자동화 등이 가능합니다. 이 책을 읽는 독자분들이 스스로 이러한 퀀트 투자 프로세스를 만들 수 있기를 바라는 마음으로 책을 구성했습니다. 또한 실제 전문 투자자들이 사용하는 기술들도 포함했으니 책의 내용을 넘어 더욱 훌륭한 모델을 만드는 데 도움이 되시리라 생각합니다. 이 책에서 데이터 수집을 위해 주로 다루는 크롤링은 웹페이지의 데이터를 가져오는 것입니다. 기존에 책 발간 이후 참고자료로 사용된 페이지 중 형태가 바뀐곳이 많아 개정판을 작성하게 되었습니다. 수정된 내역은 다음과 같습니다. 야후 파이낸스의 웹페이지 구조가 바뀌어 크롤링이 사실상 어렵게 되었고, 책 내용에서 제외하였습니다. 한국거래소 사이트가 개편되어 해당 부분은 바뀐 페이지에 맞게 새로 작성하였습니다. 네이버 증권의 주가 데이터 출처가 변경되어 새로 작성하였습니다. 일부 페이지가 크롤러의 접근을 막음에 따라 user_agent() 함수를 사용해 크롤링이 가능해지게 하였습니다. 많은 문의가 있었던 DART 크롤링에 대한 내용을 추가했습니다. 포트폴리오 구성 부분에 실무에서 많이 사용되는 인덱스 포트폴리오 및 인핸스드 인덱스 포트폴리오 구성 방법을 추가하였습니다. ggplot2 패키지의 기본적인 사용법을 추가하였습니다. 일부 코드를 수정하여 데이터 처리를 좀 더 쉽게, 종목 선택을 더욱 꼼꼼히 할수 있도록 하였습니다 앞으로도 페이지 변경 등 코드를 수정해야 하거나 추가된 내용이 있을 경우 책의 공식 페이지인 https://hyunyulhenry.github.io/quant_cookbook/ 에 즉각적으로 업데이트 할 예정이며, 질문사항이 있을 경우 페이지에 남겨주시면 답변드리고 있습니다. 어느때보다 주식과 투자에 대한 관심이 뜨거워진 지금, 유행이라는 파도에 휩쓸리는 투자보다는 데이터를 이용한 객관적이고 장기적인 투자로 성공하시길 기원합니다. 2021년 1월 이현열(leebisu@gmail.com) 이 책의 구성 이 책은 API와 크롤링을 통한 금융 데이터 수집, 투자 종목 선택 및 포트폴리오 구성, 백테스트와 성과 분석으로 이루어져 있습니다. CHAPTER 1 퀀트 투자의 심장: 데이터와 프로그래밍 퀀트 투자란 무엇인지, 왜 프로그래밍이 필요한지, 여러 언어 중 R을 사용해야 하는 이유에 대해 살펴봅니다. CHAPTER 2 크롤링을 위한 기본 지식 크롤링을 통한 데이터 수집에 앞서 인코딩, 웹의 동작 방식, HTML에 대한 기본 정보와 데이터 처리에 편리한 R 코드를 살펴봅니다. CHAPTER 3 API를 이용한 데이터 수집 API를 통한 데이터 수집과 getSymbols() 함수의 사용 방법에 대해 살펴봅니다. CHAPTER 4 크롤링 이해하기 크롤링이 무엇인가에 대해 살펴보며, GET과 POST 방식을 이용한 간단한 예제를 살펴봅니다. CHAPTER 5 금융 데이터 수집하기 기본 한국거래소에서 제공하는 데이터를 크롤링하는 방법, 섹터의 구성종목을 수집하는 방법에 대해 살펴봅니다. CHAPTER 6 금융 데이터 수집하기 심화 퀀트 투자의 핵심 자료인 수정주가, 재무제표 및 가치지표를 크롤링하는 방법을 살펴봅니다. CHAPTER 7 데이터 정리하기 앞에서 수집한 주가, 재무제표, 가치지표를 하나의 파일로 정리하는 방법을 살펴봅니다. CHAPTER 8 데이터 분석 및 시각화하기 수집한 데이터를 바탕으로 dplyr 패키지를 이용한 데이터 분석 및 ggplot2 패키지를 이용한 데이터 시각화, 인터랙티브 그래프를 나타내는 방법을 살펴봅니다. CHAPTER 9 퀀트 전략을 이용한 종목 선정 기본 베타에 대한 이해 및 기본적 팩터인 저변동성, 모멘텀, 밸류, 퀄리티를 이용한 종목 선정에 대해 살펴봅니다. CHAPTER 10 퀀트 전략을 이용한 종목 선정 심화 단순 종목 선정을 넘어 실무에서 사용되는 섹터 중립 포트폴리오 및 이상치 제거와 팩터 결합 방법, 마법공식 및 멀티팩터에 대해 살펴봅니다. CHAPTER 11 포트폴리오 구성 최적화 패키지를 이용한 포트폴리오 구성에서 가장 대중적으로 사용되는 최소분산 포트폴리오, 최대분산효과 포트폴리오, 위험균형 포트폴리오를 구현합니다. 또한 실무에서 많이 사용되는 인덱스 포트폴리오 및 인핸스드 인덱스 포트폴리오 구성 방법을 살펴봅니다. CHAPTER 12 포트폴리오 백테스트 Return.portfolio() 함수를 이용한 백테스트 방법에 대해 살펴보겠습니다. CHAPTER 13 성과 및 위험 평가 포트폴리오의 수익률을 바탕으로 성과 및 위험 평가에 사용되는 각종 지표에 대해 알아보며, 4팩터 회귀분석을 통한 요인 분석을 실행합니다. 이 책에서 다루지 않은 주제 이 책은 R을 기본적으로 사용할 줄 아는 독자를 대상으로 작성되었습니다. 따라서 내용의 효율적 전달을 위해 R과 R Studio 설치, 기초적인 프로그래밍 등의 내용은 생략했습니다. 따라서 프로그래밍을 처음 접하는 독자라면 프로그래밍 기초를 먼저 익히신후 본 책을 읽으시길 추천드립니다. 또한 이 책에서는 프로그램 언어로 R을 이용했기 때문에 Python 혹은 다른 언어를 사용하는 분들에게는 직접적으로 도움이 되지 않을 수 있다고 생각할 수 있습니다. 그러나 투자에 필요한 금융 데이터 수집을 어디서 어떻게 하는지, 종목 선택을 어떻게 하고 포트폴리오를 어떻게 구성하는지에 대한 이론적 내용을 이해한 후 본인들이 사용하는 언어로 구현해보는 것도 좋은 도전이 될 것입니다. 도움이 될 만한 자료들 먼저 팩터 투자와 관련하여 심화된 내용을 알고 싶은 분은 저의 이전 책 및 책에서 인용된 논문을 읽어볼 것을 권합니다. R 프로그래밍과 관련하여 기초부터 tidyverse 패키지까지 이해하는 데 도움이 될만한 책 목록은 다음과 같습니다. 《SMART BETA(스마트 베타): 감정을 이기는 퀀트 투자》(김병규, 이현열, 워터베어프레스, 2017) 《손에 잡히는 R 프로그래밍》(가렛 그롤먼드, 한빛미디어, 2015) 《R Cookbook》(폴 티터, 인사이트, 2012) 《R을 활용한 데이터 과학》(해들리 위컴, 개럿 그롤문드, 인사이트, 2019) 《Do it! 쉽게 배우는 R 데이터 분석》(김영우, 이지스퍼블리싱, 2017) 《ggplot2: R로 분석한 데이터를 멋진 그래픽으로》(해들리 위컴, 프리렉, 2017) 이 책의 지원 페이지 이 책은 R의 bookdown 패키지로 작성되어 웹페이지 및 GitHub 저장소에 공유되어 있습니다. 따라서 책에 포함되어 있는 각종 코드를 웹페이지에 방문하여 얻으실 수 있습니다. 웹페이지: https://hyunyulhenry.github.io/quant_cookbook GitHub 저장소: https://github.com/hyunyulhenry/quant_cookbook 크롤링 대상 웹페이지의 구조가 바뀌어 코드의 수정이 필요할 경우 즉각적으로 반영할 것이며, 인쇄본에서 다루지 않은 내용도 추가적으로 업데이트될 예정입니다. 또한 bookdown 패키지를 이용하여 책을 집필하고자 하는 분들에게도 많은 도움이 될 것입 니다. 이 외에도 퀀트 투자 혹은 R을 이용한 투자 활용법 등의 내용은 저자의 블로그에 많은글들이 있으니 참조하기 바랍니다. Henry’s Quantopia: https://blog.naver.com/leebisu 종목과 관련된 유의사항 팩터 모델을 이용한 종목 선택과 관련된 CHAPTER에서는 해당 조건으로 선택된 종목들이 나열되어 있습니다. 그러나 이는 해당 종목에 대한 매수 추천이 아님을 밝히며, 데이터를 받은 시점의 종목이기에 독자 여러분이 책을 읽는 시점에서 선택된 종목과는 상당한 차이가 있습니다. 또한 이 책에서 다루는 모델을 이용하여 투자를 할 경우, 이로 인한 이익과 손해는 본인에게 귀속됨을 알립니다. 세션정보 본 책에서 사용된 R 버젼 및 각종 정보는 다음과 같습니다. ## R version 4.1.0 (2021-05-18) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 19042) ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=Korean_Korea.949 LC_CTYPE=Korean_Korea.949 ## [3] LC_MONETARY=Korean_Korea.949 LC_NUMERIC=C ## [5] LC_TIME=Korean_Korea.949 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] showtext_0.9-4 showtextdb_3.0 sysfonts_0.8.5 ## ## loaded via a namespace (and not attached): ## [1] bookdown_0.23 digest_0.6.27 R6_2.5.1 jsonlite_1.7.2 ## [5] magrittr_2.0.1 evaluate_0.14 highr_0.9 stringi_1.7.4 ## [9] rlang_0.4.11 rstudioapi_0.13 jquerylib_0.1.4 bslib_0.3.1 ## [13] rmarkdown_2.10 tools_4.1.0 stringr_1.4.0 xfun_0.23 ## [17] yaml_2.2.1 fastmap_1.1.0 compiler_4.1.0 htmltools_0.5.2 ## [21] knitr_1.33 sass_0.4.0 "],["r-기초-배우기.html", "R 기초 배우기 0.1 R과 R 스튜디오 설치하기 0.2 R 스튜디오 화면 구성 0.3 R 스튜디오 설정하기 0.4 프로젝트 만들기 0.5 데이터 타입별 다루기 0.6 데이터 구조 다루기 0.7 데이터 불러오기 및 내보내기 0.8 효율성과 가독성 높이기 0.9 데이터 구조 변형하기", " R 기초 배우기 이번 장에서는 본 책의 핵심이 되는 언어인 R과 R 스튜디오의 설치, R 스튜디오의 화면 구성과 간단한 사용법에 대해서 배우도록 하겠습니다. 본 장은 R의 기초 중에서도 핵심만을 추린 것으로써, 기초에 대해 세세하게 다루지는 않습니다. 좀 더 탄탄한 기본기를 배우고 싶으신 분은 시중에 나와있는 훌륭한 R 기본 서적을 추가로 보실 것을 추천드립니다. 0.1 R과 R 스튜디오 설치하기 0.1.1 R 설치하기 먼저 R 프로젝트 공식 사이트인 https://cran.r-project.org/ 에 접속하여 본인의 OS에 맞는 설치 파일을 다운로드 합니다. 그림 0.1: CRAN 사이트 가장 상단의 [base]를 선택합니다. 그림 0.2: R 다운로드 화면 [Download R x.x.x for Windows] 항목을 클릭하면 설치 파일이 다운로드 됩니다. 다운로드 받은 파일을 실행해 설치를 하며, 옵션은 수정하지 않아도 됩니다. 그림 0.3: R 설치파일 다운로드 0.1.2 R 스튜디오 설치하기 위에서 설치한 R GUI를 그대로 쓰는 사용자는 거의 없습니다. 대부분의 경우 R을 사용하기 편리하게 만들어주는 IDE 소프트웨어인 R 스튜디오를 사용하므로, 해당 프로그램을 설치하도록 합니다. R 스튜디오를 사용하려면 R이 먼저 설치되어 있어야 하며, R과 마찬가지로 무료로 사용할 수 있습니다. 먼저 아래 사이트에 접속합니다. https://www.rstudio.com/products/rstudio/download/ 하단의 [All Installers] 항목에서 본인의 OS에 해당하는 파일을 다운로드 받아 설치합니다. 그림 0.4: R 스튜디오 설치파일 다운로드 윈도우 사용자의 경우 간혹 R 스튜디오를 실행하는데 있어 오류가 발생할 수 있습니다. R 스튜디오가 관리자 권한으로 실행되지 않으면 오류가 발생할 수 있으며, 이 경우 아래와 같은 방법으로 해결이 가능합니다. R 스튜디오 바로가기 아이콘을 마우스 우클릭으로 연 후, [속성] → [호환성]을 클릭합니다. [관리자 권한으로 이 프로그램 실행]에 체크한 후 [확인]을 누릅니다. 2. 윈도우 사용자 계정이 한글인 경우 기존 사용자 계정을 영문으로 변경하거나, 영문으로 된 사용자 계정을 새로 추가합니다. 0.2 R 스튜디오 화면 구성 처음으로 R 스튜디오를 실행하면 다음과 같은 화면으로 구성되어 있습니다. 이 중 소스 창을 열기 위해 네모 2개가 겹쳐 있는 모양()의 버튼을 클릭합니다. 그림 0.5: R 스튜디오 화면구성 소스 창이 활성화되면 총 4개의 창으로 화면이 구성되며, 각 창의 크기는 경계선 부분을 드래그하여 조절할 수 있습니다. 그림 0.6: R 스튜디오 화면구성 (2) 1. 콘솔 창 좌측 하단에 있는 콘솔 창은 코드를 입력하고 결과물을 출력하는 곳입니다. 그림 0.7: R 스튜디오 콘솔 창 콘솔 창의 &gt; 기호 뒤에 1+1을 입력하면 그 결과값인 2가 출력됩니다. 이 외에도 [Terminal] 탭에서는 시스템 쉘을 이용해 운영 체제를 조작할 수 있습니다. 2. 소스 창 좌측 상단에 있는 소스 창은 코드를 기록할 수 있는 공간이며, 이를 저장한 파일을 스크립트라고 합니다. 콘솔 창과는 다르게 코드를 입력하여도 바로 실행이 되지 않으며, 엔터를 누르면 행이 바뀝니다. 실행하고자 하는 코드가 있는 행을 선택한 후, [Ctrl + Enter]키를 누르면 해당 코드가 실행됩니다. 그림 0.8: R 스튜디오 소스 창의 실행 3*7이란 코드가 있는 곳에 커서를 둔 후 [Ctrl + Enter]키를 누르면 해당 코드가 콘솔 창에서 실행됩니다. 만일 여러줄의 명령어를 한번에 실행하고 할 경우, 원하는 부분의 코드를 마우스로 드래그하여 선택한 후 [Ctrl + Enter]키를 누르면 코드가 순차적으로 콘솔 창에 입력되면서 실행됩니다. 그림 0.9: R 스튜디오 소스 저장하기 위에서 작성한 코드를 저장해보도록 하겠습니다. 저장 버튼()을 클릭한 후 원하는 폴더 및 파일 이름을 입력 한 후 [Save] 버튼을 누릅니다. 그림 0.10: R 스튜디오 소스 저장하기 (2) Untitled1로 되어 있던 스크립트의 이름이 저장한 이름으로 바뀌며, 스크립트가 저장되어 있는 것이 확인됩니다. 이처럼 코딩을 한 후 스크립트를 저장할 경우, 나중에 해당 내역을 그대로 불러올 수 있습니다. 3. 환경 창 우측 상단에 있는 환경 창은 생성된 데이터를 보여주는 화면입니다. 그림 0.11: R 스튜디오 환경 창 스크립트 창에서 a = 1을 입력하면, 환경 창의 Values 목록에 a가 생기며 그 값은 1로 표시됩니다. 이 외에도 환경 창의 [History] 탭은 이제까지 실행했던 코드의 내역을 볼 수 있으며, [Connections] 탭은 SQL이나 Spark 등 데이터베이스와의 연결을 도와줍니다. 4. 파일 창 우측 하단에 있는 파일 창은 윈도우의 파일 탐색기와 비슷한 역할을 하며, 워킹 디렉터리 내의 파일을 보여줍니다. 이 외에도 [Plots] 탭은 그래프를 보여주며 [Packages] 탭은 설치된 패키지의 목록을 보여줍니다. [Help] 탭은 도움말을 보여주며, [Viewer] 탭은 분석 결과를 HTML 등 웹 문서로 출력한 모습을 보여줍니다. 0.3 R 스튜디오 설정하기 R 스튜디오는 기본적으로 흰색 바탕에 검은색 글씨로 설정되어 있습니다. 그러나 흰 화면에서 작업을 하게 되면 눈이 쉽게 피로해지며, 시력에도 좋지 않습니다. 이를 방지하기 위해 어두운 화면으로 설정을 변경해주는 것이 좋습니다. 그림 0.12: R 스튜디오의 테마 선택 상단 탭에서 [Tools] → [Global Options]를 선택한 후, Options의 [Appearance] 탭의 [Editor theme]을 통해 각종 테마를 적용할 수 있습니다. 이 중 본인의 마음에 드는 테마를 선택한 후, [OK] 버튼을 누릅니다. 그림 0.13: R 스튜디오의 다크모드 적용 화면의 배경이 어두워져 눈이 한결 편해졌습니다. 또한 스크립트 내용 중 한글이 깨지는 것을 방지하기 위해 인코딩 방식을 설정할 필요도 있습니다. 그림 0.14: R 스튜디오의 인코딩 변경 상단 탭에서 [Tools] → [Global Options]를 선택한 후, Options의 [Code] 탭의 [Default text encoding] 부분의 [Change]를 눌러 UTF-8로 변경해줍니다. 인코딩은 컴퓨터가 문자를 표현하는 방식을 의미하며, 이에 대해서는 나중 장에서 다시 자세하게 다루도록 합니다. 해당 방법으로도 스크립트의 인코딩이 깨질 경우 [File → Reopen with Encoding] 메뉴에서 [UTF-8] 항목을 선택하고 [Set as default encoding for source files] 항목을 선택한 후 [OK]를 클릭합니다. UTF-8로 인코딩이 설정된 후 파일을 다시 열리게 됩니다. 그림 0.15: 인코딩 변경 후 재시작 0.4 프로젝트 만들기 R 스튜디오에서 코딩을 하기 전에 프로젝트(Project)를 만들면 하나의 프로젝트에 사용되는 소스 코드, 이미지, 문서 등의 파일을 폴더별로 관리하여 효율적으로 관리할 수 있습니다. 먼저 R 스튜디오 상단의 육각형 모양 버튼()을 클릭하거나 [File → New Project]를 클릭합니다. 그림 0.16: 프로젝트 생성 [Create Project] 화면에서 가장 상단의 [New Directory]를 클릭합니다. 참고로 Existing Directory는 기존 폴더에 새로운 프로젝트를 만들때, Version Control은 깃허브 등의 버전 관리 시스템을 이용할 때 사용됩니다. 그림 0.17: 새 프로젝트 생성 [Project Type]에서 가장 상단의 [New Project]를 클릭합니다. 그림 0.18: 새 프로젝트 생성 (2) [Create New Project] 창에서 [Directory name] 항목에 새로 만들 프로젝트 이름을 입력합니다. [Create project as subdirectory of] 항목에는 프로젝트 폴더를 만들 위치를 선택하며, [Browse]를 클릭해 원하는 위치를 선택합니다. 그 후 하단의 [Creage Project]를 클릭합니다. 그림 0.19: 새 프로젝트 생성 (3) R 스튜디오가 재시작되면 우측 상단 부분이 프로젝트 이름으로 바뀌며, 파일 창의 윗부분도 프로젝트 폴더의 위치로 바뀝니다. 또한 폴더 내에 fin_ds.Rpoj 라는 파일이 생성됩니다. 스크립트 및 각종 파일들을 해당 프로젝트 폴더에 저장하여, 효율적으로 각종 작업을 관리할 수 있습니다. 그림 0.20: 새 프로젝트 생성 (4) 프로젝트 이름과 폴더 경로에 한글이 들어가면 오류가 발생할 수 있으니, 영문으로 입력하는 것이 좋습니다. 0.5 데이터 타입별 다루기 R과 R 스튜디오 설치가 끝났으면 본격적으로 R의 기본적인 사용법에 대해 배워보겠으며, 먼저 데이터의 타입별로 다루는 법부터 시작하겠습니다. R 뿐만 아니라 각종 프로그래밍에는 여러가지 데이터 타입이 있으며, 이를 다루는 방법은 각각 다릅니다. 예를 들어 같은 ’3’도 숫자 3인지 문자 3인지에 따라 다루는 방법이 다릅니다. 따라서 데이터 타입의 종류와 이들을 어떻게 다루어야 하는지를 아는 것이 프로그래밍의 기초라고 할 수 있습니다. 0.5.1 숫자 형태 R에서 숫자(Numbers) 형태는 크게 integer와 double로 나눌 수 있습니다. 이 중 integer는 정수를 의미하며, double은 부동소수점 실수를 의미합니다. dbl_var = c(1, 2.5, 4.5) print(dbl_var) ## [1] 1.0 2.5 4.5 위와 같이 입력하면 double, 즉 소수점 형태의 숫자가 만들어 집니다. int_var = c(1L, 6L, 5L) print(int_var) ## [1] 1 6 5 만일 숫자 뒤에 :을 붙이면, integer(정수) 형태의 숫자가 만들어 집니다. double 형태를 integer 형태로 바꾸려면 할 경우, as.integer() 함수를 사용해 쉽게 변경할 수 있습니다. 이처럼 R에서는 as.*() 함수의 형태로 각 데이터의 형태를 바꿀 수 있습니다. as.integer(dbl_var) ## [1] 1 2 4 [1.0 2.5 4.5] 이던 dbl_var 값이 as.integer() 함수를 통해 소수점이 사라지고 정수 형태인 [1 2 4]로 변경되었습니다. 0.5.1.1 숫자 생성하기 R에서는 콜론(:)과 c() 함수를 통해 순서가 있는 숫자 벡터를 생성할 수 있습니다. 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 시작숫자:끝숫자의 형태로 입력하여 1에서 10까지 숫자가 생성됩니다. c(1, 5, 10) ## [1] 1 5 10 c() 함수 내부에 각각의 숫자를 입력할 경우, 이로 구성된 숫자 벡터가 생성됩니다. seq() 함수를 이용할 경우 더욱 다양하게 숫자 벡터를 생성할 수 있습니다. seq는 Sequence 즉 ’순서’의 약어입니다. 이처럼 R이나 여타 프로그래밍에서는 함수의 이름을 통해 대략적인 기능을 추론할 수 있습니다. seq(from = 1, to = 21, by = 2) ## [1] 1 3 5 7 9 11 13 15 17 19 21 seq() 함수 내부에 from에는 시작 숫자, to에는 종료 숫자, by에는 간격을 입력합니다. 즉 1에서 21까지 2 단위로 숫자가 생성됩니다. seq(0, 21, length.out = 15) ## [1] 0.0 1.5 3.0 4.5 6.0 7.5 9.0 10.5 12.0 13.5 15.0 16.5 18.0 19.5 21.0 만일 입력값에 by 대신 length.out을 쓸 경우 from에서 to 까지 동일한 증가폭으로 length.out 만큼의 숫자를 생성하며, 해당 예제에서는 총 15개의 숫자가 만들어집니다. rep() 함수 역시 숫자를 생성해주는 함수입니다. rep(1:4, times = 2) ## [1] 1 2 3 4 1 2 3 4 rep는 Replicate 즉 ’복제하다’의 약어 입니다. 해당 함수 내에 times라는 입력값을 추가해줄 경우, 해당 숫자만큼 반복되어 벡터가 생성됩니다. rep(1:4, each = 2) ## [1] 1 1 2 2 3 3 4 4 만일 each라는 입력값을 추가할 경우, 각각의 숫자를 n번 반복하여 벡터가 생성됩니다. 0.5.1.2 올림, 내림, 반올림 함수를 통해 간단하게 숫자의 올림, 내림, 반올림을 할 수도 있습니다. 먼저 다음과 같이 숫자를 입력합니다. x = c(1, 1.35, 1.7, 2.053, 2.4, 2.758, 3.1, 3.45, 3.8, 4.15, 4.5, 4.855, 5.2, 5.55, 5.9) round(x) ## [1] 1 1 2 2 2 3 3 3 4 4 4 5 5 6 6 round() 함수는 가장 가까운 정수로 반올림을 합니다. round(x, digits = 2) ## [1] 1.00 1.35 1.70 2.05 2.40 2.76 3.10 3.45 3.80 4.15 4.50 4.86 5.20 5.55 5.90 함수 내부에 digits 입력값을 추가해 줄 경우, 해당 자리수 만큼 반올림을 합니다. 위 예제에서는 소수 둘째자리 만큼 반올림을 하였습니다. ceiling(x) ## [1] 1 2 2 3 3 3 4 4 4 5 5 5 6 6 6 floor(x) ## [1] 1 1 1 2 2 2 3 3 3 4 4 4 5 5 5 ceiling() 함수는 올림을, floor() 함수는 내림을 실행합니다. 0.5.2 문자열 형태 일반적인 글자 혹은 텍스트를 문자열(Character Strings)이라고 합니다. a = &#39;learning to create&#39; b = &#39;character strings&#39; paste(a, b) ## [1] &quot;learning to create character strings&quot; 먼저 a와 b 변수에 각각의 문자를 입력한 후, R의 기본함수인 paste() 함수를 이용해 두 문자를 붙일 수 있습니다. print(pi) ## [1] 3.142 paste(&#39;pi is&#39;, pi) ## [1] &quot;pi is 3.14159265358979&quot; 원주율을 의미하는 pi는 원래 3.14159 라는 숫자가 입력되어 있습니다. 그러나 paste() 함수를 통해 문자열과 숫자를 합칠 경우, 그 결과값은 문자열이 됩니다. paste(&#39;I&#39;, &#39;love&#39;, &#39;R&#39;, sep = &#39;,&#39;) ## [1] &quot;I,love,R&quot; paste() 함수 내부에 sep 인자를 추가할 경우, 각 단어를 구분하는 문자를 입력할 수 있습니다. 기존에는 각 문자가 공백을 기준으로 합쳐졌다면, 이번에는 콤마(,)를 기준으로 합쳐졌습니다. paste0(&#39;I&#39;, &#39;love&#39;, &#39;R&#39;) ## [1] &quot;IloveR&quot; paste0() 함수는 구분 문자가 없이 결합됩니다. 0.5.2.1 stringr 패키지를 이용한 문자열 다루기 R의 기본함수를 이용하여도 문자열을 다룰 수 있지만, stringr 패키지를 이용할 경우 더욱 다양한 작업을 수행할 수 있습니다. library(stringr) str_c(&#39;Learning&#39;, &#39;to&#39;, &#39;use&#39;, &#39;the&#39;, &#39;stringr&#39;, &#39;package&#39;, sep = &#39; &#39;) ## [1] &quot;Learning to use the stringr package&quot; str_c() 함수는 paste() 함수와 기능이 동일하며, sep 인자를 통해 구분자를 추가할 수 있습니다. text = c(&#39;Learning&#39;, &#39;to&#39;, NA, &#39;use&#39;, &#39;the&#39;, NA, &#39;stringr&#39;, &#39;package&#39;) str_length(text) ## [1] 8 2 NA 3 3 NA 7 7 str_length() 함수는 문자열 각각의 텍스트 갯수를 세줍니다. x = &#39;Learning to use the stringr package&#39; str_sub(x, start = 1, end = 15) ## [1] &quot;Learning to use&quot; str_sub(x, start = -7, end = -1) ## [1] &quot;package&quot; str_sub() 함수는 start부터 end까지의 문자를 출력합니다. 만일 start 혹은 end에 음수를 입력하면, 문장의 뒤에서부터 start/end 지점이 계산됩니다. 즉, start와 end에 각각 -7와 -1을 입력하면 끝에서부터 일곱번째와 첫번째 지점이 시작점과 끝점이 됩니다. 텍스트 데이터를 다룰때는 빈 공백이 따라오는 경우가 많으며, 이는 대부분 제거해주어야 할 대상입니다. text = c(&#39;Text &#39;, &#39; with&#39;, &#39; whitespace &#39;, &#39; on&#39;, &#39;both &#39;, &#39;sides &#39;) print(text) ## [1] &quot;Text &quot; &quot; with&quot; &quot; whitespace &quot; &quot; on&quot; &quot;both &quot; ## [6] &quot;sides &quot; 각 단어를 자세히 살펴보면 좌/우 혹은 양쪽에 공백이 있습니다. 이를 제거하도록 하겠습니다. str_trim(text, side = &#39;left&#39;) ## [1] &quot;Text &quot; &quot;with&quot; &quot;whitespace &quot; &quot;on&quot; &quot;both &quot; ## [6] &quot;sides &quot; str_trim(text, side = &#39;right&#39;) ## [1] &quot;Text&quot; &quot; with&quot; &quot; whitespace&quot; &quot; on&quot; &quot;both&quot; ## [6] &quot;sides&quot; str_trim(text, side = &#39;both&#39;) ## [1] &quot;Text&quot; &quot;with&quot; &quot;whitespace&quot; &quot;on&quot; &quot;both&quot; ## [6] &quot;sides&quot; str_trim() 함수는 공백을 제거해주는 기능을 합니다. side 인자에 left를 입력할 경우 각 텍스트 왼쪽의 공백을, right를 입력할 경우 오른쪽의 공백을, both를 입력할 경우 양쪽의 공백을 제거해줍니다. 마지막으로 원하는 자리수를 채우기 위해 문자열에 공백 혹은 특정 문자를 입력할 수도 있으며, str_pad() 함수를 통해 손쉽게 작업을 할 수 있습니다. str_pad(&#39;beer&#39;, width = 10, side = &#39;left&#39;) ## [1] &quot; beer&quot; width에 해당하는 10자리를 맞추기 위해 side의 입력값인 좌측에 공백이 추가되었습니다. str_pad(&#39;beer&#39;, width = 10, side = &#39;left&#39;, pad = &#39;!&#39;) ## [1] &quot;!!!!!!beer&quot; pad 인자를 추가할 경우, 공백이 아닌 입력한 문자가 추가됩니다 아래 페이지에는 stringr 패키지의 자세한 사용법이 나와 있습니다. https://stringr.tidyverse.org/ 0.5.3 날짜 형태 시계열 작업을 위해서는 날짜(Date), 혹은 시간(Datetime) 형태를 다루어야 합니다. Sys.timezone() ## [1] &quot;Asia/Seoul&quot; Sys.Date() ## [1] &quot;2021-11-05&quot; Sys.time() ## [1] &quot;2021-11-05 16:42:27 KST&quot; Sys.timezone() 함수는 현재 타임존을 출력합니다. Sys.Date() 함수는 현재 날짜를, Sys.time() 함수는 날짜와 시간을 출력합니다. ’2018-12-31’과 같이 사용자가 보기에는 날짜 형태이지만 문자열 형태로 데이터가 들어오는 경우, 이를 날짜 형태로 변경해야 할 경우가 있습니다. x = c(&#39;2021-07-01&#39;, &#39;2021-08-01&#39;, &#39;2021-09-01&#39;) x_date = as.Date(x) str(x_date) ## Date[1:3], format: &quot;2021-07-01&quot; &quot;2021-08-01&quot; &quot;2021-09-01&quot; as.Date() 함수를 이용하면 문자열을 손쉽게 날짜 형태로 변경할 수 있습니다. str() 함수는 데이터의 형태를 확인하는 함수로써, Date 형태임이 확인됩니다. y = c(&#39;07/01/2015&#39;, &#39;08/01/2015&#39;, &#39;09/01/2015&#39;) as.Date(y, format = &#39;%m/%d/%Y&#39;) ## [1] &quot;2015-07-01&quot; &quot;2015-08-01&quot; &quot;2015-09-01&quot; YYYY-MM-DD 형태가 아닌 다른 형태(MM/DD/YYYY)로 입력된 경우, format을 직접 입력하여 Date 형태로 변경할 수 있습니다. YYYY는 연, MM은 월, DD는 일을 나타냅니다. 0.5.3.1 lubridate 패키지를 이용한 날짜 다루기 lubridate 패키지를 이용할 경우 날짜 형태와 관련된 다양한 작업을 수행할 수 있습니다. library(lubridate) x = c(&#39;2021-07-01&#39;, &#39;2021-08-01&#39;, &#39;2021-09-01&#39;) y = c(&#39;07/01/2015&#39;, &#39;08/01/2015&#39;, &#39;09/01/2015&#39;) ymd(x) ## [1] &quot;2021-07-01&quot; &quot;2021-08-01&quot; &quot;2021-09-01&quot; mdy(y) ## [1] &quot;2015-07-01&quot; &quot;2015-08-01&quot; &quot;2015-09-01&quot; lubridate 패키지를 이용할 경우 YYYY-MM-DD 형태는 ymd(), MM-DD-YYYY 형태는 mdy() 함수를 사용해 손쉽게 Date 형태로 변경할 수 있습니다. 이 외에도 lubridate에는 Date 형태로 변경하기 위한 다양한 함수가 존재합니다. 표 0.1: lubridate 패키지의 Date 형태 변경 함수 순서 함수 연, 월, 일 ymd() 연, 일, 월 ydm() 월, 일, 연 mdy() 일, 월, 연 dmy() 시, 분 hm() 시, 분, 초 hms() 연, 월, 일, 시, 분, 초 ymd_hms() lubridate 패키지에는 날짜 관련 정보를 추출할 수 있는 다양한 함수가 존재합니다. 표 0.2: lubridate 패키지의 날짜 관련 정보 추출 함수 정보 함수 연 year() 월 month() 주 week() 연도 내 일수 yday() 월 내 일수 mday() 주 내 일수 wday() 시 hour() 분 minute() 초 second() 타임존 tz() x = c(&#39;2021-07-01&#39;, &#39;2021-08-01&#39;, &#39;2021-09-01&#39;) year(x) ## [1] 2021 2021 2021 month(x) ## [1] 7 8 9 week(x) ## [1] 26 31 35 year(), month(), week() 함수를 통해 년도, 월, 주 정보를 확인할 수 있습니다. z = &#39;2021-09-15&#39; yday(z) ## [1] 258 mday(z) ## [1] 15 wday(z) ## [1] 4 yday(), mday(), wday() 함수는 각각 해당 년도에서 몇번째 일인지, 해당 월에서 몇번째 일인지, 해당 주에서 몇번째 일인지를 계산합니다. x = ymd(&#39;2021-07-01&#39;, &#39;2021-08-01&#39;, &#39;2021-09-01&#39;) x + years(1) - days(c(2, 9, 21)) ## [1] &quot;2022-06-29&quot; &quot;2022-07-23&quot; &quot;2022-08-11&quot; 날짜에서 연과 월, 일자를 더하거나 빼는 계산 역시 가능합니다. 먼저 year() 함수를 통해 1년씩을 더 하였으며, days() 함수를 통해 각각의 일자 만큼을 뺍니다. 0.5.3.2 날짜 순서 생성하기 숫자와 마찬가지로 seq() 함수를 이용할 경우 날짜 벡터를 생성할 수 있습니다. seq(ymd(&#39;2015-01-01&#39;), ymd(&#39;2021-01-01&#39;), by =&#39;years&#39;) ## [1] &quot;2015-01-01&quot; &quot;2016-01-01&quot; &quot;2017-01-01&quot; &quot;2018-01-01&quot; &quot;2019-01-01&quot; ## [6] &quot;2020-01-01&quot; &quot;2021-01-01&quot; 2015년 1월 1일부터 2021년 1월 1일까지 1년을 기준으로 벡터가 생성됩니다. seq(ymd(&#39;2021-09-01&#39;), ymd(&#39;2021-09-30&#39;), by =&#39;2 days&#39;) ## [1] &quot;2021-09-01&quot; &quot;2021-09-03&quot; &quot;2021-09-05&quot; &quot;2021-09-07&quot; &quot;2021-09-09&quot; ## [6] &quot;2021-09-11&quot; &quot;2021-09-13&quot; &quot;2021-09-15&quot; &quot;2021-09-17&quot; &quot;2021-09-19&quot; ## [11] &quot;2021-09-21&quot; &quot;2021-09-23&quot; &quot;2021-09-25&quot; &quot;2021-09-27&quot; &quot;2021-09-29&quot; 지정한 일수인 2일 단위로 날짜 벡터를 생성할 수도 있습니다. 이 외에도 by 인자를 통해 원하는 기간 단위의 벡터를 생성할 수 있습니다. 아래 페이지에는 lubridate 패키지의 자세한 사용법이 나와 있습니다. https://lubridate.tidyverse.org/ 0.6 데이터 구조 다루기 R에서 자주 사용되는 데이터구조는 벡터(Vector), 리스트(List), 데이터프레임(Dataframe) 입니다. 0.6.1 벡터 다루기 벡터는 R의 가장 기본적인 데이터 구조로써 integer, double, logical, character로 이루어져 있습니다. 벡터를 만드는 방법에 대해서는 앞서 다루었습니다. vec_integer = 8:17 vec_integer ## [1] 8 9 10 11 12 13 14 15 16 17 vec_double = c(0.5, 0.6, 0.2) vec_double ## [1] 0.5 0.6 0.2 vec_char = c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) vec_char ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; integer의 경우 start:end 형태를 통해서, 그 외에는 c() 함수를 통해 벡터를 만들 수 있습니다. c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2, 3) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; 숫자와 문자가 같이 벡터로 묶일 경우, 숫자는 모두 문자 형태로 변경됩니다. c(1, 2, 3, TRUE, FALSE) ## [1] 1 2 3 1 0 TRUE와 FALSE는 참 혹은 거짓을 나타내는 논리값(logical) 입니다. 숫자와 논리값이 같이 묶일 경우 TRUE는 1, FALSE는 0으로 치환된 후 숫자 형태로 변경됩니다. c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, TRUE, FALSE) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;TRUE&quot; &quot;FALSE&quot; 문자와 논리값이 같이 묶일 경우 모두 문자 형태로 변경됩니다. 이처럼 문자와 다른 형태가 묶일 경우엔 모든 데이터가 문자로 변경됩니다. 이번에는 기존의 벡터에 새로운 값을 추가해보겠습니다. v1 = 8:17 c(v1, 18:22) ## [1] 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 기존 8부터 17까지의 숫자로 이루어진 v1 벡터에, c() 함수를 이용하여 새로운 값을 추가할 수 있습니다. 만약 벡터에서 원하는 부분의 데이터를 추출하려면 대괄호([])를 이용하면 됩니다. v1[2] ## [1] 9 v1[2:4] ## [1] 9 10 11 v1[c(2, 4, 6)] ## [1] 9 11 13 대괄호 안에 숫자를 입력하면, 벡터에서 해당 순서의 데이터가 추출됩니다. c(2,4,6)과 같이 특정 위치를 지정하여 데이터를 추출할 수도 있습니다. v1[-1] ## [1] 9 10 11 12 13 14 15 16 17 v1[-c(2, 4, 6, 8)] ## [1] 8 10 12 14 16 17 마이너스 기호를 입력하면, 해당 순서를 제외한 데이터가 추출됩니다. v1 &lt; 12 ## [1] TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE FALSE v1[v1 &lt; 12] ## [1] 8 9 10 11 v1[v1 &lt; 12 | v1 &gt; 15] ## [1] 8 9 10 11 16 17 먼저 v1 &lt; 12를 입력하면 해당 조건에 해당하는 부분은 TRUE, 그렇지 않은 부분은 FALSE를 반환합니다. 그 후 대괄호 안에 다시 결과를 입력하면 TRUE에 해당하는 순서의 데이터만 반환합니다. 이처럼 대괄호 내부에 조건을 설정하여 원하는 데이터를 추출할 수도 있습니다. 0.6.2 리스트 다루기 먼저 리스트를 생성합니다. l = list(1:3, &#39;a&#39;, c(TRUE, FALSE, TRUE), c(2.5, 4.2)) str(l) ## List of 4 ## $ : int [1:3] 1 2 3 ## $ : chr &quot;a&quot; ## $ : logi [1:3] TRUE FALSE TRUE ## $ : num [1:2] 2.5 4.2 첫번째 원소는 정수(int), 두번째 원소는 문자(chr), 세번째 원소는 논리값(logi), 네번째 원손,ㄴ 숫자(num)으로 이루어져 있습니다. 이처럼 리스트는 각 원소간 타입이나 길이가 달라도 데이터가 결합할 수 특징이 있습니다. l2 = list(1:3, list(letters[1:5], c(TRUE, FALSE, TRUE))) str(l2) ## List of 2 ## $ : int [1:3] 1 2 3 ## $ :List of 2 ## ..$ : chr [1:5] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... ## ..$ : logi [1:3] TRUE FALSE TRUE 위 예제에서 두번째 원소는 리스트로 구성되어 있습니다. 이처럼 리스트 내에 또 다른 리스트를 생성하는 것 역시 가능합니다. 이번에는 기존 리스트에 새로운 원소를 추가하도록 하겠습니다. l3 = list(1:3, &#39;a&#39;, c(TRUE, FALSE, TRUE)) l4 = append(l3, list(c(2.5, 4.2))) print(l4) ## [[1]] ## [1] 1 2 3 ## ## [[2]] ## [1] &quot;a&quot; ## ## [[3]] ## [1] TRUE FALSE TRUE ## ## [[4]] ## [1] 2.5 4.2 append() 함수를 이용하면 기존 리스트에 추가로 원소를 붙일 수 있습니다. l4$item5 = &#39;new list item&#39; print(l4) ## [[1]] ## [1] 1 2 3 ## ## [[2]] ## [1] &quot;a&quot; ## ## [[3]] ## [1] TRUE FALSE TRUE ## ## [[4]] ## [1] 2.5 4.2 ## ## $item5 ## [1] &quot;new list item&quot; 또한 기존 리스트에 달러 사인($)을 입력할 경우, 원소에 이름이 생성되며 데이터가 추가됩니다. 리스트에서 원하는 데이터를 추출할 때는, 벡터와 동일하게 대괄호를 이용하면 됩니다. l4[1] ## [[1]] ## [1] 1 2 3 l4[c(1,3)] ## [[1]] ## [1] 1 2 3 ## ## [[2]] ## [1] TRUE FALSE TRUE 원소에 이름이 있을 경우, 이를 이용해 추출도 가능합니다. l4[&#39;item5&#39;] ## $item5 ## [1] &quot;new list item&quot; 원소의 이름인 item5를 입력하면 해당 원소만 반환합니다. l4[[1]] ## [1] 1 2 3 l4$item5 ## [1] &quot;new list item&quot; 대괄호를 두번, 혹은 달러 사인($)을 이용해 데이터를 추출할 경우 원소 내의 형태가 반환되며, 위의 예제들과는 다르게 벡터 형태가 반환되었습니다. l4[[1]] ## [1] 1 2 3 l4[[1]][3] ## [1] 3 특정 원소의 항목을 추출하기 위해서는 [[와 [를 함께 사용합니다. 위 예제는 l4 리스트의 첫번째 원소에서 3번째 항목을 추출하게 됩니다. 0.6.3 데이터프레임 다루기 데이터프레임은 R에서 가장 널리 사용되는 형식으로써, 각 컬럼이 다른 형태를 가질 수 있습니다. df = data.frame (col1 = 1:3, col2 = c (&quot;this&quot;, &quot;is&quot;, &quot;text&quot;), col3 = c (TRUE, FALSE, TRUE), col4 = c (2.5, 4.2, pi)) str(df) ## &#39;data.frame&#39;: 3 obs. of 4 variables: ## $ col1: int 1 2 3 ## $ col2: chr &quot;this&quot; &quot;is&quot; &quot;text&quot; ## $ col3: logi TRUE FALSE TRUE ## $ col4: num 2.5 4.2 3.14 col1은 숫자(int), col2는 문자(chr), col3는 논리연산자(logi), col4는 숫자(num)로 구성되어 있습니다. 또한 벡터 혹은 리스트를 이용해 데이터프레임을 생성할 수도 있습니다. v1 = 1:3 v2 = c (&quot;this&quot;, &quot;is&quot;, &quot;text&quot;) v3 = c (TRUE, FALSE, TRUE) data.frame(col1 = v1, col2 = v2, col3 = v3) ## col1 col2 col3 ## 1 1 this TRUE ## 2 2 is FALSE ## 3 3 text TRUE v1, v2, v3는 각각 숫자, 문자, 논리연산로 구성된 벡터입니다. 이를 data.frame() 함수 내에 입력할 경우 col1, col2, col3 열 이름에 해당 데이터들이 입력됩니다. 주의해야 할 점은 각 벡터의 길이가 동일해야 데이터프레임 형태를 만들 수 있습니다. l = list (item1 = 1:3, item2 = c (&quot;this&quot;, &quot;is&quot;, &quot;text&quot;), item3 = c (2.5, 4.2, 5.1)) l ## $item1 ## [1] 1 2 3 ## ## $item2 ## [1] &quot;this&quot; &quot;is&quot; &quot;text&quot; ## ## $item3 ## [1] 2.5 4.2 5.1 data.frame(l) ## item1 item2 item3 ## 1 1 this 2.5 ## 2 2 is 4.2 ## 3 3 text 5.1 리스트 역시 data.frame() 함수를 이용할 경우, 각 원소명을 열이름으로 한 데이터프레임이 생성됩니다. 이 경우 역시 각 원소의 데이터 길이가 동일해야 합니다. 기존 데이터프레임에 행방향 혹은 열방향으로 데이터를 추가할 수 있습니다. df ## col1 col2 col3 col4 ## 1 1 this TRUE 2.500 ## 2 2 is FALSE 4.200 ## 3 3 text TRUE 3.142 v4 = c (&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) cbind(df, v4) ## col1 col2 col3 col4 v4 ## 1 1 this TRUE 2.500 A ## 2 2 is FALSE 4.200 B ## 3 3 text TRUE 3.142 C cbind() 함수는 ’column bind’의 약어로써, 기존 데이터프레임에 새로운 열을 추가합니다. v5 = c (4, &quot;R&quot;, F, 1.1) rbind(df, v5) ## col1 col2 col3 col4 ## 1 1 this TRUE 2.5 ## 2 2 is FALSE 4.2 ## 3 3 text TRUE 3.14159265358979 ## 4 4 R FALSE 1.1 rbind() 함수는 ’row bind’의 약어로써, 기존 데이터프레임에 새로운 행을 추가합니다. 주의할 점은 각 행의 데이터 형태가 기존 데이터의 형태와 일치해야 합니다. 데이터프레임 역시 대괄호를 이용해 데이터를 추출할 수 있으며, 공백으로 두면 모든 행(열)을 선택하게 됩니다. df ## col1 col2 col3 col4 ## 1 1 this TRUE 2.500 ## 2 2 is FALSE 4.200 ## 3 3 text TRUE 3.142 df[2:3, ] ## col1 col2 col3 col4 ## 2 2 is FALSE 4.200 ## 3 3 text TRUE 3.142 데이터프레임중 2:3, 즉 두번째부터 세번째까지의 행과 모든 열을 선택하게 됩니다. df[ , c(&#39;col2&#39;, &#39;col4&#39;)] ## col2 col4 ## 1 this 2.500 ## 2 is 4.200 ## 3 text 3.142 행이름 혹은 열이름 직접 입력하여 해당값을 추출할 수도 있습니다. 위 예제에서는 열이름이 col2와 col4인 열을 추출합니다. df[, 2] ## [1] &quot;this&quot; &quot;is&quot; &quot;text&quot; df[, 2, drop = FALSE] ## col2 ## 1 this ## 2 is ## 3 text 만일 하나의 열만 선택시 결과가 벡터 형태로 추출되며, drop = FALSE 인자를 추가해주면 데이터프레임의 형태가 유지되어 추출됩니다. 0.6.4 결측치 처리하기 결측치란 누락된 데이터를 의미하며, 데이터 분석에서 결측치를 처리하는 것은 매우 중요합니다. R에서 결측치는 NA로 표시되며, is.na() 함수를 통해 결측치 여부를 확인할 수 있습니다. x = c(1:4, NA, 6:7, NA) x ## [1] 1 2 3 4 NA 6 7 NA is.na(x) ## [1] FALSE FALSE FALSE FALSE TRUE FALSE FALSE TRUE 데이터가 NA인 경우에는 TRUE, 그렇지 않을 경우 FALSE를 반환합니다. 데이터프레임에도 해당 함수를 적용할 수 있습니다. df = data.frame (col1 = c (1:3, NA), col2 = c (&quot;this&quot;, NA,&quot;is&quot;, &quot;text&quot;), col3 = c (TRUE, FALSE, TRUE, TRUE), col4 = c (2.5, 4.2, 3.2, NA), stringsAsFactors = FALSE) df ## col1 col2 col3 col4 ## 1 1 this TRUE 2.5 ## 2 2 &lt;NA&gt; FALSE 4.2 ## 3 3 is TRUE 3.2 ## 4 NA text TRUE NA is.na(df) ## col1 col2 col3 col4 ## [1,] FALSE FALSE FALSE FALSE ## [2,] FALSE TRUE FALSE FALSE ## [3,] FALSE FALSE FALSE FALSE ## [4,] TRUE FALSE FALSE TRUE 데이터에 결측치가 있는 경우 계산이 불가능하다는 문제가 발생합니다. y = c(1, 3, NA, 4) mean(y) ## [1] NA 데이터의 중간에 결측치인 NA가 존재하여 평균을 계산할 수 없으며, 이 외에도 모든 연산이 불가능하게 됩니다. mean(y, na.rm = TRUE) ## [1] 2.667 na.rm에서 rm은 ’remove’의 약어입니다. 즉 해당 인자를 TRUE로 설정할 경우 NA를 제외하고 연산을 수행합니다. 따라서 1,3,4의 평균인 \\(\\frac{1+3+4}{3} = 2.6667\\)이 계산됩니다. 일반적으로 결측치가 있는 경우 해당 데이터는 문제가 있다고 판단하여 제거하거나, 다른 데이터로 대체하여 채워넣기도 합니다. 먼저 결측치가 있는 데이터를 제거하는 법을 알아보겠습니다. df = data.frame (col1 = c (1:4), col2 = c (&quot;this&quot;, NA,&quot;is&quot;, &quot;text&quot;), col3 = c (TRUE, FALSE, TRUE, TRUE), col4 = c (2.5, 4.2, 3.2, 5.0) ) df ## col1 col2 col3 col4 ## 1 1 this TRUE 2.5 ## 2 2 &lt;NA&gt; FALSE 4.2 ## 3 3 is TRUE 3.2 ## 4 4 text TRUE 5.0 두번째 행 col2 열에 결측치가 있으므로, 해당 부분을 제거해주도록 합니다. na.omit(df) ## col1 col2 col3 col4 ## 1 1 this TRUE 2.5 ## 3 3 is TRUE 3.2 ## 4 4 text TRUE 5.0 na.omit() 함수를 이용하면 NA가 위치한 부분의 데이터가 제거됩니다. x = c(1:4, NA, 6:7, NA) x ## [1] 1 2 3 4 NA 6 7 NA 이번에는 위와 같이 결측치가 있는 경우, 다른 데이터로 대체하도록 하겠습니다. x[is.na(x)] = mean(x, na.rm = TRUE) x ## [1] 1.000 2.000 3.000 4.000 3.833 6.000 7.000 3.833 mean() 함수 내부를 통해 값들의 평균을 구한 후, is.na() 함수를 통해 결측치가 위치한 부분의 데이터를 평균값인 3.833 으로 대체하였습니다. 이 외에도 결측치를 대체하는데는 다양한 방법이 존재합니다. 0.7 데이터 불러오기 및 내보내기 일반적으로 사람들은 csv 혹은 엑셀 파일로 저장된 데이터를 주고 받으며 데이터 분석을 하는 경우가 많습니다. 해당 형식의 파일을 R로 불러오는 법 그리고 저장하는 법에 대해 알아보겠습니다. csv와 엑셀 샘플 파일의 주소는 다음과 같습니다. https://github.com/hyunyulhenry/fin_ds/blob/master/data/kospi.csv https://github.com/hyunyulhenry/fin_ds/blob/master/data/kospi.xlsx 아래의 코드를 실행하면 해당 파일을 PC에 다운로드 받을 수 있습니다. download.file(&#39;https://raw.githubusercontent.com/hyunyulhenry/fin_ds/master/data/kospi.csv&#39;, &#39;kospi.csv&#39;) download.file(&#39;https://github.com/hyunyulhenry/fin_ds/raw/master/data/kospi.xlsx&#39;, &#39;kospi.xlsx&#39;, mode = &#39;wb&#39;) 0.7.1 워킹 디렉터리 데이터를 불러오거나 내보낼 때 초보자들이 가장 많이 하는 실수가 워킹 디렉터리를 제대로 설정하지 않는 것입니다. 워킹 디렉터리(Working Directory)란 현재 사용중인 폴더를 의미하며, 현재 워킹 디렉터리는 콘솔창 상단 getwd() 함수를 통해 확인할 수 있습니다. getwd() # [1] &quot;C:/Users/henry/Documents/R/fin_ds&quot; 파일들이 A 폴더에 있는데 워킹 디렉터리가 B 폴더인 상태에서는 파일을 불러올 수 없으므로, 해당 파일들이 현재 워킹 디렉터리에 있어야 합니다. 워킹 디렉터리를 변경할때는 setwd() 함수를 통해 위치를 직접 지정해주어도 되지만, R 스튜디오의 파일 창을 이용하면 손쉽게 변경할 수 있습니다. 먼저 파일 창 상단의 […] 부분을 클릭합니다. 그림 0.21: 워킹 디렉터리 변경 탐색기 화면에서 원하는 폴더를 선택한 후 하단의 [Open]을 클릭합니다. 그림 0.22: 워킹 디렉터리 변경 (2) 탐색기 화면에 선택한 폴더의 파일들이 보입니다. 이제 [Move → Set As Working Directory]를 클릭하면 콘솔창에 해당 폴더를 워킹 디렉터리로 변경하는 코드가 입력되면서, 워킹 디렉터리 위치가 해당 폴더로 변경됩니다. 그림 0.23: 워킹 디렉터리 변경 (3) 0.7.2 csv 파일 불러오기 및 저장하기 먼저 R의 기본함수인 read.csv() 함수를 이용하면 매우 손쉽게 csv 파일을 불러올 수 있습니다. kospi = read.csv(&#39;kospi.csv&#39;) head(kospi) ## 癤풡ate Close Ret ## 1 2020-01-02 2175 -1.02 ## 2 2020-01-03 2176 0.06 ## 3 2020-01-06 2155 -0.98 ## 4 2020-01-07 2176 0.95 ## 5 2020-01-08 2151 -1.11 ## 6 2020-01-09 2186 1.63 readr 패키지의 read._csv() 함수를 이용하면 기본 함수 대비 10배 정도 빠르게 데이터를 불러올 수 있으며, 훨씬 다양한 조건을 입력할 수도 있습니다. library(readr) kospi2 = read_csv(&#39;kospi.csv&#39;) head(kospi2) ## # A tibble: 6 x 3 ## Date Close Ret ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2020-01-02 2175. -1.02 ## 2 2020-01-03 2176. 0.06 ## 3 2020-01-06 2155. -0.98 ## 4 2020-01-07 2176. 0.95 ## 5 2020-01-08 2151. -1.11 ## 6 2020-01-09 2186. 1.63 R의 데이터를 csv로 저장하는 법은 기본함수의 write.csv() 혹은 readr 패키지의 write_csv() 함수를 이용하면 됩니다. # using write.csv write.csv(kospi, &#39;kospi2.csv&#39;, row.names = FALSE) # using write_csv write_csv(kospi2, &#39;kospi2.csv&#39;) 기본함수인 write.csv() 의 경우 행이름이 자동으로 새로운 열로 추가되어 저장되므로, 이를 원하지 않을 경우 row.names = FALSE 를 추가로 입력해주어야 합니다. 0.7.3 엑셀 파일 불러오기 및 저장하기 R의 기본함수 중에는 엑셀 파일을 불러오는 함수가 없지만, 해당 작업을 수행하는 다양한 패키지가 존재합니다. 그 중에서 readr 패키지와 쌍둥이 격인 readxl 패키지를 이용해보겠습니다. 먼저 해당 패키지의 read_excel() 함수를 이용해 엑셀 파일을 불러올 수 있습니다. library(readxl) kospi_excel = read_excel(&#39;kospi.xlsx&#39;, sheet = &#39;kospi&#39;) head(kospi_excel) ## # A tibble: 6 x 3 ## Date Close Ret ## &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2020-01-02 00:00:00 2175. -1.02 ## 2 2020-01-03 00:00:00 2176. 0.06 ## 3 2020-01-06 00:00:00 2155. -0.98 ## 4 2020-01-07 00:00:00 2176. 0.95 ## 5 2020-01-08 00:00:00 2151. -1.11 ## 6 2020-01-09 00:00:00 2186. 1.63 엑셀은 여러 시트로 구성된 경우가 많으며, sheet에 특정 시트명을 입력하면 해당 시트의 내용을 불러오게 됩니다. 만일 아무값도 입력하지 않을 경우 가장 첫번째 시트의 데이터를 불러옵니다. 반대로 R의 데이터를 엑셀로 저장하는 방법은 writexl 패키지의 write_xlsx() 함수를 이용하면 됩니다. library(writexl) write_xlsx(kospi_excel, &#39;kospi_excel.xlsx&#39;) 0.8 효율성과 가독성 높이기 이번에는 프로그래밍의 효율성을 높이기 위해 자주 사용되는 함수와 루프 구문, 그리고 가독성을 높이기 위한 파이프 오퍼레이터에 대해 알아보겠습니다. 0.8.1 함수 동일하거나 비슷한 작업을 반복해야 하는 경우 매번 실행하거나 복사-붙여넣기 하기 보다는 경우 함수를 작성하여 사용하면 매우 효율적으로 작업이 가능합니다. 함수는 크게 세가지 요소로 구성됩니다. body(): 함수 내부의 코드 formals(): 인자(argument) 내역 environment(): 함수의 변수에 대한 위치 예를 들어 금융 자산의 현재 가치는 다음과 같이 계산됩니다. \\[PV = FV / (1+r)^n\\] PV: 현재 가치 FV: 미래 가치 r: 할인률 n: 기간 즉, 1년 뒤에 110만원을 받는 돈의 현재가치는 \\(110만원/(1+0.1)^1 = 100만원\\) 이라 볼 수 있습니다. 이러한 값을 구하기 위해 매번 계산기를 사용하기 보다는 함수를 이용하면, 훨씬 효율적인 작업이 가능합니다. 위의 수식을 함수로 나타내면 다음과 같습니다. PV = function(FV, r, n) { PV = FV / (1+r)^n return(round(PV, 2)) } R에서는 함수명 = function(인자) {함수 내용}의 형태로 함수를 만들수 있으며, 반환하고자 하는 결과를 return() 내부에 작성합니다. 함수의 구성요소 세가지를 한번 확인해보도록 하겠습니다. body(PV) ## { ## PV = FV/(1 + r)^n ## return(round(PV, 2)) ## } 먼저 body는 함수 내부의 코드를 의미합니다. formals(PV) ## $FV ## ## ## $r ## ## ## $n formals에는 함수의 인자인 FV, r, n이 있습니다. environment(PV) ## &lt;environment: R_GlobalEnv&gt; 함수는 GlobalEnv에 위치하고 있습니다. 이제 해당함수를 이용해 현재가치를 계산해보도록 하겠습니다. PV(FV = 1000, r = 0.08, n = 5) ## [1] 680.6 \\(1000 / (1.08)^5\\)의 값인 680.58이 간단하게 계산됩니다. PV(1000, 0.08, 5) ## [1] 680.6 만약 인자의 리스트를 생략하면, 입력한 순서대로 값이 입력됩니다. PV(r = 0.08, FV = 1000, n = 5) ## [1] 680.6 인자의 내역을 정확하게 지정해준다면, 순서대로 입력하지 않아도 됩니다. PV(1000, 0.08) ## Error in PV(1000, 0.08): 기본값이 없는 인수 &quot;n&quot;가 누락되어 있습니다 PV() 함수에 필요한 인자는 3개인 반면, 2개만 입력하였으므로 에러가 발생합니다. PV = function(FV = 1000, r = .08, n = 5) { PV = FV / (1 + r)^n return(round(PV, 2)) } PV(1000, 0.08) ## [1] 680.6 만일 함수의 인자에 디폴트 값이 입력되어 있다면, 함수 실행시 이를 생략하여도 디폴트 값이 입력됩니다. 위 예제에서는 n 디폴트 값으로 5가 들어가있으며, PV() 함수 내에 입력값이 3개만 입력될 경우 마지막 인자는 디폴트 값인 5를 적용합니다. 0.8.2 루프 구문 루프 및 각종 구문을 이용하여 휴율적인 작업을 하는것도 가능합니다. 0.8.2.1 if 구문 먼저 if 구문은 다음과 같이 구성됩니다. if (test_expression) { statement } 괄호 안의 test_expression이 TRUE일 경우에만 statement 코드가 실행됩니다. 간단한 예제를 살펴보겠습니다. x = c(8, 3, -2, 5) if (any(x &lt; 0)) { print(&#39;x contains negative number&#39;) } ## [1] &quot;x contains negative number&quot; any() 함수는 적어도 하나의 값이 참이면 참으로 출력하는 함수입니다. 즉, 위의 코드는 x중 하나라도 0보다 작은 값이 있으면 x contains negative number라는 문장을 출력하며, -2가 0보다 작으므로 해당 문장을 출력합니다. y = c (8, 3, 2, 5) if (any (y &lt; 0)) { print (&quot;y contains negative numbers&quot;) } 이번에는 y에 0보다 작은 값이 없으므로, 구문이 실행되지 않아 문장을 출력하지 않습니다. 이처럼 if 구문만 존재할 시 이를 만족하지 않는 경우 아무런 구문도 실행되지 않습니다. 만일 조건을 충족하지 않을 때 동작을 추가하고 싶을 경우 if else 구문을 사용하며, 이는 if의 조건을 만족하지 않을 경우 else에 해당하는 구문이 실행됩니다. if (test_expression) { statement 1 } else { statement 2 } 만일 test_expression 구문이 TRUE이면 statement 1이 실행되며, 그렇지 않을 경우 statement 2가 실행됩니다. 실제 예제를 살펴봅시다. y = c (8, 3, 2, 5) if (any (y &lt; 0)) { print (&quot;y contains negative numbers&quot;) } else { print (&quot;y contains all positive numbers&quot;) } ## [1] &quot;y contains all positive numbers&quot; y에 음수가 존재하는 if 구문이 FALSE 이므로, else에 해당하는 메세지가 출력됩니다. ifelse 구문은 ifelse() 함수로 간단히 나타낼 수도 있습니다. x = c (8, 3, 2, 5) ifelse(any(x &lt; 0), &quot;x contains negative numbers&quot;, &quot;x contains all positive numbers&quot;) ## [1] &quot;x contains all positive numbers&quot; 해당 함수는 ifelse(test, yes, no) 형태로 입력되며, test를 충족하면 yes가 그렇지 않으면 no가 실행됩니다. 위의 예에서는 x에 0보다 작은 값이 없으므로, no에 해당하는 내용이 실행됩니다. 또한 if와 else 사이에 else if 조건을 통해, 여러 조건을 추가할 수도 있습니다. x = 7 if (x &gt;= 10) { print (&quot;x exceeds acceptable tolerance levels&quot;) } else if(x &gt;= 0 &amp; x &lt; 10) { print (&quot;x is within acceptable tolerance levels&quot;) } else { print (&quot;x is negative&quot;) } ## [1] &quot;x is within acceptable tolerance levels&quot; 위 조건은 다음과 같습니다. x가 10 이상일 경우 x exceeds acceptable tolerance levels을 출력합니다. 만일 x가 10 이상, 10 미만일경우 x is within acceptable tolerance levels을 출력합니다. 그렇지 않을 경우 x is negative을 출력합니다. x는 7 이므로 else에 해당하는 내용이 출력됩니다. 0.8.2.2 for loop 구문 for loop 구문은 특정한 부분의 코드가 반복적으로 수행될 수 있도록 하며, 다음과 같이 구성됩니다. for (i in 1:100) { &lt;code: do stuff here with i&gt; } 먼저 i에 1이 들어간 뒤 code에 해당하는 부분이 실행됩니다. 그 후, i에 2가 들어간 뒤 다시 code가 실행되며 이 작업이 100까지 반복됩니다. 실제 예제를 살펴보도록 하겠습니다. for (i in 2016:2020) { output = paste(&quot;The year is&quot;, i) print(output) } ## [1] &quot;The year is 2016&quot; ## [1] &quot;The year is 2017&quot; ## [1] &quot;The year is 2018&quot; ## [1] &quot;The year is 2019&quot; ## [1] &quot;The year is 2020&quot; i에 2010부터 2016 까지 대입되며, The year is라는 문자와 결합해 결과가 출력됩니다. 0.8.2.3 apply 계열 함수 apply 계열의 함수는 loop 구문과 비슷한 역할을 하며, 코드를 훨씬 간결하게 표현할 수 있습니다. 먼저 가장 기본이 되는 apply() 함수는 데이터프레임의 행 혹은 열단위 계산에 자주 사용됩니다. 해당 함수는 다음과 같이 구성됩니다. apply(x, MARGIN, FUN, ...) x: 매트릭스, 데이터프레임, 혹은 어레이 MARGIN: 함수가 적용될 벡. 1은 행을, 2는 열을, c(1, 2)는 행과 열을 의미 FUN: 적용될 함수 …: 기타 실제 사용 예제를 살펴보도록 하겠습니다. head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 먼저 위 데이터에서 각 열의 평균을 구하도록 합니다. apply(mtcars, 2, mean) ## mpg cyl disp hp drat wt qsec vs ## 20.0906 6.1875 230.7219 146.6875 3.5966 3.2172 17.8487 0.4375 ## am gear carb ## 0.4062 3.6875 2.8125 mtcars에서 2 즉 열의 방향으로 평균(mean)을 구합니다. lapply() 함수는 리스트에 적용되며, 결과 또한 리스트로 반환됩니다. 해당 함수는 다음과 같이 구성됩니다. lapply(x, FUN, ...) x: 리스트 FUN: 적용될 함수 …: 기타 실제 사용 예제를 살펴보도록 하겠습니다. data = list(item1 = 1:4, item2 = rnorm(10), item3 = rnorm(20, 1), item4 = rnorm(100, 5)) data ## $item1 ## [1] 1 2 3 4 ## ## $item2 ## [1] -0.56048 -0.23018 1.55871 0.07051 0.12929 1.71506 0.46092 -1.26506 ## [9] -0.68685 -0.44566 ## ## $item3 ## [1] 2.22408 1.35981 1.40077 1.11068 0.44416 2.78691 1.49785 -0.96662 ## [9] 1.70136 0.52721 -0.06782 0.78203 -0.02600 0.27111 0.37496 -0.68669 ## [17] 1.83779 1.15337 -0.13814 2.25381 ## ## $item4 ## [1] 5.426 4.705 5.895 5.878 5.822 5.689 5.554 4.938 4.694 4.620 4.305 4.792 ## [13] 3.735 7.169 6.208 3.877 4.597 4.533 5.780 4.917 5.253 4.971 4.957 6.369 ## [25] 4.774 6.516 3.451 5.585 5.124 5.216 5.380 4.498 4.667 3.981 3.928 5.304 ## [37] 5.448 5.053 5.922 7.050 4.509 2.691 6.006 4.291 4.312 6.026 4.715 3.779 ## [49] 5.181 4.861 5.006 5.385 4.629 5.644 4.780 5.332 6.097 5.435 4.674 6.149 ## [61] 5.994 5.548 5.239 4.372 6.361 4.400 7.187 6.533 4.764 3.974 4.290 5.257 ## [73] 4.753 4.652 4.048 4.955 4.215 3.332 4.620 5.919 4.425 5.608 3.382 4.944 ## [85] 5.519 5.301 5.106 4.359 4.150 3.976 5.118 4.053 4.509 4.744 6.844 4.348 ## [97] 5.235 5.078 4.038 4.929 4개의 원소로 구성된 리스트에서 각 원소의 평균을 구하고자 할 경우, 리스트에 적용되는 apply인 lapply() 함수를 사용해야 합니다. lapply(data, mean) ## $item1 ## [1] 2.5 ## ## $item2 ## [1] 0.07463 ## ## $item3 ## [1] 0.892 ## ## $item4 ## [1] 5.022 lapply() 함수를 통해 각 항목의 평균을 구할 수 있으며, 결과 또한 리스트 형태로 반환됩니다. 해당 함수는 좀더 복잡한 형태로 응용도 가능합니다. beaver_data = list(beaver1 = beaver1, beaver2 = beaver2) lapply(beaver_data, head) ## $beaver1 ## day time temp activ ## 1 346 840 36.33 0 ## 2 346 850 36.34 0 ## 3 346 900 36.35 0 ## 4 346 910 36.42 0 ## 5 346 920 36.55 0 ## 6 346 930 36.69 0 ## ## $beaver2 ## day time temp activ ## 1 307 930 36.58 0 ## 2 307 940 36.73 0 ## 3 307 950 36.93 0 ## 4 307 1000 37.15 0 ## 5 307 1010 37.23 0 ## 6 307 1020 37.24 0 위 데이터의 각 항목에서 열 별 평균을 구하고자 할 경우 lapply() 함수 만으로는 계산이 불가능합니다. 이러한 경우 해당 함수 내부에 새로운 함수인 function()을 정의하여 복잡한 계산을 수행할 수 있습니다. lapply(beaver_data, function(x) { round(apply(x, 2, mean), 2) }) ## $beaver1 ## day time temp activ ## 346.20 1312.02 36.86 0.05 ## ## $beaver2 ## day time temp activ ## 307.13 1446.20 37.60 0.62 function(x)를 통해 각 항목에 적용될 함수를 직접 정의할 수 있습니다. 우리가 정의한 함수는 apply() 함수를 통해 열의 방향으로 평균을 구한 뒤 소수 둘째 자리까지 반올림을 하는 것이며, 해당 함수가 리스트의 모든 원소에 적용됩니다. 마지막으로 살펴볼 sapply() 함수는 lapply() 함수와 거의 동일하며, 결과가 리스트가 아닌 벡터 혹은 매트릭스로 출력된다는 점만 차이가 있습니다. lapply(beaver_data, function(x) { round(apply(x, 2, mean), 2) }) ## $beaver1 ## day time temp activ ## 346.20 1312.02 36.86 0.05 ## ## $beaver2 ## day time temp activ ## 307.13 1446.20 37.60 0.62 sapply(beaver_data, function(x) { round(apply(x, 2, mean), 2) }) ## beaver1 beaver2 ## day 346.20 307.13 ## time 1312.02 1446.20 ## temp 36.86 37.60 ## activ 0.05 0.62 sapply() 함수는 각 원소에 적용된 값을 벡터로 하는 매트릭스 형태로 결과값이 출력됩니다. 0.8.2.4 기타 함수 열과 행이 합계나 평균처럼 일반적으로 많이 사용되는 계산에는 apply() 함수보다 간단하게 표현할 수 있는 함수들이 있습니다. rowSums(mtcars) ## Mazda RX4 Mazda RX4 Wag Datsun 710 Hornet 4 Drive ## 329.0 329.8 259.6 426.1 ## Hornet Sportabout Valiant Duster 360 Merc 240D ## 590.3 385.5 656.9 271.0 ## Merc 230 Merc 280 Merc 280C Merc 450SE ## 299.6 350.5 349.7 510.7 ## Merc 450SL Merc 450SLC Cadillac Fleetwood Lincoln Continental ## 511.5 509.9 728.6 726.6 ## Chrysler Imperial Fiat 128 Honda Civic Toyota Corolla ## 725.7 213.8 195.2 207.0 ## Toyota Corona Dodge Challenger AMC Javelin Camaro Z28 ## 273.8 519.6 506.1 646.3 ## Pontiac Firebird Fiat X1-9 Porsche 914-2 Lotus Europa ## 631.2 208.2 272.6 273.7 ## Ford Pantera L Ferrari Dino Maserati Bora Volvo 142E ## 670.7 379.6 694.7 288.9 colSums(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 642.9 198.0 7383.1 4694.0 115.1 103.0 571.2 14.0 13.0 118.0 90.0 rowSums() 함수는 행의 합계를, colSums() 함수는 열의 합계는 구하며 이는 apply(mtcars, 1 or 2, sum) 과 동일합니다. rowMeans(mtcars) ## Mazda RX4 Mazda RX4 Wag Datsun 710 Hornet 4 Drive ## 29.91 29.98 23.60 38.74 ## Hornet Sportabout Valiant Duster 360 Merc 240D ## 53.66 35.05 59.72 24.63 ## Merc 230 Merc 280 Merc 280C Merc 450SE ## 27.23 31.86 31.79 46.43 ## Merc 450SL Merc 450SLC Cadillac Fleetwood Lincoln Continental ## 46.50 46.35 66.23 66.06 ## Chrysler Imperial Fiat 128 Honda Civic Toyota Corolla ## 65.97 19.44 17.74 18.81 ## Toyota Corona Dodge Challenger AMC Javelin Camaro Z28 ## 24.89 47.24 46.01 58.75 ## Pontiac Firebird Fiat X1-9 Porsche 914-2 Lotus Europa ## 57.38 18.93 24.78 24.88 ## Ford Pantera L Ferrari Dino Maserati Bora Volvo 142E ## 60.97 34.51 63.16 26.26 colMeans(mtcars) ## mpg cyl disp hp drat wt qsec vs ## 20.0906 6.1875 230.7219 146.6875 3.5966 3.2172 17.8487 0.4375 ## am gear carb ## 0.4062 3.6875 2.8125 rowMeans() 함수와 colMeans() 함수 역시 각각 행과 열의 평균을 구합니다. 0.8.3 파이프 오퍼레이터 파이프 오퍼레이터는 R에서 동일한 데이터를 대상으로 연속으로 작업하게 해주는 오퍼레이터(연산자)입니다. 흔히 프로그래밍에서 x라는 데이터를 F()라는 함수에 넣어 결괏값을 확인하고 싶으면 F(x)의 방법을 사용합니다. 예를 들어 3과 5라는 데이터 중 큰 값을 찾으려면 max(3,5)를 통해 확인합니다. 이를 통해 나온 결괏값을 또 다시 G()라는 함수에 넣어 결괏값을 확인하려면 비슷한 과정을 거칩니다. max(3,5)를 통해 나온 값의 제곱근을 구하려면 result = max(3,5)를 통해 첫 번째 결괏값을 저장하고, sqrt(result)를 통해 두 번째 결괏값을 계산합니다. 물론 sqrt(max(3,5))와 같은 표현법으로 한 번에 표현할 수 있습니다. 이러한 표현의 단점은 계산하는 함수가 많아질수록 저장하는 변수가 늘어나거나 괄호가 지나치게 길어진다는 것입니다. 그러나 파이프 오퍼레이터인 %&gt;%를 사용하면 함수 간의 관계를 매우 직관적으로 표현하고 이해할 수 있습니다. 이를 정리하면 아래 표와 같습니다. 표 0.3: 파이프 오퍼레이터의 표현과 내용 비교 내용 표현 방법 F(x) x %&gt;% F G(F(x)) x %&gt;% F %&gt;% G 간단한 예제를 통해 파이프 오퍼레이터의 사용법을 살펴보겠습니다. 먼저 다음과 같은 10개의 숫자가 있다고 가정합니다. x = c(0.3078, 0.2577, 0.5523, 0.0564, 0.4685, 0.4838, 0.8124, 0.3703, 0.5466, 0.1703) 우리가 원하는 과정은 다음과 같습니다. 각 값들의 로그값을 구할 것 로그값들의 계차를 구할 것 구해진 계차의 지수값을 구할 것 소수 둘째 자리까지 반올림할 것 입니다. 즉 log(), diff(), exp(), round()에 대한 값을 순차적으로 구하고자 합니다. x1 = log(x) x2 = diff(x1) x3 = exp(x2) round(x3, 2) ## [1] 0.84 2.14 0.10 8.31 1.03 1.68 0.46 1.48 0.31 첫 번째 방법은 단계별 함수의 결괏값을 변수에 저장하고 저장된 변수를 다시 불러와 함수에 넣고 계산하는 방법입니다. 전반적인 계산 과정을 확인하기에는 좋지만 매번 변수에 저장하고 불러오는 과정이 매우 비효율적이며 코드도 불필요하게 길어집니다. round(exp(diff(log(x))), 2) ## [1] 0.84 2.14 0.10 8.31 1.03 1.68 0.46 1.48 0.31 두 번째는 괄호를 통해 감싸는 방법입니다. 앞선 방법에 비해 코드는 짧아졌지만, 계산 과정을 알아보기에는 매우 불편한 방법으로 코드가 짜여 있습니다. library(magrittr) x %&gt;% log() %&gt;% diff() %&gt;% exp() %&gt;% round(., 2) ## [1] 0.84 2.14 0.10 8.31 1.03 1.68 0.46 1.48 0.31 마지막으로 파이프 오퍼레이터를 사용하는 방법입니다. 코드도 짧으며 계산 과정을 한눈에 파악하기도 좋습니다. 맨 왼쪽에는 원하는 변수를 입력하며, %&gt;% 뒤에는 차례대로 계산하고자 하는 함수를 입력합니다. 변수의 입력값을 ()로 비워둘 경우, 오퍼레이터의 왼쪽에 있는 값이 입력 변수가 됩니다. 반면 round()와 같이 입력값이 두 개 이상 필요하면 마침표(.)가 오퍼레이터의 왼쪽 값으로 입력됩니다. 파이프 오퍼레이터는 크롤링뿐만 아니라 모든 코드에 사용할 수 있습니다. 이를 통해 훨씬 깔끔하면서도 데이터 처리 과정을 직관적으로 이해할 수 있습니다. 0.9 데이터 구조 변형하기 기본적인 R 사용법을 익혔다면 데이터의 모양을 바꾸고 가공하여 내가 원하는 결과물을 출력해야 합니다. 해당 작업은 tidyr 패키지와 dplyr 패키지를 이용해 매우 효율적으로 수행할 수 있으며, dplyr 패키지의 함수 중 일부는 SQL 구문과 매우 유사합니다. 0.9.1 tidyr 패키지를 이용한 데이터 모양 바꾸기 깔끔한 데이터(tidy data)는 다음과 같이 구성되어 있습니다. 각 변수(variable)는 열로 구성됩니다. 각 관측값(observation)은 행으로 구성됩니다. 각 타입의 관측치는 테이블을 구성합니다. 그림 0.24: tidy 데이터 요건 tidyr 패키지에는 이러한 깔끔한 데이터를 만드는데 필요한 여러 함수가 있습니다. 0.9.1.1 pivot_longer(): 세로로 긴 데이터 만들기 먼저 가로로 긴(Wide) 데이터를 세로로 길게 만드는데는 pivot_longer() 함수가 사용됩니다. 이 함수는 여러 열을 key-value 페어로 변형해줍니다. library(tidyr) table4a ## # A tibble: 3 x 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 위 예제에는 세 국가의 1999, 2000년 데이터가 있습니다. 이 중 country를 제외한 연도별 데이터를 세로로 길게 만들도록 하겠습니다. long = table4a %&gt;% pivot_longer(names_to = &#39;years&#39;, values_to = &#39;cases&#39;, -country) print(long) ## # A tibble: 6 x 3 ## country years cases ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 ## 2 Afghanistan 2000 2666 ## 3 Brazil 1999 37737 ## 4 Brazil 2000 80488 ## 5 China 1999 212258 ## 6 China 2000 213766 열 이름에 해당하던 1999, 2000 데이터가 names_to에 입력한 years 열에 입력되었습니다. 또한 각 관측값이 values_to에 입력한 cases 열에 입력되었습니다. country 앞에는 마이너스(-) 기호를 붙여 해당 열은 그대로 유지됩니다. country 1999 2000 Afghanistan 745 2666 Brazil 37737 80488 China 212258 213766 country years cases Afghanistan 1999 745 Afghanistan 2000 2666 Brazil 1999 37737 Brazil 2000 80488 China 1999 212258 China 2000 213766 0.9.1.2 pivot_wider(): 가로로 긴 데이터 만들기 pivot_longer() 함수와 반대로, pivot_wider() 함수를 이용할 경우 세로로 긴 데이터를 가로로 길게 만들 수 있습니다. 위의 데이터에 year 열에 있는 항목들을 열 이름으로, cases 열에 있는 항목들을 가로로 길게 되돌려 보겠습니다. back2wide = long %&gt;% pivot_wider(names_from = &#39;years&#39;, values_from = &#39;cases&#39;) print(back2wide) ## # A tibble: 3 x 3 ## country `1999` `2000` ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 names_from와 values_from에 각각 열이름 및 관측값에 해당하는 값을 입력하면, 원래대로 가로로 긴 테이블 형태가 되었습니다. 0.9.1.3 separate(): 하나의 열을 여러 열로 나누기 table3 ## # A tibble: 6 x 3 ## country year rate ## * &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 rate 열에는 데이터가 ###/#### 형태로 들어가 있습니다. / 기호를 기준으로 앞과 뒤로 각각 나누어보도록 하겠습니다. table3 %&gt;% separate(rate, into = c(&quot;cases&quot;, &quot;population&quot;)) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 separate() 함수를 사용할 경우 rate 열이 “/”를 기준으로 into에 입력한 cases와 population 열로 분리됩니다. table3 %&gt;% separate(rate, into = c(&quot;cases&quot;, &quot;population&quot;), remove = FALSE) ## # A tibble: 6 x 5 ## country year rate cases population ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 745 19987071 ## 2 Afghanistan 2000 2666/20595360 2666 20595360 ## 3 Brazil 1999 37737/172006362 37737 172006362 ## 4 Brazil 2000 80488/174504898 80488 174504898 ## 5 China 1999 212258/1272915272 212258 1272915272 ## 6 China 2000 213766/1280428583 213766 1280428583 remove = FALSE 인자를 추가해주면 원래의 열이 사라지지 않고 유지됩니다. 0.9.1.4 unite(): 여러 열을 하나로 합치기 separate() 함수와는 반대로, unite() 함수를 이용시 여러 열을 하나로 합칠 수 있습니다. table5 ## # A tibble: 6 x 4 ## country century year rate ## * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19 99 745/19987071 ## 2 Afghanistan 20 00 2666/20595360 ## 3 Brazil 19 99 37737/172006362 ## 4 Brazil 20 00 80488/174504898 ## 5 China 19 99 212258/1272915272 ## 6 China 20 00 213766/1280428583 이번에는 century와 year 열을 합친 후 새로운 열을 만들어보도록 하겠습니다. table5 %&gt;% unite(new, century, year, sep = &quot;_&quot;) ## # A tibble: 6 x 3 ## country new rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19_99 745/19987071 ## 2 Afghanistan 20_00 2666/20595360 ## 3 Brazil 19_99 37737/172006362 ## 4 Brazil 20_00 80488/174504898 ## 5 China 19_99 212258/1272915272 ## 6 China 20_00 213766/1280428583 century 열과 year열이 합쳐진 후 new 열에 입력되었으며, sep 인자를 통해 구분자는 \"_\"로 설정하였습니다. 0.9.1.5 tidyr 패키지의 기타 함수 먼저 fill() 함수는 결측치를 채워주는 역할을 합니다. score = tribble( ~ person, ~ Math, ~ Computer, &quot;Henry&quot;, 1, 7, NA, 2, 10, NA, NA, 9, &quot;David&quot;, 1, 4 ) score ## # A tibble: 4 x 3 ## person Math Computer ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Henry 1 7 ## 2 &lt;NA&gt; 2 10 ## 3 &lt;NA&gt; NA 9 ## 4 David 1 4 score의 2번째와 3번째 행에 NA 데이터가 있어 이를 채워줄 필요가 있습니다. score %&gt;% fill(person, Math) ## # A tibble: 4 x 3 ## person Math Computer ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Henry 1 7 ## 2 Henry 2 10 ## 3 Henry 2 9 ## 4 David 1 4 fill() 함수는 결측치가 있을 경우, 각 열의 이전 데이터를 이용해 채워줍니다. 반면에 NA 데이터를 특정 값으로 변경할 수도 있습니다. score %&gt;% replace_na(replace = list(person = &quot;unknown&quot;, Math = 0)) ## # A tibble: 4 x 3 ## person Math Computer ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Henry 1 7 ## 2 unknown 2 10 ## 3 unknown 0 9 ## 4 David 1 4 replace_na() 함수를 이용해 person 열의 NA 데이터를 unknown으로, Math열의 NA 데이터를 0으로 변경하였습니다. 0.9.2 dplyr 패키지를 이용한 데이터 변형하기 데이터를 필터링 하거나, 요약하거나, 정렬하거나, 새로운 변수를 만드는 등 데이터 분석을 위해서는 데이터 변형하고 가공해야 하는 경우가 많습니다. R의 기본 함수도 이러한 기능을 제공하지만, dplyr 패키지를 이용할 경우 훨씬 빠르고 효율적으로 업무를 처리할 수 있습니다. nycflights13 패키지의 flights 데이터셋을 예제로 사용하도록 하겠습니다. library(dplyr) library(nycflights13) flights ## # A tibble: 336,776 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # ... with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 0.9.2.1 select(): 원하는 열 선택하기 select() 함수를 이용해 특정 열만을 선택할 수 있습니다. flights %&gt;% select(year, month, day) %&gt;% head() ## # A tibble: 6 x 3 ## year month day ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 ## 2 2013 1 1 ## 3 2013 1 1 ## 4 2013 1 1 ## 5 2013 1 1 ## 6 2013 1 1 select() 함수 내에 선택하고자 하는 열을 입력하여 year, month, day 열을 선택했습니다. flights %&gt;% select(year:day) %&gt;% head() ## # A tibble: 6 x 3 ## year month day ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 ## 2 2013 1 1 ## 3 2013 1 1 ## 4 2013 1 1 ## 5 2013 1 1 ## 6 2013 1 1 콜론(:)을 이용해 year부터 day 까지의 열을 한번에 선택할 수도 있습니다. flights %&gt;% select(-(year:day)) %&gt;% head() ## # A tibble: 6 x 16 ## dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 517 515 2 830 819 11 UA ## 2 533 529 4 850 830 20 UA ## 3 542 540 2 923 850 33 AA ## 4 544 545 -1 1004 1022 -18 B6 ## 5 554 600 -6 812 837 -25 DL ## 6 554 558 -4 740 728 12 UA ## # ... with 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, ## # dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; 마이너스(-)를 이용할 경우 해당 열을 제외한 모든 열이 선택됩니다. flights %&gt;% select(starts_with(&quot;dep&quot;)) %&gt;% head() ## # A tibble: 6 x 2 ## dep_time dep_delay ## &lt;int&gt; &lt;dbl&gt; ## 1 517 2 ## 2 533 4 ## 3 542 2 ## 4 544 -1 ## 5 554 -6 ## 6 554 -4 select() 함수 내에 starts_with() 함수를 이용할 경우, 해당 문자로 시작하는 열을 모두 선택할 수 있습니다. 이 외에도 ends_with() 함수는 해당 문자로 끝나는 열울, contains() 함수는 해당 문자가 포함되는 열을 선택합니다. 0.9.2.2 rename(): 열이름 바꾸기 flights %&gt;% rename(tail_num = tailnum) %&gt;% select(tail_num) %&gt;% head() ## # A tibble: 6 x 1 ## tail_num ## &lt;chr&gt; ## 1 N14228 ## 2 N24211 ## 3 N619AA ## 4 N804JB ## 5 N668DN ## 6 N39463 rename() 함수를 이용해 tailnum 이던 열 이름을 tail_num 으로 변경하였습니다. 해당 함수는 rename(변경하고자 하는 이름 = 변경전 이름) 형태로 입력해야 합니다. 0.9.2.3 filter(): 필터링 특정 열에 원하는 데이터가 있는 부분만 필터링을 해야하는 경우가 많으며, filter() 함수를 사용해 손쉽게 해결할 수 있습니다. flights %&gt;% filter(month == 3, day == 1) %&gt;% head() ## # A tibble: 6 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 3 1 4 2159 125 318 56 ## 2 2013 3 1 50 2358 52 526 438 ## 3 2013 3 1 117 2245 152 223 2354 ## 4 2013 3 1 454 500 -6 633 648 ## 5 2013 3 1 505 515 -10 746 810 ## 6 2013 3 1 521 530 -9 813 827 ## # ... with 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ## # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, ## # hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; filter() 함수 내에 필터링 하고자 하는 조건, 즉 month가 3이고 day가 1인 조건을 입력하면 해당 조건에 부합하는 행만 선택됩니다. 0.9.2.4 summarize(): 요약값 계산하기 요약 통계값은 summarize() 함수를 통해 쉽게 계산할 수 있습니다. flights %&gt;% summarize(max_dep = max(dep_time, na.rm = TRUE), min_dep = min(dep_time, na.rm = TRUE)) ## # A tibble: 1 x 2 ## max_dep min_dep ## &lt;int&gt; &lt;int&gt; ## 1 2400 1 summarize() 함수를 통해 max_dep에는 dep_time의 최대값을, min_dep에는 dep_time의 최소값을 구해줍니다. na.rm 인자를 TRUE로 설정하여 NA 데이터는 제거해 줍니다. 0.9.2.5 group_by(): 원하는 조건으로 그룹화 각 그룹별 통계량을 계산할 때는 group_by() 함수를 통해 그룹을 묶고, 계산하는 것이 편합니다. by_day = flights %&gt;% group_by(year, month, day) by_day %&gt;% head() ## # A tibble: 6 x 19 ## # Groups: year, month, day [1] ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## # ... with 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ## # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, ## # hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; year, month, day를 기준으로 그룹을 묶었습니다. 아직 계산을 하지 않았으므로 출력되는 데이터프레임 자체는 원래와 동일하며, Groups를 통해 어떠한 조건으로 그룹이 묶여있는지 확인됩니다. by_day %&gt;% summarise(delay = mean(dep_delay, na.rm = TRUE)) %&gt;% head() ## # A tibble: 6 x 4 ## # Groups: year, month [1] ## year month day delay ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 11.5 ## 2 2013 1 2 13.9 ## 3 2013 1 3 11.0 ## 4 2013 1 4 8.95 ## 5 2013 1 5 5.73 ## 6 2013 1 6 7.15 해당 데이터는 그룹별로 묶여 있으므로, summarise() 함수를 적용하면 각 그룹(year, month, day) 별로 dep_delay의 평균을 구합니다. flights %&gt;% group_by(dest) %&gt;% summarize( count = n(), dist = mean(distance, na.rm = TRUE), delay = mean(arr_delay, na.rm = TRUE) ) ## # A tibble: 105 x 4 ## dest count dist delay ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ABQ 254 1826 4.38 ## 2 ACK 265 199 4.85 ## 3 ALB 439 143 14.4 ## 4 ANC 8 3370 -2.5 ## 5 ATL 17215 757. 11.3 ## 6 AUS 2439 1514. 6.02 ## 7 AVL 275 584. 8.00 ## 8 BDL 443 116 7.05 ## 9 BGR 375 378 8.03 ## 10 BHM 297 866. 16.9 ## # ... with 95 more rows 한 번에 여러 통계량을 계산할 수도 있으며, n()은 데이터의 갯수를 의미합니다. 0.9.2.6 arrange(): 데이터 정렬하기 arrange() 함수를 통해 원하는 열을 기준으로 데이터를 순서대로 정렬할 수 있으며, 오름차순을 기본으로 합니다. flights %&gt;% arrange(year, month, day) %&gt;% head() ## # A tibble: 6 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## # ... with 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ## # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, ## # hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; arrange() 함수 내에 입력한 [year -&gt; month -&gt; day] 순으로 오름차순 정렬이 됩니다. flights %&gt;% arrange(desc(dep_delay)) %&gt;% head() ## # A tibble: 6 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 9 641 900 1301 1242 1530 ## 2 2013 6 15 1432 1935 1137 1607 2120 ## 3 2013 1 10 1121 1635 1126 1239 1810 ## 4 2013 9 20 1139 1845 1014 1457 2210 ## 5 2013 7 22 845 1600 1005 1044 1815 ## 6 2013 4 10 1100 1900 960 1342 2211 ## # ... with 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ## # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, ## # hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 정렬하고자 하는 열에 desc() 함수를 추가할 경우, 오름차순이 아닌 내림차순으로 정렬됩니다. 0.9.2.7 *_join(): 데이터 합치기 여러 테이블을 하나로 합치기 위해 *_join() 함수를 이용합니다. 합치는 방법은 그림 0.25과 표 0.4 같이 크게 네가지 종류가 있습니다. 그림 0.25: *_ join() 함수의 종류 표 0.4: join 함수의 종류 함수 내용 inner_join() 교집합 full_join() 합집합 left_join() 좌측 기준 right_join() 우측 기준 다음 두개의 데이터 테이블을 이용하도록 합니다. flights2 = flights %&gt;% select(year:day, hour, tailnum, carrier) flights2 %&gt;% head() ## # A tibble: 6 x 6 ## year month day hour tailnum carrier ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2013 1 1 5 N14228 UA ## 2 2013 1 1 5 N24211 UA ## 3 2013 1 1 5 N619AA AA ## 4 2013 1 1 5 N804JB B6 ## 5 2013 1 1 6 N668DN DL ## 6 2013 1 1 5 N39463 UA airlines %&gt;% head() ## # A tibble: 6 x 2 ## carrier name ## &lt;chr&gt; &lt;chr&gt; ## 1 9E Endeavor Air Inc. ## 2 AA American Airlines Inc. ## 3 AS Alaska Airlines Inc. ## 4 B6 JetBlue Airways ## 5 DL Delta Air Lines Inc. ## 6 EV ExpressJet Airlines Inc. flights2 데이터에는 항공사 명의 약자인 carrier가 있으며, airlines 데이터는 해당 약자의 풀 네임이 적혀있습니다. left_join() 함수를 이용해 왼쪽 데이터프레임을 기준으로 데이터를 합치도록 하며, 두 데이터 모두 carrier 열이 있으므로 이를 기준으로 데이터가 합치도록 하겠습니다. flights2 %&gt;% left_join(airlines, by = &quot;carrier&quot;) %&gt;% head() ## # A tibble: 6 x 7 ## year month day hour tailnum carrier name ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2013 1 1 5 N14228 UA United Air Lines Inc. ## 2 2013 1 1 5 N24211 UA United Air Lines Inc. ## 3 2013 1 1 5 N619AA AA American Airlines Inc. ## 4 2013 1 1 5 N804JB B6 JetBlue Airways ## 5 2013 1 1 6 N668DN DL Delta Air Lines Inc. ## 6 2013 1 1 5 N39463 UA United Air Lines Inc. flights2에서 모든 데이터를 가져오며, airlines의 name 열이 기존 테이블에 추가됩니다. join 구문에 대한 더욱 상세한 예제 및 애니메이션은 다음 주소를 참조하시기 바랍니다. https://github.com/gadenbuie/tidyexplain 0.9.2.8 mutate(): 새로운 열 생성하기 mutate() 함수를 사용해 기존 열끼리 계산을 하여 새로운 열을 생성할 수 있습니다. flights_sml = flights %&gt;% select( year:day, ends_with(&quot;delay&quot;), distance, air_time ) flights_sml %&gt;% mutate( gain = dep_delay - arr_delay, speed = distance / air_time * 60 ) %&gt;% head() ## # A tibble: 6 x 9 ## year month day dep_delay arr_delay distance air_time gain speed ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 2 11 1400 227 -9 370. ## 2 2013 1 1 4 20 1416 227 -16 374. ## 3 2013 1 1 2 33 1089 160 -31 408. ## 4 2013 1 1 -1 -18 1576 183 17 517. ## 5 2013 1 1 -6 -25 762 116 19 394. ## 6 2013 1 1 -4 12 719 150 -16 288. 먼저 flights에서 일부 열을 선택하여 flights_sml에 저장합니다.그 후, mutate() 함수를 이용해 새로운 열을 만들어 줍니다. gain 열에는 dep_delay와 arr_delay의 차이가, speed 열에는 distance와 air_time 비에 60을 곱한 값이 새롭게 생성됩니다. flights_sml %&gt;% mutate( across(c(&#39;dep_delay&#39;, &#39;arr_delay&#39;), ~ .x * 60) ) %&gt;% head() ## # A tibble: 6 x 7 ## year month day dep_delay arr_delay distance air_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 120 660 1400 227 ## 2 2013 1 1 240 1200 1416 227 ## 3 2013 1 1 120 1980 1089 160 ## 4 2013 1 1 -60 -1080 1576 183 ## 5 2013 1 1 -360 -1500 762 116 ## 6 2013 1 1 -240 720 719 150 동일한 함수를 한번에 여러행에 적용해야 할 때는 mutate() 함수 내에 across() 함수를 입력합니다. 위 예제에서는 dep_delay과 arr_delay열의 데이터에 60을 곱해주었습니다. across() 함수의 자세한 사용법은 다소 생소하고 어려울 수 있으므로 아래 페이지의 내용을 따라가며 익히시는게 좋습니다. https://dplyr.tidyverse.org/reference/across.html "],["퀀트-투자의-심장-데이터와-프로그래밍.html", "Chapter 1 퀀트 투자의 심장: 데이터와 프로그래밍 1.1 데이터 구하기 1.2 퀀트 투자와 프로그래밍 1.3 R 프로그램 1.4 퀀트 투자에 유용한 R 패키지", " Chapter 1 퀀트 투자의 심장: 데이터와 프로그래밍 몇 년 전까지만 하더라도 퀀트 투자는 일반 투자자들에게 매우 낯선 영역이었지만, 최근에는 각종 커뮤니티와 매체를 통해 많은 사람들에게 익숙한 단어가 되었습니다. 퀀트 투자에서 ‘퀀트’란 모형을 기반으로 금융상품의 가격을 산정하거나, 이를 바탕으로 투자를 하는 사람을 말합니다. 퀀트(Quant)라는 단어가 ’계량적’을 의미하는 퀀티터티브(Quantitative)의 앞 글자를 따왔음을 생각하면 쉽게 이해가 될 것입니다. 일반적으로 투자자들이 산업과 기업을 분석해 가치를 매기는 정성적인 투자법과는 달리, 퀀트 투자는 수학과 통계를 기반으로 전략을 만들고 이를 바탕으로 투자하는 정량적인 투자법을 의미합니다. 이처럼 데이터를 수집·가공한 후 이를 바탕으로 모델을 만들고 실행하는 단계는 데이터 과학의 업무 흐름도와 매우 유사합니다. 해들리 위컴 (Hadley Wickham)(Grolemund and Wickham 2018)에 따르면 데이터 과학의 업무 과정은 그림 1.1과 같습니다. 그림 1.1: 데이터 과학 업무 과정 데이터 과학자들은 프로그래밍을 통해 데이터를 불러온 후 이를 정리하고, 원하는 결과를 찾기 위해 데이터를 변형하거나 시각화하고 모델링합니다. 이러한 결과를 바탕으로 타인과 소통하는 일련의 과정을 거칩니다. 퀀트 투자의 단계 역시 이와 매우 유사합니다. 투자에 필요한 주가, 재무제표 등의 데이터를 수집해 정리한 후 필요한 지표를 얻기 위해 가공합니다. 그 후 각종 모형을 이용해 투자 종목을 선택하거나 백테스트를 수행하며, 이를 바탕으로 실제로 투자하고 성과를 평가합니다. 따라서 퀀트 투자는 데이터 과학이 금융에 응용된 사례라고도 볼수 있으며, 퀀트 투자의 중심에는 데이터와 프로그래밍이 있습니다. 이 책에서도 데이터 과학의 업무 단계와 동일하게 데이터 불러오기, 데이터별로 정리하고 가공하기, 시각화를 통해 데이터의 특징 파악하기, 퀀트 모델을 이용해 종목 선택하기, 백테스트를 실시한 후 성과 및 위험 평가하기에 대해 알아보겠습니다. 이에 앞서 이 CHAPTER에서는 퀀트 투자의 심장이라고 할 수 있는 데이터를 어떻게 얻을 수 있는지, 왜 프로그래밍을 해야 하는지, 그중에서도 R이 무엇인지에 대해 간략히 살펴보겠습니다. 1.1 데이터 구하기 퀀트 투자에 필요한 데이터는 여러 데이터 제공업체의 서비스를 이용해서 매우 쉽게 구할 수 있습니다. 해외 데이터 수집에는 블룸버그 혹은 Factset, 국내 데이터 수집에는 DataGuide가 흔히 사용됩니다. 물론 비용을 더 지불한다면 단순 데이터 수집뿐만 아니라 즉석에서 백테스트 및 성과 평가까지 가능합니다. Factset에서 판매하는 Alpha Testing 혹은 S&amp;P Global에서 판매하는 ClariFI(그림 1.2)를 사용한다면, 전 세계 주식을 대상으로 원하는 전략의 백테스트 결과를 마우스 몇 번 클릭해서 얻을 수 있습니다. 그림 1.2: ClariFI®의 백테스트 기능 데이터 제공업체를 이용하는 방법의 최대 단점은 바로 비용입니다. 블룸버그 단말기는 1년 사용료가 대리 한 명의 연봉과 비슷해, 흔히 ’블대리’라고 부르기도 합니다. 국내 데이터 업체의 사용료는 이보다 저렴하기는 하지만, 역시 1년 사용료가 수백만 원 정도로, 일반 개인 투자자가 감당하기에는 부담이 됩니다. 해외데이터는 Quandl1이나 tiingo2등의 업체가 제공하는 서비스를 이용하면 상대적으로 저렴한 가격에 데이터를 구할 수 있습니다. 물론 대형 데이터 제공업체에 비해 데이터의 종류가 적고 기간은 짧은 편이지만, 대부분의 일반 투자자가 사용하기에는 충분한 데이터를 얻을 수 있습니다. tiingo에서는 전 세계 64,386개 주식의 30년 이상 가격 정보, 21,352개 주식의 12년 이상 재무정보를 월 $10에 받을 수 있으며, 한정된 종목과 용량에 대해서는 무료로 데이터를 받을 수도 있습니다. 더군다나 API를 통해 프로그램 내에서 직접 데이터를 받을 수 있어 편리합니다. 그러나 아쉽게도 이러한 데이터에서 한국 시장의 정보는 소외되어 있습니다. 따라서 돈을 들이지 않고 국내 데이터를 얻기 위해서는 직접 발품을 파는 수밖에 없습니다.야후 파이낸스3 혹은 국내 금융 웹사이트에서 제공하는 정보를 크롤링해 데이터를 수집할 수 있습니다. 그림 1.3: NAVER 금융 제공 재무정보 이러한 정보를 잘만 활용한다면 장기간의 주가 및 재무정보를 무료로 수집할 수 있습니다. 물론 데이터 제공업체가 제공하는 깔끔한 형태의 데이터가 아니므로 클렌징 작업이 필요하고 상장폐지된 기업의 데이터를 구하기 힘들다는 단점이 있습니다. 그러나 비용이 들지 않는 데다 현재 시점에서 투자 종목을 선택할 때는 상장폐지된 기업의 정보가 필요하지 않는다는 점을 고려하면 이는 큰 문제가 되지 않습니다. 1.2 퀀트 투자와 프로그래밍 우리가 구한 데이터는 연구나 투자에 바로 사용할 수 있는 형태로 주어지는 경우가 거의 없습니다. 따라서 데이터를 목적에 맞게 처리하는 과정을 거쳐야 하며, 이를 흔히 데이터 클렌징 작업이라고 합니다. 또한 정제된 데이터를 활용한 투자 전략의 백테스트나 종목 선정을 위해서 프로그래밍은 필수입니다. 물론 모든 퀀트 투자에서 프로그래밍이 필수인 것은 아닙니다. 엑셀을 이용해도 간단한 형태의 백테스트 및 종목 선정은 얼마든지 가능합니다. 그러나 응용성 및 효율성의 측면에서 엑셀은 매우 비효율적입니다. 데이터를 수집하고 클렌징 작업을 할 때 대상이 몇 종목 되지 않는다면 엑셀을 이용해도 충분히 가능합니다. 그러나 종목 수가 수천 종목을 넘어간다면 데이터를 손으로 일일이 처리하기가 사실상 불가능에 가깝습니다. 이러한 단순 반복 작업은 프로그래밍을 이용한다면 훨씬 효율적으로 수행할 수 있습니다. 백테스트에서도 프로그래밍이 훨씬 효율적입니다. 과거 12개월 누적수익률이 높은 종목에 투자하는 모멘텀 전략의 백테스트를 한다고 가정합시다. 처음에는 엑셀로 백테스트를 하는 것이 편하다고 생각할 수 있습니다. 그러나 만일 12개월이 아닌 6개월 누적 수익률로 백테스트를 하고자 한다면 어떨까요? 엑셀에서 다시 6개월 누적수익률을 구하기 위해 명령어를 바꾸고 드래그하는 작업을 반복해야 할 것입니다. 그러나 프로그래밍을 이용한다면 n = 12였던 부분을 n = 6으로 변경한 후 단지 클릭 한 번만으로 새로운 백테스트가 완료됩니다. 전체 데이터가 100MB 정도라고 가정할 때, 투자 전략이 계속해서 늘어날 경우는 어떨까요? 엑셀에서 A라는 전략을 백테스트하기 위해서는 해당 데이터로 작업한 후 저장할 것입니다. 그 후 B라는 전략을 새롭게 백테스트하려면 해당 데이터를 새로운 엑셀 파일에 복사해 작업한 후 다시 저장해야 합니다. 결과적으로 10개의 전략만 백테스트 하더라도 100MB짜리 엑셀 파일이 10개, 즉 1GB 정도의 엑셀 파일이 쌓이게 됩니다. 만일 데이터가 바뀔 경우 다시 10개 엑셀 시트의 데이터를 일일이 바꿔야 하는 귀찮음도 감수해야 합니다. 물론 하나의 엑셀 파일 내에서 모든 전략을 수행할 수도 있지만, 이러한 경우 속도가 상당히 저하되는 문제가 있습니다. 프로그래밍을 이용한다면 어떨까요? 백테스트를 수행하는 프로그래밍 스크립트는 불과 몇 KB에 불과하므로, 10개의 전략에 대한 스크립트 파일을 합해도 1MB가 되지 않습니다. 데이터가 바뀌더라도 원본 데이터 파일 하나만 수정해주면 됩니다. 물론 대부분의 사람들에게 프로그래밍은 낯선 도구입니다. 그러나 퀀트 투자에 필요한 프로그래밍은 매우 한정적이고 몇 가지 기능을 반복적으로 쓰기 때문에 몇 개의 단어와 구문만 익숙해지면 사용하는 데 큰 어려움이 없습니다. 또한 전문 개발자들의 프로그래밍에 비하면 상당히 쉬운 수준이므로, 비교적 빠른 시간 내에 원하는 전략을 테스트하고 수행하는 정도의 능력을 갖출 수도 있습니다. 1.3 R 프로그램 인간이 사용하는 언어의 종류가 다양하듯이, 프로그래밍 언어의 종류 역시 다양합니다. 대략 700여 개 이상의 프로그래밍 언어 중4 대중적으로 사용하는 언어는 그리 많지 않으므로, 대중성과 효율성을 위해 사용량이 많은 언어를 이용하는 것이 좋습니다. 그림 1.5는 프로그래밍 언어의 사용 순위5입니다. 이 중 R과 Python은 매우 대중적인 언어입니다. 해당 언어가 많이 사용되는 가장 큰 이유는 무료인 데다 일반인들이 사용하기에도 매우 편한 형태로 구성되어 있기 때문입니다. 그림 1.4: 2017년 기준 프로그래밍 언어 사용 통계 순위 이러한 프로그래밍 언어 중 이 책에서는 R을 이용합니다. R의 장점은 무료라는 점 이외에도 타 언어와 비교할 수 없이 다양한 패키지가 있다는 점입니다. R은 두터운 사용자층을 기반으로 두고 있어 상상할 수 없을 정도로 패키지가 많으며, 특히 통계나 계량분석과 관련된 패키지는 독보적이라고 할 수 있습니다. 그림 1.5: CRAN 등록 패키지 수 1.4 퀀트 투자에 유용한 R 패키지 R에는 여러 연구자와 실무자의 헌신적인 노력 덕분에 금융 연구와 퀀트 투자를 위한 다양한 패키지가 만들어져 있으며, 누구나 무료로 이용할 수 있습니다. 이 책에서 사용되는 패키지 중 중요한 것은 다음과 같습니다. 각 패키지에 대한 자세한 설명은 구글에서 패키지명을 검색한 후 PDF 파일을 통해 확인할 수 있습니다. quantmod: 이름에서 알 수 있듯이 퀀트 투자에 매우 유용한 패키지입니다. API를 이용해 데이터를 다운로드하는 getSymbols() 함수는 대단히 많이 사용됩니다. 이 외에도 볼린저밴드, 이동평균선, 상대강도지수(RSI) 등 여러 기술적 지표를 주가 차트에 나타낼 수도 있습니다. PerformanceAnalytics: 포트폴리오의 성과와 위험을 측정하는 데 매우 유용한 패키지입니다. Return.portfolio() 함수는 포트폴리오 백테스트에 필수적인 함수입니다. xts: 기본적으로 금융 데이터는 시계열 형태이며, xts 패키지는 여러 데이터를 시계열 형태(eXtensible TimeSeries)로 변형해줍니다. 일별 수익률을 월별 수익률 혹은 연도별 수익률로 변환하는 apply.monthly()와 apply.yearly() 함수, 데이터들의 특정 시점을 찾아주는 endpoints() 함수 역시 백테스트에 필수적으로 사용되는 함수입니다. 이 패키지는 PerformanceAnalytics 패키지 설치 시 자동으로 설치됩니다. zoo: zoo 패키지 역시 시계열 데이터를 다루는 데 유용한 함수가 있습니다. rollapply() 함수는 apply() 함수를 전체 데이터가 아닌 롤링 윈도우 기법으로 활용할 수 있게 해주며, NA 데이터를 채워주는 na.locf() 함수는 시계열 데이터의 결측치를 보정할 때 매우 유용합니다. httr &amp; rvest: 데이터를 웹에서 수집하기 위해서는 크롤링이 필수이며, httr과 rvest는 크롤링에 사용되는 패키지입니다. httr은 http의 표준 요청을 수행하는 패키지로서 단순히 데이터를 받는 GET() 함수와 사용자가 필요한 값을 선택해 요청하는 POST() 함수가 대표적으로 사용됩니다. rvest는 HTML 문서의 데이터를 가져오는 패키지이며, 웹페이지에서 데이터를 크롤링한 후 원하는 데이터만 뽑는데 필요한 여러 함수가 포함되어 있습니다. dplyr: 데이터 처리에 특화되어 R을 이용한 데이터 과학 분야에서 많이 사용되는 패키지입니다. C++로 작성되어 매우 빠른 처리 속도를 보이며, API나 크롤링을 통해 수집한 데이터들을 정리할 때도 매우 유용합니다. ggplot2: 데이터를 시각화할 때 가장 많이 사용되는 패키지입니다. 물론 R에서 기본적으로 내장된 plot() 함수를 이용해도 시각화가 가능하지만, 해당 패키지를 이용하면 훨씬 다양하고 깔끔하게 데이터를 그림으로 표현할 수 있습니다. 이 외에도 이 책에서는 다양한 패키지를 사용했으며, 아래의 코드를 실행하면 설치되지 않은 패키지를 설치할 수 있습니다. pkg = c(&#39;magrittr&#39;, &#39;quantmod&#39;, &#39;rvest&#39;, &#39;httr&#39;, &#39;jsonlite&#39;, &#39;readr&#39;, &#39;readxl&#39;, &#39;stringr&#39;, &#39;lubridate&#39;, &#39;dplyr&#39;, &#39;tidyr&#39;, &#39;ggplot2&#39;, &#39;corrplot&#39;, &#39;dygraphs&#39;, &#39;highcharter&#39;, &#39;plotly&#39;, &#39;PerformanceAnalytics&#39;, &#39;nloptr&#39;, &#39;quadprog&#39;, &#39;RiskPortfolios&#39;, &#39;cccp&#39;, &#39;timetk&#39;, &#39;broom&#39;, &#39;stargazer&#39;, &#39;timeSeries&#39;) new.pkg = pkg[!(pkg %in% installed.packages()[, &quot;Package&quot;])] if (length(new.pkg)) { install.packages(new.pkg, dependencies = TRUE)} References "],["크롤링을-위한-기본-지식.html", "Chapter 2 크롤링을 위한 기본 지식 2.1 인코딩의 이해와 R에서 UTF-8 설정하기 2.2 웹의 동작 방식 2.3 HTML과 CSS 2.4 파이프 오퍼레이터(%&gt;%) 2.5 오류에 대한 예외처리", " Chapter 2 크롤링을 위한 기본 지식 프로그래밍에 익숙한 분들도 크롤링은 생소한 경우가 많습니다. 기본적인 프로그래밍에 관한 책과 강의가 굉장히 많지만 크롤링을 다루는 자료는 접하기 힘들기 때문입니다. 크롤링은 기계적인 단계가 많기 때문에 조금만 연습해도 활용할 수 있는 기술입니다. 그러나 복잡한 웹페이지나 데이터 내용을 수집하려면 인코딩, 통신 구조에 대한 지식이 필요할 때가 있습니다. 이 CHAPTER에서는 크롤링을 하기 위해 사전에 알고 있으면 도움이 되는 인코딩, 웹의 동작 방식, HTML과 CSS에 대해 알아보겠습니다. 그리고 실제 크롤링 시 유용한 파이프 오퍼레이터와 오류에 대한 예외처리도 알아보겠습니다. 2.1 인코딩의 이해와 R에서 UTF-8 설정하기 2.1.1 인간과 컴퓨터 간 번역의 시작, ASCII R에서 스크립트를 한글로 작성해 저장한 후 이를 다시 불러올 때, 혹은 한글로 된 데이터를 크롤링하면 오류가 뜨거나 읽을 수 없는 문자로 나타나는 경우가 종종 있습니다. 이는 한글 인코딩 때문에 발생하는 문제이며, 이러한 현상을 흔히 ‘인코딩이 깨졌다’라고 표현합니다. 인코딩이란 사람이 사용하는 언어를 컴퓨터가 사용하는 0과 1로 변환하는 과정을 말하며, 이와 반대의 과정을 디코딩이라고 합니다. 이렇듯 사람과 컴퓨터 간의 언어를 번역하기 위해 최초로 사용된 방식이 아스키(ASCII: American Standard Code for Information Interchange)입니다. 0부터 127까지 총 128개 바이트에 알파벳과 숫자, 자주 사용되는 특수문자 값을 부여하고, 문자가 입력되면 이에 대응되는 바이트가 저장됩니다. 그러나 아스키의 ‘American’이라는 이름에서 알 수 있듯이 이는 영어의 알파벳이 아닌 다른 문자를 표현하는 데 한계가 있으며, 이를 보완하기 위한 여러 방법이 나오게 되었습니다. 그림 2.1: 아스키 코드 표 2.1.2 한글 인코딩 방식의 종류 인코딩에 대한 전문적인 내용은 이 책의 범위를 넘어가며, 크롤링을 위해서는 한글을 인코딩하는 데 쓰이는 EUC-KR과 CP949, UTF-8 정도만 이해해도 충분합니다. 만일 ‘알’이라는 단어를 인코딩한다면 어떤 방법이 있을까요? 먼저 ‘알’이라는 문자 자체에 해당하는 코드를 부여해 나타내는 방법이 있습니다. 아니면 이를 구성하는 모음과 자음을 나누어 ㅇ, ㅏ, ㄹ 각각에 해당하는 코드를 부여하고 이를 조합할 수도 있습니다. 전자와 같이 완성된 문자 자체로 나타내는 방법을 완성형, 후자와 같이 각 자모로 나타내는 방법을 조합형이라고 합니다. 한글 인코딩 중 완성형으로 가장 대표적인 방법은 EUC-KR입니다. EUC-KR은 현대 한글에서 많이 쓰이는 문자 2,350개에 번호를 붙인 방법입니다. 그러나 2,350개 문자로 모든 한글 자모의 조합을 표현하기 부족해, 이를 보완하고자 마이크로소프트가 도입한 방법이 CP949입니다. CP949는 11,720개 한글 문자에 번호를 붙인 방법으로 기존 EUC-KR보다 나타낼 수 있는 한글의 개수가 훨씬 많아졌습니다. 윈도우의 경우 기본 인코딩이 CP949로 되어 있습니다. 조합형의 대표적 방법인 UTF-8은 모음과 자음 각각에 코드를 부여한 후 조합해 한글을 나타냅니다. 조합형은 한글뿐만 아니라 다양한 언어에 적용할 수 있다는 장점이 있어 전 세계 웹페이지의 대부분이 UTF-8로 만들어지고 있습니다. 그림 2.2: 웹페이지에서 사용되는 인코딩 비율 2.1.3 R에서 UTF-8 설정하기 윈도우에서는 기본 인코딩이 CP949로 이루어져 있으며, 일부 국내 웹사이트는 EUC-KR로 인코딩이 된 경우도 있습니다. 반면 R의 여러 함수는 인코딩이 UTF-8로 이루어져 있어, 인코딩 방식의 차이로 인해 스크립트 작성 및 크롤링 과정에서 오류가 발생하는 경우가 종종 있습니다. 만일 CP949 인코딩을 그대로 사용하면 미리 저장되었던 한글 스크립트가 깨져 나오는 일이 발생할 수 있습니다. 이를 방지하기 위해 그림 2.3과 같이 기본 인코딩을 UTF-8로 변경해주는 것이 좋습니다. R Studio의 [Tools → Global Options] 메뉴에서 [Code → Saving] 항목 중 [Default text encodings] 항목을 통해 기본 인코딩을 UTF-8로 변경합니다. 그림 2.3: 인코딩 변경 해당 방법으로도 해결되지 않는다면 그림 2.4와 같이 [File → Reopen with Encoding] 메뉴에서 [UTF-8] 항목을 선택하고 [Set as default encoding for source files] 항목을 선택한 후 [OK]를 클릭합니다. UTF-8로 인코딩이 설정된 후 파일을 다시 엽니다. 그림 2.4: 인코딩 변경 후 재시작 2.2 웹의 동작 방식 크롤링은 웹사이트의 정보를 수집하는 과정입니다. 따라서 웹이 어떻게 동작하는지 이해할 필요가 있습니다. 그림 2.5: 웹 환경 구조 먼저 클라이언트란 여러분의 데스크톱이나 휴대폰과 같은 장치와 크롬이나 파이어폭스와 같은 소프트웨어를 의미합니다. 서버는 웹사이트와 앱을 저장하는 컴퓨터를 의미합니다. 클라이언트가 특정 정보를 요구하는 과정을 ‘요청’이라고 하며, 서버가 해당 정보를 제공하는 과정을 ‘응답’이라고 합니다. 그러나 클라이언트와 서버가 연결되어 있지 않다면 둘 사이에 정보를 주고받을 수 없으며, 이를 연결하는 공간이 바로 인터넷입니다. 또한 건물에도 고유의 주소가 있는 것처럼, 각 서버에도 고유의 주소가 있는데 이것이 인터넷 주소 혹은 URL입니다. 여러분이 네이버에서 경제 기사를 클릭하는 경우를 생각해봅시다. 클라이언트는 사용자인 여러분이고, 서버는 네이버이며, URL은 www.naver.com이 됩니다. 경제 기사를 클릭하는 과정이 요청이며, 클릭 후 해당 페이지를 보여주는 과정이 응답입니다. 2.2.1 HTTP 클라이언트가 각기 다른 방법으로 데이터를 요청한다면, 서버는 해당 요청을 알아듣지 못할 것입니다. 이를 방지하기 위해 규정된 약속이나 표준에 맞추어 데이터를 요청해야 합니다. 이러한 약속을 HTTP(HyperText Transfer Protocol)라고 합니다. 클라이언트가 서버에게 요청의 목적이나 종류를 알리는 방법을 HTTP 요청 방식(HTTP Request Method)이라고 합니다. HTTP 요청 방식은 크게 표 2.1와 같이 GET, POST, PUT, DELETE라는 네 가지로 나눌 수 있지만 크롤링에는 GET과 POST 방식이 대부분 사용되므로 이 두 가지만 알아도 충분합니다. GET 방식과 POST 방식의 차이 및 크롤링 방법은 CHAPTER 4에서 자세하게 다루겠습니다. 표 2.1: HTTP 요청 방식과 설명 요청방식 주소 GET 특정 정보 조회 POST 새로운 정보 등록 PUT 기존 특정 정보 갱신 DELETE 기존 특정 정보 삭제 인터넷을 사용하다 보면 한 번쯤 ‘이 페이지를 볼 수 있는 권한이 없음(HTTP 오류 403 - 사용할 수 없음)’ 혹은 ‘페이지를 찾을 수 없음(HTTP 오류 404 - 파일을 찾을 수 없음)’이라는 오류를 본 적이 있을 겁니다. 여기서 403과 404라는 숫자는 클라이언트의 요청에 대한 서버의 응답 상태를 나타내는 HTTP 상태 코드입니다. HTTP 상태 코드는 100번대부터 500번대까지 있으며, 성공적으로 응답을 받을 시 200번 코드를 받게 됩니다. 각 코드에 대한 내용은 HTTP 상태 코드를 검색하면 확인할 수 있으며, 크롤링 과정에서 오류가 발생할 시 해당 코드를 통해 어떤 부분에서 오류가 발생했는지 확인이 가능합니다. 표 2.2: HTTP 상태 코드 그룹 별 내용 코드 주소 내용 1xx Informational (조건부 응답) 리퀘스트를 받고, 처리 중에 있음 2xx Success (성공) 리퀘스트를 정상적으로 처리함 3xx Redirection (리디렉션) 리퀘스트 완료를 위해 추가 동작이 필요함 4xx Client Error (클라이언트 오류) 클라이언트 요청을 처리할 수 없어 오류 발생 5xx Server Error (서버 오류) 서버에서 처리를 하지 못하여 오류 발생 2.3 HTML과 CSS 클라이언트와 서버가 데이터를 주고받을 때는 디자인이라는 개념이 필요하지 않습니다. 그러나 응답받은 정보를 사람이 확인하려면 보기 편한 방식으로 바꾸어줄 필요가 있는데 웹페이지가 그러한 역할을 합니다. 웹페이지의 제목, 단락, 목록 등 레이아웃을 잡아주는 데 쓰이는 대표적인 마크업 언어가 HTML(HyperText Markup Language)입니다. HTML을 통해 잡혀진 뼈대에 글자의 색상이나 폰트, 배경색, 배치 등 화면을 꾸며주는 역할을 하는 것이 CSS(Cascading Style Sheets)입니다. 우리의 목적은 웹페이지를 만드는 것이 아니므로 HTML과 CSS에 대해 자세히 알 필요는 없습니다. 그러나 크롤링하고자 하는 데이터가 웹페이지의 어떤 태그 내에 위치하고 있는지, 어떻게 크롤링하면 될지 파악하기 위해서는 HTML과 CSS에 대한 기본적인 지식은 알아야 합니다. 메모장에서 HTML 코드를 입력한 후 ‘파일명.html’로 저장하면 해당 코드가 웹페이지에서 어떻게 나타나는지 확인할 수 있습니다. 2.3.1 HTML 기본 구조 HTML은 크게 메타 데이터를 나타내는 head와 본문을 나타내는 body로 나누어집니다. head에서 title은 웹페이지에서 나타나는 제목을 나타내며 body 내에는 본문에 들어갈 각종 내용들이 포함되어 있습니다. &lt;html&gt; &lt;head&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt; This is page heading &lt;/h2&gt; &lt;p&gt; THis is first paragraph text &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 그림 2.6: HTML 기본 구조 2.3.2 태그와 속성 HTML 코드는 태그와 속성, 내용으로 이루어져 있습니다. 크롤링한 데이터에서 특정 태그의 데이터만을 찾는 방법, 특정 속성의 데이터만을 찾는 방법, 뽑은 자료에서 내용만을 찾는 방법 등 내용을 찾는 방법이 모두 다르기 때문에 태그와 속성에 대해 좀 더 자세히 살펴보겠습니다. 그림 2.7: HTML 구성 요소 분석 꺾쇠(&lt;&gt;)로 감싸져 있는 부분을 태그라고 하며, 여는 태그 &lt;&gt;가 있으면 반드시 이를 닫는 태그인 &lt;/&gt;가 쌍으로 있어야 합니다. 속성은 해당 태그에 대한 추가적인 정보를 제공해주는 것으로, 뒤에 속성값이 따라와야 합니다. 내용은 우리가 눈으로 보는 텍스트 부분을 의미합니다. 앞의 HTML 코드는 문단을 나타내는 &lt;p&gt;, 정렬을 나타내는 align 속성과 center를 통해 가운데 정렬을 지정하며, 내용에는 ‘퀀트 투자 Cookbook’을 나타내고, &lt;/p&gt; 태그를 통해 태그를 마쳤습니다. 2.3.3 h 태그와 p 태그 h 태그는 폰트의 크기를 나타내는 태그이며, p 태그는 문단을 나타내는 태그입니다. 이를 사용한 간단한 예제는 다음과 같습니다. h 태그의 숫자가 작을수록 텍스트 크기는 커지는 것이 확인되며, 숫자는 1에서 6까지 지원됩니다. p 태그를 사용하면 각각의 문단이 만들어지는 것이 확인됩니다. &lt;html&gt; &lt;body&gt; &lt;h1&gt;Page heading: size 1&lt;/h1&gt; &lt;h2&gt;Page heading: size 2&lt;/h2&gt; &lt;h3&gt;Page heading: size 3&lt;/h3&gt; &lt;p&gt;Quant Cookbook&lt;/p&gt; &lt;p&gt;By Henry&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 그림 2.8: h 태그와 p 태그 예제 2.3.4 리스트를 나타내는 ul 태그와 ol 태그 ul과 ol 태그는 리스트(글머리 기호)를 만들 때 사용됩니다. ul은 순서가 없는 리스트(unordered list), ol은 순서가 있는 리스트(ordered list)를 만듭니다. &lt;html&gt; &lt;body&gt; &lt;h2&gt; Unordered List&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;Price&lt;/li&gt; &lt;li&gt;Financial Statement&lt;/li&gt; &lt;li&gt;Sentiment&lt;/li&gt; &lt;/ul&gt; &lt;h2&gt; Ordered List&lt;/h2&gt; &lt;ol&gt; &lt;li&gt;Import&lt;/li&gt; &lt;li&gt;Tidy&lt;/li&gt; &lt;li&gt;Understand&lt;/li&gt; &lt;li&gt;Communicate&lt;/li&gt; &lt;/ol&gt; &lt;/body&gt; &lt;/html&gt; 그림 2.9: 리스트 관련 태그 예제 ul 태그로 감싼 부분은 글머리 기호가 순서가 없는 •으로 표현되며, ol 태그로 감싼 부분은 숫자가 순서대로 표현됩니다. 각각의 리스트는 li를 통해 생성됩니다. 2.3.5 table 태그 table 태그는 표를 만드는 태그입니다. &lt;html&gt; &lt;body&gt; &lt;h2&gt;Major Stock Indices and US ETF&lt;/h2&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;Country&lt;/th&gt; &lt;th&gt;Index&lt;/th&gt; &lt;th&gt;ETF&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;US&lt;/td&gt; &lt;td&gt;S&amp;P 500&lt;/td&gt; &lt;td&gt;IVV&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Europe&lt;/td&gt; &lt;td&gt;Euro Stoxx 50&lt;/td&gt; &lt;td&gt;IEV&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Japan&lt;/td&gt; &lt;td&gt;Nikkei 225&lt;/td&gt; &lt;td&gt;EWJ&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Korea&lt;/td&gt; &lt;td&gt;KOSPI 200&lt;/td&gt; &lt;td&gt;EWY&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 그림 2.10: table 태그 예제 table 태그 내의 tr 태그는 각 행을 의미합니다. 각 셀의 구분은 th 혹은 td 태그를 통해 구분할 수 있습니다. th 태그는 진하게 표현되므로 주로 테이블의 제목에 사용되고, td 태그는 테이블의 내용에 사용됩니다. 2.3.6 a 태그와 img 태그 및 속성 a 태그와 img 태그는 다른 태그와는 다르게, 혼자 쓰이기보다는 속성과 결합해 사용됩니다. a 태그는 href 속성과 결합해 다른 페이지의 링크를 걸 수 있습니다. img 태그는 src 속성과 결합해 이미지를 불러옵니다. &lt;html&gt; &lt;body&gt; &lt;h2&gt;a tag &amp; href attribute&lt;/h2&gt; &lt;p&gt;HTML links are defined with the a tag. The link address is specified in the href attribute:&lt;/p&gt; &lt;a href=&quot;https://henryquant.blogspot.com/&quot;&gt;Henry&#39;s Quantopia&lt;/a&gt; &lt;h2&gt;img tag &amp; src attribute&lt;/h2&gt; &lt;p&gt;HTML images are defined with the img tag, and the filename of the image source is specified in the src attribute:&lt;/p&gt; &lt;img src=&quot;https://cran.r-project.org/Rlogo.svg&quot;, width=&quot;180&quot;,height=&quot;140&quot;&gt; &lt;/body&gt; &lt;/html&gt; 그림 2.11: a 태그와 src 태그 예제 a 태그 뒤 href 속성의 속성값으로 연결하려는 웹페이지 주소를 입력한 후 내용을 입력하면, 내용 텍스트에 웹페이지의 링크가 추가됩니다. img 태그 뒤 src 속성의 속성값에는 불러오려는 이미지 주소를 입력하며, width 속성과 height 속성을 통해 이미지의 가로세로 길이를 조절할 수도 있습니다. 페이지 내에서 링크된 주소를 모두 찾거나, 모든 이미지를 저장하려고 할 때 속성값을 찾으면 손쉽게 원하는 작업을 할 수 있습니다. 2.3.7 div 태그 div 태그는 화면의 전체적인 틀(레이아웃)을 만들 때 주로 사용하는 태그입니다. 단독으로도 사용될 수 있으며, 꾸밈을 담당하는 style 속성과 결합되어 사용되기도 합니다. &lt;html&gt; &lt;body&gt; &lt;div style=&quot;background-color:black;color:white&quot;&gt; &lt;h5&gt;First Div&lt;/h5&gt; &lt;p&gt;Black backgrond, White Color&lt;/p&gt; &lt;/div&gt; &lt;div style=&quot;background-color:yellow;color:red&quot;&gt; &lt;h5&gt;Second Div&lt;/h5&gt; &lt;p&gt;Yellow backgrond, Red Color&lt;/p&gt; &lt;/div&gt; &lt;div style=&quot;background-color:blue;color:grey&quot;&gt; &lt;h5&gt;Second Div&lt;/h5&gt; &lt;p&gt;Blue backgrond, Grey Color&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 그림 2.12: div 태그 예제 div 태그를 통해 총 세 개의 레이아웃으로 나누어진 것을 알 수 있습니다. style 속성 중 background-color는 배경 색상을, color는 글자 색상을 의미하며, 각 레이아웃마다 다른 스타일이 적용되었습니다. 2.3.8 CSS CSS는 앞서 설명했듯이 웹페이지를 꾸며주는 역할을 합니다. head에서 각 태그에 CSS 효과를 입력하면 본문의 모든 해당 태그에 CSS 효과가 적용됩니다. 이처럼 웹페이지를 꾸미기 위해 특정 요소에 접근하는 것을 셀렉터(Selector)라고 합니다. &lt;html&gt; &lt;head&gt; &lt;style&gt; body {background-color: powderblue;} h4 {color: blue;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h4&gt;This is a heading&lt;/h4&gt; &lt;p&gt;This is a first paragraph.&lt;/p&gt; &lt;p&gt;This is a second paragraph.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 그림 2.13: css 예제 head 태그 사이에 여러 태그에 대한 CSS 효과가 정의되었습니다. 먼저 body의 전체 배경 색상을 powderblue로 설정했으며, h4 태그의 글자 색상은 파란색(blue)으로 설정했습니다. body 태그 내에서 style에 태그를 주지 않더라도, CSS 효과가 모두 적용되었음이 확인됩니다. 2.3.9 클래스와 id CSS를 이용하면 본문의 모든 태그에 효과가 적용되므로, 특정한 요소(Element)에만 동일한 효과를 적용할 수 없습니다. 클래스 속성을 이용하면 동일한 이름을 가진 클래스에는 동일한 효과가 적용됩니다. &lt;html&gt; &lt;style&gt; .index { background-color: tomato; color: white; padding: 10px; } .desc { background-color: moccasin; color: black; padding: 10px; } &lt;/style&gt; &lt;div&gt; &lt;h2 class=&quot;index&quot;&gt;S&amp;P 500&lt;/h2&gt; &lt;p class=&quot;desc&quot;&gt; Market capitalizations of 500 large companies having common stock listed on the NYSE, NASDAQ, or the Cboe BZX Exchange&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;h2&gt;Dow Jones Industrial Average&lt;/h2&gt; &lt;p&gt;Value of 30 large, publicly owned companies based in the United States&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;h2 class=&quot;index&quot;&gt;NASDAQ Composite&lt;/h2&gt; &lt;p class=&quot;desc&quot;&gt;The composition of the NASDAQ Composite is heavily weighted towards information technology companies&lt;/p&gt; &lt;div&gt; &lt;/html&gt; 그림 2.14: class 예제 셀렉터를 클래스에 적용할 때는 클래스명 앞에 마침표(.)를 붙여 표현합니다. 위 예제에서 index 클래스는 배경 색상이 tomato, 글자 색상은 흰색, 여백은 10px로 정의되었습니다. desc 클래스는 배경 색상이 moccasin, 글자 색상은 검은색, 여백은 10px로 정의되었습니다. 본문의 첫 번째(S&amp;P 500)와 세 번째(NASDAQ Composite) 레이아웃의 h2 태그 뒤에는 index 클래스를, p 태그 뒤에는 desc 클래스를 속성으로 입력했습니다. 따라서 해당 레이아웃에만 CSS 효과가 적용되며, 클래스 값이 없는 두 번째 레이아웃에는 효과가 적용되지 않습니다. id 또한 이와 비슷한 역할을 하며, HTML 내에서 여러 개의 클래스가 정의될 수 있는 반면, id는 단 하나만 사용하기를 권장합니다. &lt;html&gt; &lt;head&gt; &lt;style&gt; /* Style the element with the id &quot;myHeader&quot; */ #myHeader { background-color: lightblue; color: black; padding: 15px; text-align: center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- A unique element --&gt; &lt;h1 id=&quot;myHeader&quot;&gt;My Header&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 그림 2.15: id 예제 셀렉터를 id에 적용할 때는 클래스명 앞에 샵(#)를 붙여 표현하며, 페이지에서 한 번만 사용된다는 점을 제외하면 클래스와 사용 방법이 거의 동일합니다. 클래스나 id 값을 통해 원하는 내용을 크롤링하는 경우도 많으므로, 각각의 이름 앞에 마침표(.)와 샵(#) 을 붙여야 한다는 점을 꼭 기억하기 바랍니다. HTML과 관련해 추가적인 정보가 필요하거나 내용이 궁금하다면 아래 웹사이트를 참고하기 바랍니다. w3schools: https://www.w3schools.in/html-tutorial/ 웨버 스터디: http://webberstudy.com/ 2.4 파이프 오퍼레이터(%&gt;%) 파이프 오퍼레이터는 R에서 동일한 데이터를 대상으로 연속으로 작업하게 해주는 오퍼레이터(연산자)입니다. 크롤링에 필수적인 rvest 패키지를 설치하면 자동으로 magrittr 패키지가 설치되어 파이프 오퍼레이터를 사용할 수 있습니다. 흔히 프로그래밍에서 x라는 데이터를 F()라는 함수에 넣어 결괏값을 확인하고 싶으면 F(x)의 방법을 사용합니다. 예를 들어 3과 5라는 데이터 중 큰 값을 찾으려면 max(3,5)를 통해 확인합니다. 이를 통해 나온 결괏값을 또 다시 G()라는 함수에 넣어 결괏값을 확인하려면 비슷한 과정을 거칩니다. max(3,5)를 통해 나온 값의 제곱근을 구하려면 result = max(3,5)를 통해 첫 번째 결괏값을 저장하고, sqrt(result)를 통해 두 번째 결괏값을 계산합니다. 물론 sqrt(max(3,5))와 같은 표현법으로 한 번에 표현할 수 있습니다. 이러한 표현의 단점은 계산하는 함수가 많아질수록 저장하는 변수가 늘어나거나 괄호가 지나치게 길어진다는 것입니다. 그러나 파이프 오퍼레이터인 %&gt;%를 사용하면 함수 간의 관계를 매우 직관적으로 표현하고 이해할 수 있습니다. 이를 정리하면 아래 표 2.3와 같습니다. 표 2.3: 파이프 오퍼레이터의 표현과 내용 비교 내용 표현.방법 F(x) x %&gt;% F G(F(x)) x %&gt;% F %&gt;% G 간단한 예제를 통해 파이프 오퍼레이터의 사용법을 살펴보겠습니다. 먼저 다음과 같은 10개의 숫자가 있다고 가정합니다. x = c(0.3078, 0.2577, 0.5523, 0.0564, 0.4685, 0.4838, 0.8124, 0.3703, 0.5466, 0.1703) 우리가 원하는 과정은 다음과 같습니다. 각 값들의 로그값을 구할 것 로그값들의 계차를 구할 것 구해진 계차의 지수값을 구할 것 소수 둘째 자리까지 반올림할 것 입니다. 즉 log(), diff(), exp(), round()에 대한 값을 순차적으로 구하고자 합니다. x1 = log(x) x2 = diff(x1) x3 = exp(x2) round(x3, 2) ## [1] 0.84 2.14 0.10 8.31 1.03 1.68 0.46 1.48 0.31 첫 번째 방법은 단계별 함수의 결괏값을 변수에 저장하고 저장된 변수를 다시 불러와 함수에 넣고 계산하는 방법입니다. 전반적인 계산 과정을 확인하기에는 좋지만 매번 변수에 저장하고 불러오는 과정이 매우 비효율적이며 코드도 불필요하게 길어집니다. round(exp(diff(log(x))), 2) ## [1] 0.84 2.14 0.10 8.31 1.03 1.68 0.46 1.48 0.31 두 번째는 괄호를 통해 감싸는 방법입니다. 앞선 방법에 비해 코드는 짧아졌지만, 계산 과정을 알아보기에는 매우 불편한 방법으로 코드가 짜여 있습니다. library(magrittr) x %&gt;% log() %&gt;% diff() %&gt;% exp() %&gt;% round(., 2) ## [1] 0.84 2.14 0.10 8.31 1.03 1.68 0.46 1.48 0.31 마지막으로 파이프 오퍼레이터를 사용하는 방법입니다. 코드도 짧으며 계산 과정을 한눈에 파악하기도 좋습니다. 맨 왼쪽에는 원하는 변수를 입력하며, %&gt;% 뒤에는 차례대로 계산하고자 하는 함수를 입력합니다. 변수의 입력값을 ()로 비워둘 경우, 오퍼레이터의 왼쪽에 있는 값이 입력 변수가 됩니다. 반면 round()와 같이 입력값이 두 개 이상 필요하면 마침표(.)가 오퍼레이터의 왼쪽 값으로 입력됩니다. 파이프 오퍼레이터는 크롤링뿐만 아니라 모든 코드에 사용할 수 있습니다. 이를 통해 훨씬 깔끔하면서도 데이터 처리 과정을 직관적으로 이해할 수 있습니다. 2.5 오류에 대한 예외처리 크롤링을 이용해 데이터를 수집할 때 일반적으로 for loop 구문을 통해 수천 종목에 해당하는 웹페이지에 접속해 해당 데이터를 읽어옵니다. 그러나 특정 종목에 해당하는 페이지가 없거나, 단기적으로 접속이 불안정할 경우 오류가 발생해 루프를 처음부터 다시 실행해야 하는 번거로움이 있습니다. tryCatch() 함수를 이용하면 예외처리, 즉 오류가 발생할 경우 이를 무시하고 넘어갈 수 있습니다. tryCatch() 함수의 구조는 다음과 같습니다. result = tryCatch({ expr }, warning = function(w) { warning-handler-code }, error = function(e) { error-handler-code }, finally = { cleanup-code }) 먼저 expr는 실행하고자 하는 코드를 의미합니다. warning은 경고를 나타내며, warning-handler-code는 경고 발생 시 실행할 구문을 의미합니다. 이와 비슷하게 error와 error-handler-code는 각각 오류와 오류 발생 시 실행할 구문을 의미합니다. finally는 오류의 여부와 관계 없이 무조건 수행할 구문을 의미하며, 생략할 수도 있습니다. number = data.frame(1,2,3,&quot;4&quot;,5, stringsAsFactors = FALSE) str(number) ## &#39;data.frame&#39;: 1 obs. of 5 variables: ## $ X1 : num 1 ## $ X2 : num 2 ## $ X3 : num 3 ## $ X.4.: chr &quot;4&quot; ## $ X5 : num 5 먼저 number 변수에는 1에서 5까지 값이 입력되어 있으며, 다른 값들은 형태가 숫자인 반면 4는 문자 형태입니다. for (i in number) { print(i^2) } ## [1] 1 ## [1] 4 ## [1] 9 ## Error in i^2: 이항연산자에 수치가 아닌 인수입니다 for loop 구문을 통해 순서대로 값들의 제곱을 출력하는 명령어를 실행하면 문자 4는 제곱을 할 수 없어 오류가 발생하게 됩니다. tryCatch() 함수를 사용하면 이처럼 오류가 발생하는 루프를 무시하고 다음 루프로 넘어갈 수 있게 됩니다. for (i in number) { tryCatch({ print(i^2) }, error = function(e) { print(paste(&#39;Error:&#39;, i)) }) } ## [1] 1 ## [1] 4 ## [1] 9 ## [1] &quot;Error: 4&quot; ## [1] 25 expr 부분은 print(i^2)이며, error-handler-code 부분은 오류가 발생한 i를 출력합니다. 해당 코드를 실행하면 문자 4에서 오류가 발생함을 알려준 후 루프가 멈추지 않고 다음으로 진행됩니다. "],["api를-이용한-데이터-수집.html", "Chapter 3 API를 이용한 데이터 수집 3.1 API를 이용한 Quandl 데이터 다운로드 3.2 getSymbols() 함수를 이용한 API 다운로드", " Chapter 3 API를 이용한 데이터 수집 이 CHAPTER와 다음 CHAPTER에서는 본격적으로 데이터를 수집하는 방법을 배우겠습니다. 먼저 API를 이용해 데이터를 수집하는 방법을 살펴봅니다. API 제공자는 본인이 가진 데이터베이스를 다른 누군가가 쉽게 사용할 수 있는 형태로 가지고 있으며, 해당 데이터베이스에 접근할 수 있는 열쇠인 API 주소를 가진 사람은 이를 언제든지 사용할 수 있습니다. 그림 3.1: API 개념 API는 API 주소만 가지고 있다면 데이터를 언제, 어디서, 누구나 쉽게 이용할 수 있다는 장점이 있습니다. 또한 대부분의 경우 사용자가 필요한 데이터만을 가지고 있으므로 접속 속도가 빠르며, 데이터를 가공하는 번거로움도 줄어듭니다. 해외에는 금융 데이터를 API의 형태로 제공하는 업체가 많으므로, 이를 잘만 활용한다면 매우 손쉽게 퀀트 투자에 필요한 데이터를 수집할 수 있습니다. 3.1 API를 이용한 Quandl 데이터 다운로드 데이터 제공업체 Quandl은 일부 데이터를 무료로 제공하며 API를 통해서 다운로드할 수 있습니다.6 이 책에서는 예제로 애플(AAPL)의 주가를 다운로드해보겠습니다. csv 형식의 API 주소는 다음과 같습니다. https://www.quandl.com/api/v3/datasets/WIKI/AAPL/data.csv?api_key=xw3NU3xLUZ7vZgrz5QnG 위 주소를 웹 브라우저 주소 창에 직접 입력하면 csv 형식의 파일이 다운로드되며, 파일을 열어보면 애플의 주가 데이터가 있습니다. 그림 3.2: API 주소를 이용한 데이터 다운로드 그러나 웹 브라우저에 해당 주소를 입력해 csv 파일을 다운로드하고 csv 파일을 다시 R에서 불러오는 작업은 무척이나 비효율적입니다. R에서 API 주소를 이용해 직접 데이터를 다운로드할 수 있습니다. url.aapl = &quot;https://www.quandl.com/api/v3/datasets/WIKI/AAPL/data.csv?api_key=xw3NU3xLUZ7vZgrz5QnG&quot; data.aapl = read.csv(url.aapl) head(data.aapl) ## Date Open High Low Close Volume Ex.Dividend Split.Ratio Adj..Open ## 1 2018-03-27 173.7 175.2 166.9 168.3 38962839 0 1 173.7 ## 2 2018-03-26 168.1 173.1 166.4 172.8 36272617 0 1 168.1 ## 3 2018-03-23 168.4 169.9 164.9 164.9 40248954 0 1 168.4 ## 4 2018-03-22 170.0 172.7 168.6 168.8 41051076 0 1 170.0 ## 5 2018-03-21 175.0 175.1 171.3 171.3 35247358 0 1 175.0 ## 6 2018-03-20 175.2 176.8 174.9 175.2 19314039 0 1 175.2 ## Adj..High Adj..Low Adj..Close Adj..Volume ## 1 175.2 166.9 168.3 38962839 ## 2 173.1 166.4 172.8 36272617 ## 3 169.9 164.9 164.9 40248954 ## 4 172.7 168.6 168.8 41051076 ## 5 175.1 171.3 171.3 35247358 ## 6 176.8 174.9 175.2 19314039 url에 해당 주소를 입력한 후 read.csv() 함수를 이용해 간단하게 csv 파일을 불러올 수 있습니다. 3.2 getSymbols() 함수를 이용한 API 다운로드 이전 예시에서 API 주소를 이용하면 매우 간단하게 데이터를 수집할 수 있음을 살펴보았습니다. 그러나 이 방법에는 단점도 있습니다. 먼저 원하는 항목에 대한 API 주소를 일일이 얻기가 힘듭니다. 또한 Quandl의 경우 무료로 얻을 수 있는 정보에 제한이 있으며, 다운로드 양에도 제한이 있습니다. 이 방법으로 한두 종목의 데이터를 수집할 수 있지만, 전 종목의 데이터를 구하기는 사실상 불가능합니다. 다행히 야후 파이낸스 역시 주가 데이터를 무료로 제공하며, quantmod 패키지의 getSymbols() 함수는 해당 API에 접속해 데이터를 다운로드합니다. 3.2.1 주가 다운로드 getSymbols() 함수의 기본적인 사용법은 매우 간단합니다. 괄호 안에 다운로드하려는 종목의 티커를 입력하면 됩니다. library(quantmod) getSymbols(&#39;AAPL&#39;) ## [1] &quot;AAPL&quot; head(AAPL) ## AAPL.Open AAPL.High AAPL.Low AAPL.Close AAPL.Volume AAPL.Adjusted ## 2007-01-03 3.082 3.092 2.925 2.993 1238319600 2.570 ## 2007-01-04 3.002 3.070 2.994 3.059 847260400 2.627 ## 2007-01-05 3.063 3.079 3.014 3.038 834741600 2.608 ## 2007-01-08 3.070 3.090 3.046 3.053 797106800 2.621 ## 2007-01-09 3.087 3.321 3.041 3.306 3349298400 2.839 ## 2007-01-10 3.384 3.493 3.337 3.464 2952880000 2.974 먼저 getSymbols() 함수 내에 애플의 티커인 AAPL을 입력합니다. 티커와 동일한 변수인 AAPL이 생성되며, 주가 데이터가 다운로드된 후 xts 형태로 입력됩니다. 다운로드 결과로 총 6개의 열이 생성됩니다. Open은 시가, High는 고가, Low는 저가, Close는 종가를 의미합니다. 또한 Volume은 거래량을 의미하며, Adjusted는 배당이 반영된 수정주가를 의미합니다. 이 중 가장 많이 사용되는 데이터는 Adjusted, 즉 배당이 반영된 수정주가입니다. chart_Series(Ad(AAPL)) Ad() 함수를 통해 다운로드한 데이터에서 수정주가만을 선택한 후 chart_Series() 함수를 이용해 시계열 그래프를 그릴 수도 있습니다. 시계열 기간을 입력하지 않으면 2007년 1월부터 현재까지의 데이터가 다운로드되며, 입력 변수를 추가해서 원하는 기간의 데이터를 다운로드할 수도 있습니다. data = getSymbols(&#39;AAPL&#39;, from = &#39;2000-01-01&#39;, to = &#39;2018-12-31&#39;, auto.assign = FALSE) head(data) ## AAPL.Open AAPL.High AAPL.Low AAPL.Close AAPL.Volume AAPL.Adjusted ## 2000-01-03 0.9364 1.0045 0.9079 0.9994 535796800 0.8581 ## 2000-01-04 0.9665 0.9877 0.9035 0.9152 512377600 0.7858 ## 2000-01-05 0.9263 0.9872 0.9196 0.9286 778321600 0.7973 ## 2000-01-06 0.9475 0.9554 0.8482 0.8482 767972800 0.7283 ## 2000-01-07 0.8616 0.9018 0.8527 0.8884 460734400 0.7628 ## 2000-01-10 0.9107 0.9129 0.8460 0.8728 505064000 0.7494 from에는 시작시점을 입력하고 to에는 종료시점을 입력하면 해당 기간의 데이터가 다운로드됩니다. getSymbols() 함수를 통해 다운로드한 데이터는 자동으로 티커와 동일한 변수명에 저장됩니다. 만일 티커명이 아닌 원하는 변수명에 데이터를 저장하려면 auto.assign 인자를 FALSE로 설정해주면 다운로드한 데이터가 원하는 변수에 저장됩니다. ticker = c(&#39;FB&#39;, &#39;NVDA&#39;) getSymbols(ticker) ## [1] &quot;FB&quot; &quot;NVDA&quot; head(FB) ## FB.Open FB.High FB.Low FB.Close FB.Volume FB.Adjusted ## 2012-05-18 42.05 45.00 38.00 38.23 573576400 38.23 ## 2012-05-21 36.53 36.66 33.00 34.03 168192700 34.03 ## 2012-05-22 32.61 33.59 30.94 31.00 101786600 31.00 ## 2012-05-23 31.37 32.50 31.36 32.00 73600000 32.00 ## 2012-05-24 32.95 33.21 31.77 33.03 50237200 33.03 ## 2012-05-25 32.90 32.95 31.11 31.91 37149800 31.91 head(NVDA) ## NVDA.Open NVDA.High NVDA.Low NVDA.Close NVDA.Volume NVDA.Adjusted ## 2007-01-03 6.178 6.253 5.798 6.013 115482000 5.525 ## 2007-01-04 5.992 6.013 5.838 5.985 79729800 5.499 ## 2007-01-05 5.843 5.867 5.570 5.610 124334400 5.154 ## 2007-01-08 5.630 5.760 5.533 5.652 65727000 5.192 ## 2007-01-09 5.660 5.698 5.535 5.542 76416600 5.091 ## 2007-01-10 5.483 5.867 5.400 5.815 110874600 5.342 한 번에 여러 종목의 주가를 다운로드할 수도 있습니다. 위 예제와 같이 페이스북과 엔비디아의 티커인 FB와 NVDA를 ticker 변수에 입력하고 getSymbols() 함수에 티커를 입력한 변수를 넣으면 두 종목의 주가가 순차적으로 다운로드됩니다. 3.2.2 국내 종목 주가 다운로드 getSymbols() 함수를 이용하면 미국뿐 아니라 국내 종목의 주가도 다운로드할 수 있습니다. 국내 종목의 티커는 총 6자리로 구성되어 있으며, 해당 함수에 입력되는 티커는 코스피 상장 종목의 경우 티커.KS, 코스닥 상장 종목의 경우 티커.KQ의 형태로 입력해야 합니다. 다음은 코스피 상장 종목인 삼성전자 데이터의 다운로드 예시입니다. getSymbols(&#39;005930.KS&#39;, from = &#39;2000-01-01&#39;, to = &#39;2018-12-31&#39;) ## [1] &quot;005930.KS&quot; tail(Ad(`005930.KS`)) ## 005930.KS.Adjusted ## 2018-12-20 35073 ## 2018-12-21 35073 ## 2018-12-24 35209 ## 2018-12-26 34801 ## 2018-12-27 35033 ## 2018-12-28 35445 삼성전자의 티커인 005930에 .KS를 붙여 getSymbols() 함수에 입력하면 티커명에 해당하는 005930.KS 변수명에 데이터가 저장됩니다. 변수명에 마침표(.)가 있으므로 Ad() 함수를 통해 수정주가를 확인하려면 변수명 앞뒤에 억음 부호(`)를 붙여야 합니다. 국내 종목은 종종 수정주가에 오류가 발생하는 경우가 많아서 배당이 반영된 값보다는 단순 종가(Close) 데이터를 사용하기를 권장합니다. tail(Cl(`005930.KS`)) ## 005930.KS.Close ## 2018-12-20 38650 ## 2018-12-21 38650 ## 2018-12-24 38800 ## 2018-12-26 38350 ## 2018-12-27 38250 ## 2018-12-28 38700 Cl() 함수는 Close, 즉 종가만을 선택하며, 사용 방법은 Ad() 함수와 동일합니다. 비록 배당을 고려할 수는 없지만, 전반적으로 오류가 없는 데이터를 사용할 수 있습니다. 다음은 코스닥 상장종목인 셀트리온제약의 예시이며, 티커인 068670에 .KQ를 붙여 함수에 입력합니다. 역시나 데이터가 다운로드되어 티커명의 변수에 저장됩니다. getSymbols(&quot;068760.KQ&quot;, from = &#39;2000-01-01&#39;, to = &#39;2018-12-31&#39;) ## [1] &quot;068760.KQ&quot; tail(Cl(`068760.KQ`)) ## 068760.KQ.Close ## 2018-12-20 NA ## 2018-12-21 NA ## 2018-12-24 NA ## 2018-12-26 NA ## 2018-12-27 NA ## 2018-12-28 NA 3.2.3 FRED 데이터 다운로드 미국 연방준비은행에서 관리하는 Federal Reserve Economic Data(FRED)는 미국 및 각국의 중요 경제지표 데이터를 살펴볼 때 가장 많이 참조되는 곳 중 하나입니다. getSymbols() 함수를 통해 FRED 데이터를 다운로드할 수 있습니다. 먼저 미 국채 10년물 금리를 다운로드하는 예제를 살펴보겠습니다. getSymbols(&#39;DGS10&#39;, src=&#39;FRED&#39;) ## [1] &quot;DGS10&quot; chart_Series(DGS10) 미 국채 10년물 금리에 해당하는 티커인 DGS10을 입력해주며, 데이터 출처에 해당하는 src에 FRED를 입력해줍니다. FRED에서 제공하는 API를 이용해 데이터가 다운로드되며, chart_Series() 함수를 통해 금리 추이를 살펴볼 수 있습니다. 각 항목별 티커를 찾는 방법은 매우 간단합니다. 먼저 FRED의 웹사이트7원 하는 데이터를 검색합니다. 만일 원/달러 환율에 해당하는 티커를 찾고자 한다면 그림 3.3와 같이 이에 해당하는 South Korea / U.S. Foreign Exchange Rate를 검색해 원하는 페이지에 접속합니다. 이 중 페이지 주소에서 /series/ 다음에 위치하는 DEXKOUS가 해당 항목의 티커입니다. 그림 3.3: FRED 사이트 내 원/달러 환율의 티커 확인 getSymbols(&#39;DEXKOUS&#39;, src=&#39;FRED&#39;) ## [1] &quot;DEXKOUS&quot; tail(DEXKOUS) ## DEXKOUS ## 2021-10-22 1177 ## 2021-10-25 1168 ## 2021-10-26 1168 ## 2021-10-27 1171 ## 2021-10-28 1167 ## 2021-10-29 1175 해당 티커를 입력하면, FRED 웹사이트와 동일한 데이터가 다운로드됩니다. 이 외에도 509,000여 개의 방대한 FRED 데이터를 해당 함수를 통해 손쉽게 R에서 다운로드할 수 있습니다. 자세한 내용은 https://docs.quandl.com/ 에서 확인할 수 있습니다.↩︎ https://fred.stlouisfed.org/↩︎ "],["크롤링-이해하기.html", "Chapter 4 크롤링 이해하기 4.1 GET과 POST 방식 이해하기 4.2 크롤링 예제", " Chapter 4 크롤링 이해하기 API를 이용하면 데이터를 매우 쉽게 수집할 수 있지만, 국내 주식 데이터를 다운로드 하기에는 한계가 있으며, 원하는 데이터가 API의 형태로 제공된다는 보장도 없습니다. 따라서 우리는 필요한 데이터를 얻기 위해 직접 찾아 나서야 합니다. 각종 금융 웹사이트에는 주가, 재무정보 등 우리가 원하는 대부분의 주식 정보가 제공되고 있으며, API를 활용할 수 없는 경우에도 크롤링을 통해 이러한 데이터를 수집할 수 있습니다. 크롤링 혹은 스크래핑이란 웹사이트에서 원하는 정보를 수집하는 기술입니다. 대부분의 금융 웹사이트는 간단한 형태로 작성되어 있어, 몇 가지 기술만 익히면 어렵지 않게 데이터를 크롤링할 수 있습니다. 이 CHAPTER에서는 크롤링에 대한 간단한 설명과 예제를 살펴보겠습니다. 크롤링을 할 때 주의해야 할 점이 있습니다. 특정 웹사이트의 페이지를 쉬지 않고 크롤링하는 행위를 무한 크롤링이라고 합니다. 무한 크롤링은 해당 웹사이트의 자원을 독점하게 되어 타인의 사용을 막게 되며 웹사이트에 부하를 주게 됩니다. 일부 웹사이트에서는 동일한 IP로 쉬지 않고 크롤링을 할 경우 접속을 막아버리는 경우도 있습니다. 따라서 하나의 페이지를 크롤링한 후 1~2초 가량 정지하고 다시 다음 페이지를 크롤링하는 것이 좋습니다. 4.1 GET과 POST 방식 이해하기 우리가 인터넷에 접속해 서버에 파일을 요청하면, 서버는 이에 해당하는 파일을 우리에게 보내줍니다. 크롬과 같은 웹 브라우저는 이러한 과정을 사람이 수행하기 편하고 시각적으로 보기 편하도록 만들어진 것이며, 인터넷 주소는 서버의 주소를 기억하기 쉽게 만든 것입니다. 우리가 서버에 데이터를 요청하는 형태는 다양하지만 크롤링에서는 주로 GET과 POST 방식을 사용합니다. 그림 4.1: 클라이언트와 서버 간의 요청/응답 과정 4.1.1 GET 방식 GET 방식은 인터넷 주소를 기준으로 이에 해당하는 데이터나 파일을 요청하는 것입니다. 주로 클라이언트가 요청하는 쿼리를 앰퍼샌드(&amp;) 혹은 물음표(?) 형식으로 결합해 서버에 전달합니다. 한경컨센서스8에 접속한 후 상단 탭에서 [기업] 탭을 선택하면, 주소 끝부분에 ?skinType=business가 추가되며 이에 해당하는 페이지의 내용을 보여줍니다. 즉, 해당 페이지는 GET 방식을 사용하고 있으며 입력 종류는 skinType, 이에 해당하는 [기업] 탭의 입력값은 business임을 알 수 있습니다. 그림 4.2: 한경 컨센서스 기업 REPORT 페이지 이번에는 [파생] 탭을 선택해봅니다. 역시나 웹사이트 주소 끝부분이 ?skinType=derivative로 변경되며, 해당 주소에 맞는 내용이 나타납니다. 여러 다른 탭들을 클릭해보면 ?skinType= 뒷부분의 입력값이 변함에 따라 이에 해당하는 페이지로 내용 이 변경되는 것을 알 수 있습니다. 다시 [기업] 탭을 선택한 후 다음 페이지를 확인하기 위해 하단의 [2]를 클릭합니다. 기존 주소인 ?skinType=business 뒤에 추가로 sdate와 edate, now_page 쿼리가 추가됩니다. sdate는 검색 기간의 시작시점, edate는 검색 기간의 종료시점, now_ page는 현재 페이지를 의미하며, 원하는 데이터를 수기로 입력해도 이에 해당하는 페이지의 데이터를 보여줍니다. 이처럼 GET 방식으로 데이터를 요청하면 웹페이지 주소를 수정해 원하는 종류의 데이터를 받아올 수 있습니다. 그림 4.3: 쿼리 추가로 인한 url의 변경 4.1.2 POST 방식 POST 방식은 사용자가 필요한 값을 추가해서 요청하는 방법입니다. GET 방식과 달리 클라이언트가 요청하는 쿼리를 body에 넣어서 전송하므로 요청 내역을 직접 볼 수 없습니다. 한국거래소 상장공시시스템9에 접속해 [전체메뉴보기]를 클릭하고 [상장법인상세정보] 중 [상장종목현황]을 선택합니다. 웹페이지 주소가 바뀌며, 상장종목현황이 나타납니다. 그림 4.4: 상장공시시스템의 상장종목현황 메뉴 이번엔 조회일자를 [2017-12-28]로 선택한 후 [검색]을 클릭합니다. 페이지의 내용은 선택일 기준으로 변경되었지만, 주소는 변경되지 않고 그대로 남아 있습니다. GET 방식에서는 선택 항목에 따라 웹페이지 주소가 변경되었지만, POST 방식을 사용해 서버에 데이터를 요청하는 해당 웹사이트는 그렇지 않은 것을 알 수 있습니다. POST 방식의 데이터 요청 과정을 살펴보려면 개발자 도구를 이용해야 하며, 크롬에서는 [F12]키를 눌러 개발자 도구 화면을 열 수 있습니다. 개발자 도구 화면에서 다시 한번 [검색]을 클릭해봅니다. [Network] 탭을 클릭하면, [검색]을 클릭함과 동시에 브라우저와 서버 간의 통신 과정을 살펴볼 수 있습니다. 이 중 listedIssueStatus.do라는 항목이 POST 형태임을 알 수 있습니다. 그림 4.5: 크롬 개발자도구의 Network 화면 해당 메뉴를 클릭하면 통신 과정을 좀 더 자세히 알 수 있습니다. 가장 하단의 Form Data에는 서버에 데이터를 요청하는 내역이 있습니다. method에는 readListIssueStatus, selDate에는 2017-12-28이라는 값이 있습니다. 그림 4.6: POST 방식의 서버 요청 내역 이처럼 POST 방식은 요청하는 데이터에 대한 쿼리가 GET 방식처럼 URL을 통해 전송되는 것이 아닌 body를 통해 전송되므로, 이에 대한 정보는 웹 브라우저를 통해 확인할 수 없습니다. 4.2 크롤링 예제 일반적인 크롤링은 httr 패키지의 GET() 혹은 POST() 함수를 이용해 데이터를 다운로드한 후 rvest 패키지의 함수들을 이용해 원하는 데이터를 찾는 과정으로 이루어집니다. 이 CHAPTER에서는 GET 방식으로 금융 실시간 속보의 제목을 추출하는 예제, POST 방식으로 기업공시채널에서 오늘의 공시를 추출하는 예제, 태그와 속성, 페이지 내비게이션 값을 결합해 국내 상장주식의 종목명 및 티커를 추출하는 예제를 학습해 보겠습니다. 4.2.1 금융 속보 크롤링 크롤링의 간단한 예제로 금융 속보의 제목을 추출해보겠습니다. 먼저 네이버 금융에 접속한 후 [뉴스 → 실시간 속보]10를 선택합니다. 이 중 뉴스의 제목에 해당하는 텍스트만 추출하고자 합니다. 뉴스 제목 부분에 마우스 커서를 올려둔 후 마우스 오른쪽 버튼을 클릭하고 [검사]를 선택하면 개발자 도구 화면이 나타납니다. 여기서 해당 글자가 HTML 내에서 어떤 부분에 위치하는지 확인할 수 있습니다. 해당 제목은 dl 태그 → dd 태그의 articleSubject 클래스 → a 태그 중 title 속성에 위치하고 있습니다. 태그와 속성의 차이가 이해되지 않은 분은 CHAPTER 2를 다시 살펴보기 바랍니다. 그림 4.7: 실시간 속보의 제목 부분 html 먼저 해당 페이지의 내용을 R로 불러옵니다. library(rvest) library(httr) url = &#39;https://finance.naver.com/news/news_list.nhn?mode=LSS2D&amp;section_id=101&amp;section_id2=258&#39; data = GET(url) print(data) 먼저 url 변수에 해당 주소를 입력한 후 GET() 함수를 이용해 해당 페이지의 내용을 받아 data 변수에 저장합니다. data 변수를 확인해보면 Status가 200, 즉 데이터가 이상 없이 받아졌으며, 인코딩(charset)은 EUC-KR 타입으로 되어 있습니다. 우리는 개발자 도구 화면을 통해 제목에 해당하는 부분이 dl 태그 → dd 태그의 articleSubject 클래스 → a 태그 중 title 속성에 위치하고 있음을 살펴보았습니다. 이를 활용해 제목 부분만을 추출하는 방법은 다음과 같습니다. data_title = data %&gt;% read_html(encoding = &#39;EUC-KR&#39;) %&gt;% html_nodes(&#39;dl&#39;) %&gt;% html_nodes(&#39;.articleSubject&#39;) %&gt;% html_nodes(&#39;a&#39;) %&gt;% html_attr(&#39;title&#39;) read_html() 함수를 이용해 해당 페이지의 HTML 내용을 읽어오며, 인코딩은 EUC-KR로 설정합니다. html_nodes() 함수는 해당 태그를 추출하는 함수이며 dl 태그에 해당하는 부분을 추출합니다. html_nodes() 함수를 이용해 articleSubject 클래스에 해당하는 부분을 추출할 수 있으며, 클래스 속성의 경우 이름 앞에 마침표(.)를 붙여주어야 합니다. html_nodes() 함수를 이용해 a 태그를 추출합니다. html_attr() 함수는 속성을 추출하는 함수이며 title에 해당하는 부분만을 추출합니다. 위 과정을 거쳐 data_title에는 실시간 속보의 제목만이 저장됩니다. 이처럼 개발자 도구 화면을 통해 내가 추출하고자 하는 데이터가 HTML 중 어디에 위치하고 있는지 먼저 확인하면 어렵지 않게 해당 데이터를 읽어올 수 있습니다. print(data_title) ## [1] &quot;혈우병을 이긴 CAM 전문가, 두 종&quot; ## [2] &quot;엑손모빌부터 &#39;천슬라&#39;까지…석유의 대&quot; ## [3] &quot;[마감시황] 에코프로, 호실적에 10&quot; ## [4] &quot;롯데케미칼 3분기 영업이익 2천883&quot; ## [5] &quot;당분간 박스권 횡보, 종목별 차별화…&quot; ## [6] &quot;신고가 50만원 육박했는데....\\&quot;목&quot; ## [7] &quot;거래소, &#39;2021 글로벌 ETP 컨&quot; ## [8] &quot;FSN, 전방위 블록체인 신사업 다각&quot; ## [9] &quot;[마감시황] 기관 &#39;팔자&#39;에 하락한 &quot; ## [10] &quot;한국거래소, 9일 ‘글로벌 ETP 컨&quot; ## [11] &quot;거래소, 9일 글로벌 ETP 컨퍼런스&quot; ## [12] &quot;코넥스, 109개 종목 거래…거래대금&quot; ## [13] &quot;센코, 3000억원 규모 공장 증설·&quot; ## [14] &quot;[증시이슈] 카카오페이, 장중 상승폭&quot; ## [15] &quot;단타 개미였던 이재명의 투자론 \\&quot;우량&quot; ## [16] &quot;삼성증권, 3분기 영업익 3627억…&quot; ## [17] &quot;국민의힘 대선후보 테마주 롤러코스터…&quot; ## [18] &quot;롯데케미칼, 3분기 영업익 2883억&quot; ## [19] &quot;인터파크, 3Q 영업손실 72억원… &quot; ## [20] &quot;LGU+ 11년 만에 분기 최대 실적&quot; 4.2.2 기업공시채널에서 오늘의 공시 불러오기 한국거래소 상장공시시스템에 접속한 후 [오늘의 공시 → 전체 → 더보기]를 선택해 전체 공시내용을 확인할 수 있습니다. 그림 4.8: 오늘의공시 확인하기 해당 페이지에서 날짜를 변경하면 페이지의 내용은 해당일의 공시로 변경되지만 URL은 변경되지 않습니다. 이처럼 POST 방식은 요청하는 데이터에 대한 쿼리가 body의 형태를 통해 전송되므로, 개발자 도구 화면을 통해 해당 쿼리에 대한 내용을 확인해야 합니다. 개발자 도구 화면을 연 상태에서 조회일자를 [2018-12-28]로 선택한 후 [검색]을 클릭하고 [Network] 탭의 todaydisclosure.do 항목을 살펴보면 Form Data를 통해 서버에 데이터를 요청하는 내역을 확인할 수 있습니다. 여러 항목 중 selDate 부분이 우리가 선택한 일자로 설정되어 있습니다. 그림 4.9: POST 방식의 데이터 요청 POST 방식으로 쿼리를 요청하는 방법을 코드로 나타내면 다음과 같습니다. library(httr) library(rvest) Sys.setlocale(&quot;LC_ALL&quot;, &quot;English&quot;) url = &#39;https://dev-kind.krx.co.kr/disclosure/todaydisclosure.do&#39; data = POST(url, body = list( method = &#39;searchTodayDisclosureSub&#39;, currentPageSize = &#39;15&#39;, pageIndex = &#39;1&#39;, orderMode = &#39;0&#39;, orderStat = &#39;D&#39;, forward = &#39;todaydisclosure_sub&#39;, chose = &#39;S&#39;, todayFlag = &#39;Y&#39;, selDate = &#39;2018-12-28&#39; )) data = read_html(data) %&gt;% html_table(fill = TRUE) %&gt;% .[[1]] Sys.setlocale(&quot;LC_ALL&quot;, &quot;Korean&quot;) 한글(korean)로 작성된 페이지를 크롤링하면 오류가 발생하는 경우가 종종 있으므로 Sys.setlocale() 함수를 통해 로케일 언어를 영어(English)로 설정합니다. POST() 함수를 통해 해당 url에 원하는 쿼리를 요청하며, 쿼리는 body 내에 리스트 형태로 입력해줍니다. 해당 값은 개발자 도구 화면의 Form Data와 동일하게 입력해주며, marketType과 같이 값이 없는 항목은 입력하지 않아도 됩니다. read_html() 함수를 이용해 해당 페이지의 HTML 내용을 읽어옵니다. html_table() 함수는 테이블 형태의 데이터를 읽어오는 함수입니다. 셀 병합이 된 열이 있으므로 fill=TRUE를 추가합니다. .[[1]]를 통해 첫 번째 리스트를 선택합니다. 한글을 읽기 위해 Sys.setlocale() 함수를 통해 로케일 언어를 다시 Korean으로 변경합니다. 저장된 데이터를 확인하면 화면과 동일한 내용이 출력됩니다. print(head(data)) ## # A tibble: 6 x 5 ## `18:32` 이노와이즈 최대주주변경 이노와이즈 `공시차트\\r\\n\\t\\t\\~ ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 18:26 &quot;에스제이케이&quot; 증권 발행결과(자율공시~ 에스제이케~ &quot;공시차트\\r\\n\\t\\t\\~ ## 2 18:11 &quot;아이엠텍&quot; [정정]유상증자결정(제3~ 아이엠텍 &quot;&quot; ## 3 18:10 &quot;시그넷이브이&quot; 유형자산 양수 결정 시그넷이브~ &quot;공시차트\\r\\n\\t\\t\\~ ## 4 18:09 &quot;&quot; 자기주식매매신청내역(~ 코스닥시장~ &quot;&quot; ## 5 18:09 &quot;&quot; 대량매매내역(코스닥시~ 코스닥시장~ &quot;&quot; ## 6 18:08 &quot;&quot; 최근 20일중 최저(최고)~ 코스닥시장~ &quot;&quot; POST 형식의 경우 body에 들어가는 쿼리 내용을 바꾸어 원하는 데이터를 받을 수 있습니다. 만일 2020년 9월 18일 공시를 확인하고자 한다면 위의 코드에서 selDate만 2020-09-18로 변경해주면 됩니다. 아래 코드의 출력 결과물을 2020년 9월 18일 공시와 비교하면 동일한 결과임을 확인할 수 있습니다. Sys.setlocale(&quot;LC_ALL&quot;, &quot;English&quot;) url = &#39;https://dev-kind.krx.co.kr/disclosure/todaydisclosure.do&#39; data = POST(url, body = list( method = &#39;searchTodayDisclosureSub&#39;, currentPageSize = &#39;15&#39;, pageIndex = &#39;1&#39;, orderMode = &#39;0&#39;, orderStat = &#39;D&#39;, forward = &#39;todaydisclosure_sub&#39;, chose = &#39;S&#39;, todayFlag = &#39;Y&#39;, selDate = &#39;2020-09-18&#39; )) data = read_html(data) %&gt;% html_table(fill = TRUE) %&gt;% .[[1]] Sys.setlocale(&quot;LC_ALL&quot;, &quot;Korean&quot;) print(head(data)) ## # A tibble: 6 x 5 ## `18:24` KMH `소송등의제기(전환사채~ 케이엠에이치 `공시차트\\r\\n\\t\\t~ ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 18:19 &quot;대한그린파워&quot; 증권 발행결과(자율공시~ 대한그린파워 &quot;공시차트\\r\\n\\t\\t~ ## 2 18:19 &quot;대한그린파워&quot; 전환사채(해외전환사채~ 대한그린파워 &quot;공시차트\\r\\n\\t\\t~ ## 3 18:17 &quot;이더블유케이&quot; 전환사채권발행결정(제4~ 이더블유케이 &quot;공시차트\\r\\n\\t\\t~ ## 4 18:08 &quot;&quot; 자기주식매매신청내역(~ 코스닥시장~ &quot;&quot; ## 5 18:08 &quot;&quot; 대량매매내역(코스닥시~ 코스닥시장~ &quot;&quot; ## 6 18:08 &quot;&quot; 일일회전율상위20종목(~ 코스닥시장~ &quot;&quot; 4.2.3 네이버 금융에서 주식티커 크롤링 태그와 속성, 페이지 내비게이션 값을 결합해 국내 상장주식의 종목명 및 티커를 추출하는 방법을 알아보겠습니다. 네이버 금융에서 [국내증시 → 시가총액] 페이지에는 코스피와 코스닥의 시가총액별 정보가 나타나 있습니다. 코스피: https://finance.naver.com/sise/sise_market_sum.nhn?sosok=0&amp;page=1 코스닥: https://finance.naver.com/sise/sise_market_sum.nhn?sosok=1&amp;page=1 또한 종목명을 클릭해 이동하는 페이지의 URL을 확인해보면, 끝 6자리가 각 종목의 거래소 티커임도 확인이 됩니다. 티커 정리를 위해 HTML에서 확인해야 할 부분은 총 두 가지입니다. 먼저 하단의 페이지 내비게이션을 통해 코스피와 코스닥 시가총액에 해당하는 페이지가 각각 몇 번째 페이지까지 있는지 알아야 합니다. 아래와 같은 항목 중 [맨뒤]에 해당하는 페이지가 가장 마지막 페이지입니다. 그림 4.10: 페이지 네비게이션 [맨뒤]에 마우스 커서를 올려두고 마우스 오른쪽 버튼을 클릭한 후 [검사]를 선택하면 개발자 도구 화면이 열립니다. 여기서 해당 글자가 HTML 내에서 어떤 부분에 위치하는지 확인할 수 있습니다. 해당 링크는 pgRR 클래스 → a 태그 중 href 속성에 위치하며, page= 뒷부분의 숫자에 위치하는 페이지로 링크가 걸려 있습니다. 그림 4.11: HTML 내 페이지 네비게이션 부분 종목명 링크에 해당하는 주소 중 끝 6자리는 티커에 해당합니다. 따라서 각 링크들의 주소를 알아야 할 필요도 있습니다. 그림 4.12: 네이버 금융 시가총액 페이지 삼성전자에 마우스 커서를 올려둔 후 마우스 오른쪽 버튼을 클릭하고 [검사]를 선택합니다. 개발자 도구 화면을 살펴보면 해당 링크가 tbody → td → a 태그의 href 속성에 위치하고 있음을 알 수 있습니다. 위 정보들을 이용해 데이터를 다운로드하겠습니다. 아래 코드에서 i = 0일 경우 코스피에 해당하는 URL이 생성되고, i = 1일 경우 코스닥에 해당하는 URL이 생성됩니다. 먼저 코스피에 해당하는 데이터를 다운로드하겠습니다. library(httr) library(rvest) i = 0 ticker = list() url = paste0(&#39;https://finance.naver.com/sise/&#39;, &#39;sise_market_sum.nhn?sosok=&#39;,i,&#39;&amp;page=1&#39;) down_table = GET(url) 빈 리스트인 ticker 변수를 만들어줍니다. paste0() 함수를 이용해 코스피 시가총액 페이지의 url을 만듭니다. GET() 함수를 통해 해당 페이지 내용을 받아 down_table 변수에 저장합니다. 가장 먼저 해야 할 작업은 마지막 페이지가 몇 번째 페이지인지 찾아내는 작업입니다. 우리는 이미 개발자 도구 화면을 통해 해당 정보가 pgRR 클래스의 a 태그 중 href 속성에 위치하고 있음을 알고 있습니다. navi.final = read_html(down_table, encoding = &#39;EUC-KR&#39;) %&gt;% html_nodes(., &#39;.pgRR&#39;) %&gt;% html_nodes(., &#39;a&#39;) %&gt;% html_attr(., &#39;href&#39;) read_html() 함수를 이용해 해당 페이지의 HTML 내용을 읽어오며, 인코딩은 EUC-KR로 설정합니다. html_nodes() 함수를 이용해 pgRR 클래스 정보만 불러오며, 클래스 속성이므로 앞에 마침표(.)를 붙입니다. html_nodes() 함수를 통해 a 태그 정보만 불러옵니다. html_attr() 함수를 통해 href 속성을 불러옵니다. 이를 통해 navi.final에는 해당 부분에 해당하는 내용이 저장됩니다. print(navi.final) ## [1] &quot;/sise/sise_market_sum.nhn?sosok=0&amp;page=34&quot; 이 중 우리가 알고 싶은 내용은 page= 뒤에 있는 숫자입니다. 해당 내용을 추출하는 코드는 다음과 같습니다. navi.final = navi.final %&gt;% strsplit(., &#39;=&#39;) %&gt;% unlist() %&gt;% tail(., 1) %&gt;% as.numeric() strsplit() 함수는 전체 문장을 특정 글자 기준으로 나눕니다. page= 뒷부분 의 데이터만 필요하므로 =를 기준으로 문장을 나눠줍니다. unlist() 함수를 통해 결과를 벡터 형태로 변환합니다. tail() 함수를 통해 뒤에서 첫 번째 데이터만 선택합니다. as.numeric() 함수를 통해 해당 값을 숫자 형태로 바꾸어줍니다. print(navi.final) ## [1] 34 코스피 시가총액 페이지는 34번째 페이지까지 있으며, for loop 구문을 이용하면 1페이지부터 navi.final, 즉 34 페이지까지 모든 내용을 읽어올 수 있습니다. 먼저 코스피의 첫 번째 페이지에서 우리가 원하는 데이터를 추출하는 방법을 살펴보겠습니다. i = 0 # 코스피 j = 1 # 첫번째 페이지 url = paste0(&#39;https://finance.naver.com/sise/&#39;, &#39;sise_market_sum.nhn?sosok=&#39;,i,&quot;&amp;page=&quot;,j) down_table = GET(url) i와 j에 각각 0과 1을 입력해 코스피 첫 번째 페이지에 해당하는 url을 생성합니다. GET() 함수를 이용해 해당 페이지의 데이터를 다운로드합니다. Sys.setlocale(&quot;LC_ALL&quot;, &quot;English&quot;) table = read_html(down_table, encoding = &quot;EUC-KR&quot;) %&gt;% html_table(fill = TRUE) table = table[[2]] Sys.setlocale(&quot;LC_ALL&quot;, &quot;Korean&quot;) Sys.setlocale() 함수를 통해 로케일 언어를 English로 설정합니다. read_html() 함수를 통해 HTML 정보를 읽어옵니다. html_table() 함수를 통해 테이블 정보를 읽어오며, fill=TRUE를 추가해줍니다. table 변수에는 리스트 형태로 총 세 가지 테이블이 저장되어 있습니다. 첫 번째 리스트에는 거래량, 시가, 고가 등 적용 항목이 저장되어 있고 세 번째 리스트에는 페이지 내비게이션 테이블이 저장되어 있으므로, 우리에게 필요한 두 번째 리스트만을 table 변수에 다시 저장합니다. 한글을 읽기 위해 Sys.setlocale() 함수를 통해 로케일 언어를 다시 Korean으로 변경합니다. 저장된 테이블 내용을 확인하면 다음과 같습니다. print(head(table)) ## # A tibble: 6 x 13 ## N 종목명 현재가 전일비 등락률 액면가 시가총액 상장주식수 외국인비율 거래량 ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 NA &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; NA &quot;&quot; ## 2 1 &quot;삼성~ &quot;70,2~ &quot;400&quot; &quot;-0.5~ &quot;100&quot; &quot;4,190,~ &quot;5,969,78~ 51.2 &quot;12,6~ ## 3 2 &quot;SK하~ &quot;107,~ &quot;1,00~ &quot;+0.9~ &quot;5,00~ &quot;778,96~ &quot;728,002&quot; 47.3 &quot;2,50~ ## 4 3 &quot;NAVE~ &quot;410,~ &quot;1,00~ &quot;-0.2~ &quot;100&quot; &quot;674,30~ &quot;164,263&quot; 56.7 &quot;308,~ ## 5 4 &quot;카카~ &quot;128,~ &quot;1,50~ &quot;-1.1~ &quot;100&quot; &quot;572,28~ &quot;445,361&quot; 30.7 &quot;2,79~ ## 6 5 &quot;삼성~ &quot;864,~ &quot;1,00~ &quot;-0.1~ &quot;2,50~ &quot;571,66~ &quot;66,165&quot; 10.6 &quot;48,9~ ## # ... with 3 more variables: PER &lt;dbl&gt;, ROE &lt;chr&gt;, 토론실 &lt;lgl&gt; 이 중 마지막 열인 토론실은 필요 없는 열이며, 첫 번째 행과 같이 아무런 정보가 없는 행도 있습니다. 이를 다음과 같이 정리해줍니다. table[, ncol(table)] = NULL table = na.omit(table) print(head(table)) ## # A tibble: 6 x 12 ## N 종목명 현재가 전일비 등락률 액면가 시가총액 상장주식수 외국인비율 거래량 ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 삼성~ 70,200 400 -0.57% 100 4,190,7~ 5,969,783 51.2 12,60~ ## 2 2 SK하~ 107,0~ 1,000 +0.94% 5,000 778,963 728,002 47.3 2,501~ ## 3 3 NAVER 410,5~ 1,000 -0.24% 100 674,301 164,263 56.7 308,6~ ## 4 4 카카오 128,5~ 1,500 -1.15% 100 572,289 445,361 30.7 2,798~ ## 5 5 삼성~ 864,0~ 1,000 -0.12% 2,500 571,666 66,165 10.6 48,927 ## 6 6 LG화학 786,0~ 4,000 -0.51% 5,000 554,856 70,592 47.4 172,1~ ## # ... with 2 more variables: PER &lt;dbl&gt;, ROE &lt;chr&gt; 이제 필요한 정보는 6자리 티커입니다. 티커 역시 개발자 도구 화면을 통해 tbody → td → a 태그의 href 속성에 위치하고 있음을 알고 있습니다. 티커를 추출하는 코드는 다음과 같습니다. symbol = read_html(down_table, encoding = &#39;EUC-KR&#39;) %&gt;% html_nodes(., &#39;tbody&#39;) %&gt;% html_nodes(., &#39;td&#39;) %&gt;% html_nodes(., &#39;a&#39;) %&gt;% html_attr(., &#39;href&#39;) print(head(symbol, 10)) ## [1] &quot;/item/main.naver?code=005930&quot; &quot;/item/board.naver?code=005930&quot; ## [3] &quot;/item/main.naver?code=000660&quot; &quot;/item/board.naver?code=000660&quot; ## [5] &quot;/item/main.naver?code=035420&quot; &quot;/item/board.naver?code=035420&quot; ## [7] &quot;/item/main.naver?code=035720&quot; &quot;/item/board.naver?code=035720&quot; ## [9] &quot;/item/main.naver?code=207940&quot; &quot;/item/board.naver?code=207940&quot; read_html() 함수를 통해 HTML 정보를 읽어오며, 인코딩은 EUC-KR로 설정합니다. html_nodes() 함수를 통해 tbody 태그 정보를 불러옵니다. 다시 html_nodes() 함수를 통해 td와 a 태그 정보를 불러옵니다. html_attr() 함수를 이용해 href 속성을 불러옵니다. 이를 통해 symbol에는 href 속성에 해당하는 링크 주소들이 저장됩니다. 이 중 마지막 6자리 글자만 추출하는 코드는 다음과 같습니다. library(stringr) symbol = sapply(symbol, function(x) { str_sub(x, -6, -1) }) print(head(symbol, 10)) ## /item/main.naver?code=005930 /item/board.naver?code=005930 ## &quot;005930&quot; &quot;005930&quot; ## /item/main.naver?code=000660 /item/board.naver?code=000660 ## &quot;000660&quot; &quot;000660&quot; ## /item/main.naver?code=035420 /item/board.naver?code=035420 ## &quot;035420&quot; &quot;035420&quot; ## /item/main.naver?code=035720 /item/board.naver?code=035720 ## &quot;035720&quot; &quot;035720&quot; ## /item/main.naver?code=207940 /item/board.naver?code=207940 ## &quot;207940&quot; &quot;207940&quot; sapply() 함수를 통해 symbol 변수의 내용들에 function()을 적용하며, stringr 패키지의 str_sub() 함수를 이용해 마지막 6자리 글자만 추출합니다. 결과를 살펴보면 티커에 해당하는 마지막 6글자만 추출되지만 동일한 내용이 두 번 연속해 추출됩니다. 이는 main.nhn?code=에 해당하는 부분은 종목명에 설정된 링크, board.nhn?code=에 해당하는 부분은 토론실에 설정된 링크이기 때문입니다. symbol = unique(symbol) print(head(symbol, 10)) ## [1] &quot;005930&quot; &quot;000660&quot; &quot;035420&quot; &quot;035720&quot; &quot;207940&quot; &quot;051910&quot; &quot;005935&quot; &quot;006400&quot; ## [9] &quot;005380&quot; &quot;000270&quot; unique() 함수를 이용해 중복되는 티커를 제거하면 우리가 원하는 티커 부분만 깔끔하게 정리됩니다. 해당 내용을 위에서 구한 테이블에 입력한 후 데이터를 다듬는 과정은 다음과 같습니다. table$N = symbol colnames(table)[1] = &#39;종목코드&#39; rownames(table) = NULL ticker[[j]] = table 위에서 구한 티커를 N열에 입력합니다. 해당 열 이름을 종목코드로 변경합니다. na.omit() 함수를 통해 특정 행을 삭제했으므로, 행 이름을 초기화해줍니다. ticker의 j번째 리스트에 정리된 데이터를 입력합니다. 위의 코드에서 i와 j 값을 for loop 구문에 이용하면 코스피와 코스닥 전 종목의 티커가 정리된 테이블을 만들 수 있습니다. 이를 전체 코드로 나타내면 다음과 같습니다. data = list() # i = 0 은 코스피, i = 1 은 코스닥 종목 for (i in 0:1) { ticker = list() url = paste0(&#39;https://finance.naver.com/sise/&#39;, &#39;sise_market_sum.nhn?sosok=&#39;,i,&#39;&amp;page=1&#39;) down_table = GET(url) # 최종 페이지 번호 찾아주기 navi.final = read_html(down_table, encoding = &quot;EUC-KR&quot;) %&gt;% html_nodes(., &quot;.pgRR&quot;) %&gt;% html_nodes(., &quot;a&quot;) %&gt;% html_attr(.,&quot;href&quot;) %&gt;% strsplit(., &quot;=&quot;) %&gt;% unlist() %&gt;% tail(., 1) %&gt;% as.numeric() # 첫번째 부터 마지막 페이지까지 for loop를 이용하여 테이블 추출하기 for (j in 1:navi.final) { # 각 페이지에 해당하는 url 생성 url = paste0( &#39;https://finance.naver.com/sise/&#39;, &#39;sise_market_sum.nhn?sosok=&#39;,i,&quot;&amp;page=&quot;,j) down_table = GET(url) Sys.setlocale(&quot;LC_ALL&quot;, &quot;English&quot;) # 한글 오류 방지를 위해 영어로 로케일 언어 변경 table = read_html(down_table, encoding = &quot;EUC-KR&quot;) %&gt;% html_table(fill = TRUE) table = table[[2]] # 원하는 테이블 추출 Sys.setlocale(&quot;LC_ALL&quot;, &quot;Korean&quot;) # 한글을 읽기위해 로케일 언어 재변경 table[, ncol(table)] = NULL # 토론식 부분 삭제 table = na.omit(table) # 빈 행 삭제 # 6자리 티커만 추출 symbol = read_html(down_table, encoding = &quot;EUC-KR&quot;) %&gt;% html_nodes(., &quot;tbody&quot;) %&gt;% html_nodes(., &quot;td&quot;) %&gt;% html_nodes(., &quot;a&quot;) %&gt;% html_attr(., &quot;href&quot;) symbol = sapply(symbol, function(x) { str_sub(x, -6, -1) }) symbol = unique(symbol) # 테이블에 티커 넣어준 후, 테이블 정리 table$N = symbol colnames(table)[1] = &quot;종목코드&quot; rownames(table) = NULL ticker[[j]] = table Sys.sleep(0.5) # 페이지 당 0.5초의 슬립 적용 } # do.call을 통해 리스트를 데이터 프레임으로 묶기 ticker = do.call(rbind, ticker) data[[i + 1]] = ticker } # 코스피와 코스닥 테이블 묶기 data = do.call(rbind, data) http://hkconsensus.hankyung.com/↩︎ http://kind.krx.co.kr/↩︎ https://finance.naver.com/news/news_list.nhn?mode=LSS2D&amp;section_id=101&amp;section_id2=258↩︎ "],["금융-데이터-수집하기-기본.html", "Chapter 5 금융 데이터 수집하기 (기본) 5.1 한국거래소의 산업별 현황 및 개별지표 크롤링 5.2 WICS 기준 섹터정보 크롤링", " Chapter 5 금융 데이터 수집하기 (기본) API와 크롤링을 이용한다면 비용을 지불하지 않고 얼마든지 금융 데이터를 수집할 수있습니다. 이 CHAPTER에서는 금융 데이터를 받기 위해 필요한 주식티커를 구하는 방법과 섹터별 구성종목을 크롤링하는 방법을 알아보겠습니다. 5.1 한국거래소의 산업별 현황 및 개별지표 크롤링 앞 CHAPTER의 예제를 통해 네이버 금융에서 주식티커를 크롤링하는 방법을 살펴보았습니다. 그러나 이 방법은 지나치게 복잡하고 시간이 오래 걸립니다. 반면 한국거래소에서 제공하는 업종분류 현황과 개별종목 지표 데이터를 이용하면 훨씬 간단하게 주식티커 데이터를 수집할 수 있습니다. KRX 정보데이터시스템 http://data.krx.co.kr/ 에서 [기본통계 → 주식 → 세부안내] 부분 [12025] 업종분류 현황 [12021] 개별종목 해당 데이터들을 크롤링이 아닌 [Excel] 버튼을 클릭해 엑셀 파일로 받을 수도 있습니다. 그러나 매번 엑셀 파일을 다운로드하고 이를 R로 불러오는 작업은 상당히 비효율적이며, 크롤링을 이용한다면 해당 데이터를 R로 직접 불러올 수 있습니다. 5.1.1 업종분류 현황 크롤링 먼저 업종분류 현황에 해당하는 페이지에 접속한 후 개발자 도구 화면을 열고 [다운로드] 버튼을 클릭한 후 [CSV]를 누릅니다. [Network] 탭에는 generate.cmd와 download.cmd 두 가지 항목이 있습니다. 거래소에서 엑셀 데이터를 받는 과정은 다음과 같습니다. http://data.krx.co.kr/comm/fileDn/download_excel/download.cmd 에 원하는 항목을 쿼리로 발송하면 해당 쿼리에 해당하는 OTP(generate.cmd)를 받게 됩니다. 부여받은 OTP를 http://data.krx.co.kr/에 제출하면 이에 해당하는 데이터(download.cmd)를 다운로드하게 됩니다. 먼저 1번 단계를 살펴보겠습니다. 그림 5.1: OTP 생성 부분 General 항목의 Request URL의 앞부분이 원하는 항목을 제출할 주소입니다. Form Data에는 우리가 원하는 항목들이 적혀 있습니다. 이를 통해 POST 방식으로 데이터를 요청함을 알 수 있습니다. 다음으로 2번 단계를 살펴보겠습니다. 그림 5.2: OTP 제출 부분 General 항목의 Request URL은 OTP를 제출할 주소입니다. Form Data의 OTP는 1번 단계에서 부여받은 OTP에 해당합니다. 이 역시 POST 방식으로 데이터를 요청합니다. 위 과정을 코드로 나타내면 다음과 같습니다. library(httr) library(rvest) library(readr) gen_otp_url = &#39;http://data.krx.co.kr/comm/fileDn/GenerateOTP/generate.cmd&#39; gen_otp_data = list( mktId = &#39;STK&#39;, trdDd = &#39;20210108&#39;, money = &#39;1&#39;, csvxls_isNo = &#39;false&#39;, name = &#39;fileDown&#39;, url = &#39;dbms/MDC/STAT/standard/MDCSTAT03901&#39; ) otp = POST(gen_otp_url, query = gen_otp_data) %&gt;% read_html() %&gt;% html_text() gen_otp_url에 원하는 항목을 제출할 URL을 입력합니다. 개발자 도구 화면에 나타는 쿼리 내용들을 리스트 형태로 입력합니다. 이 중 mktId의 STK는 코스피에 해당하는 내용이며, 코스닥 데이터를 받고자 할 경우 KSQ를 입력해야 합니다. POST() 함수를 통해 해당 URL에 쿼리를 전송하면 이에 해당하는 데이터를 받게 됩니다. read_html()함수를 통해 HTML 내용을 읽어옵니다. html_text() 함수는 HTML 내에서 텍스트에 해당하는 부분만을 추출합니다. 이를 통해 OTP 값만 추출하게 됩니다. 위의 과정을 거쳐 생성된 OTP를 제출하면, 우리가 원하는 데이터를 다운로드할 수 있습니다. down_url = &#39;http://data.krx.co.kr/comm/fileDn/download_csv/download.cmd&#39; down_sector_KS = POST(down_url, query = list(code = otp), add_headers(referer = gen_otp_url)) %&gt;% read_html(encoding = &#39;EUC-KR&#39;) %&gt;% html_text() %&gt;% read_csv() OTP를 제출할 URL을 down_url에 입력합니다. POST() 함수를 통해 위에서 부여받은 OTP 코드를 해당 URL에 제출합니다. add_headers() 구문을 통해 리퍼러(referer)를 추가해야 합니다. 리퍼러란 링크를 통해서 각각의 웹사이트로 방문할 때 남는 흔적입니다. 거래소 데이터를 다운로드하는 과정을 살펴보면 첫 번째 URL에서 OTP를 부여받고, 이를 다시 두번째 URL에 제출했습니다. 그런데 이러한 과정의 흔적이 없이 OTP를 바로 두번째 URL에 제출하면 서버는 이를 로봇으로 인식해 데이터를 반환하지 않습니다. 따라서 add_headers() 함수를 통해 우리가 거쳐온 과정을 흔적으로 남겨 야 데이터를 반환하게 되며 첫 번째 URL을 리퍼러로 지정해줍니다. read_html()과 html_text() 함수를 통해 텍스트 데이터만 추출합니다. EUC-KR로 인코딩이 되어 있으므로 read_html() 내에 이를 입력해줍니다. read_csv() 함수는 csv 형태의 데이터를 불러옵니다. print(down_sector_KS) ## # A tibble: 917 x 8 ## 종목코드 종목명 시장구분 업종명 종가 대비 등락률 시가총액 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 095570 AJ네트웍스 KOSPI 서비스업 4540 -155 -3.3 212573219300 ## 2 006840 AK홀딩스 KOSPI 기타금융 25350 150 0.6 335825671350 ## 3 027410 BGF KOSPI 기타금융 4905 -25 -0.51 469490859855 ## 4 282330 BGF리테일 KOSPI 유통업 141000 4500 3.3 2437030746000 ## 5 138930 BNK금융지주 KOSPI 기타금융 5780 0 0 1883905721880 ## 6 001460 BYC KOSPI 섬유의복 324500 10500 3.34 202687567500 ## 7 001465 BYC우 KOSPI 섬유의복 157500 10000 6.78 33923137500 ## 8 001040 CJ KOSPI 기타금융 102500 7600 8.01 2990642295000 ## 9 079160 CJ CGV KOSPI 서비스업 26150 300 1.16 917865000000 ## 10 00104K CJ4우(전환) KOSPI 기타금융 81400 5300 6.96 344038076800 ## # ... with 907 more rows 위 과정을 통해 down_sector 변수에는 산업별 현황 데이터가 저장되었습니다. 코스닥 시장의 데이터도 다운로드 받도록 하겠습니다. gen_otp_data = list( mktId = &#39;KSQ&#39;, # 코스닥으로 변경 trdDd = &#39;20210108&#39;, money = &#39;1&#39;, csvxls_isNo = &#39;false&#39;, name = &#39;fileDown&#39;, url = &#39;dbms/MDC/STAT/standard/MDCSTAT03901&#39; ) otp = POST(gen_otp_url, query = gen_otp_data) %&gt;% read_html() %&gt;% html_text() down_sector_KQ = POST(down_url, query = list(code = otp), add_headers(referer = gen_otp_url)) %&gt;% read_html(encoding = &#39;EUC-KR&#39;) %&gt;% html_text() %&gt;% read_csv() 코스피 데이터와 코스닥 데이터를 하나로 합치도록 합니다. down_sector = rbind(down_sector_KS, down_sector_KQ) 이를 csv 파일로 저장하겠습니다. ifelse(dir.exists(&#39;data&#39;), FALSE, dir.create(&#39;data&#39;)) write.csv(down_sector, &#39;data/krx_sector.csv&#39;) 먼저 ifelse() 함수를 통해 data라는 이름의 폴더가 있으면 FALSE를 반환하고, 없으면 해당 이름으로 폴더를 생성해줍니다. 그 후 앞서 다운로드한 데이터를 data 폴더 안에 krx_sector.csv 이름으로 저장합니다. 해당 폴더를 확인해보면 데이터가 csv 형태로 저장되어 있습니다. 5.1.2 개별종목 지표 크롤링 개별종목 데이터를 크롤링하는 방법은 위와 매우 유사하며, 요청하는 쿼리 값에만 차이가 있습니다. 개발자 도구 화면을 열고 [CSV] 버튼을 클릭해 어떠한 쿼리를 요청하는지 확인합니다. 그림 5.3: 개별지표 OTP 생성 부분 이 중 tboxisuCd_finder_stkisu0_6, isu_Cd, isu_Cd2 등의 항목은 조회 구분의 개별추이 탭에 해당하는 부분이므로 우리가 원하는 전체 데이터를 받을 때는 필요하지 않은 요청값입니다. 이를 제외한 요청값을 산업별 현황 예제에 적용하면 해당 데이터 역시 손쉽게 다운로드할 수 있습니다. library(httr) library(rvest) library(readr) gen_otp_url = &#39;http://data.krx.co.kr/comm/fileDn/GenerateOTP/generate.cmd&#39; gen_otp_data = list( searchType = &#39;1&#39;, mktId = &#39;ALL&#39;, trdDd = &#39;20210108&#39;, csvxls_isNo = &#39;false&#39;, name = &#39;fileDown&#39;, url = &#39;dbms/MDC/STAT/standard/MDCSTAT03501&#39; ) otp = POST(gen_otp_url, query = gen_otp_data) %&gt;% read_html() %&gt;% html_text() down_url = &#39;http://data.krx.co.kr/comm/fileDn/download_csv/download.cmd&#39; down_ind = POST(down_url, query = list(code = otp), add_headers(referer = gen_otp_url)) %&gt;% read_html(encoding = &#39;EUC-KR&#39;) %&gt;% html_text() %&gt;% read_csv() print(down_ind) ## # A tibble: 2,345 x 11 ## 종목코드 종목명 종가 대비 등락률 EPS PER BPS PBR 주당배당금 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 060310 3S 2245 -45 -1.97 NA NA 745 3.01 0 ## 2 095570 AJ네트웍스 4540 -155 -3.3 982 4.62 6802 0.67 300 ## 3 006840 AK홀딩스 25350 150 0.6 2168 11.7 62448 0.41 750 ## 4 054620 APS홀딩스 7500 -150 -1.96 NA NA 10530 0.71 0 ## 5 265520 AP시스템 26000 -100 -0.38 671 38.8 7468 3.48 50 ## 6 211270 AP위성 8100 -250 -2.99 51 159. 5479 1.48 70 ## 7 027410 BGF 4905 -25 -0.51 281 17.5 15699 0.31 110 ## 8 282330 BGF리테일 141000 4500 3.3 8763 16.1 36022 3.91 2700 ## 9 138930 BNK금융지주 5780 0 0 1647 3.51 25415 0.23 360 ## 10 001460 BYC 324500 10500 3.34 33265 9.75 517079 0.63 1100 ## # ... with 2,335 more rows, and 1 more variable: 배당수익률 &lt;dbl&gt; 위 과정을 통해 down_ind 변수에는 개별종목 지표 데이터가 저장되었습니다. 해당 데이터 역시 csv 파일로 저장하겠습니다. write.csv(down_ind, &#39;data/krx_ind.csv&#39;) 5.1.3 최근 영업일 기준 데이터 받기 위 예제의 쿼리 항목 중 date와 schdate 부분을 원하는 일자로 입력하면(예: 20190104) 해당일의 데이터를 다운로드할 수 있으며, 전 영업일 날짜를 입력하면 가장 최근의 데이터를 받을 수 있습니다. 그러나 매번 해당 항목을 입력하기는 번거로우므로 자동으로 반영되게 할 필요가 있습니다. 네이버 금융의 [국내증시 → 증시자금동향]에는 이전 2영업일에 해당하는 날짜가 있으며, 자동으로 날짜가 업데이트되어 편리합니다. 따라서 해당 부분을 크롤링해 쿼리 항목에 사용할 수 있습니다. 그림 5.4: 최근 영업일 부분 크롤링하고자 하는 데이터가 하나거나 소수일때는 HTML 구조를 모두 분해한 후 데이터를 추출하는 것보다 Xpath를 이용하는 것이 훨씬 효율적입니다. Xpath란 XML 중 특정 값의 태그나 속성을 찾기 쉽게 만든 주소라 생각하면 됩니다. 예를 들어 R 프로그램이 저장된 곳을 윈도우 탐색기를 이용해 이용하면 C:\\Program Files\\R\\R-3.4.2 형태의 주소를 보이는데 이것은 윈도우의 path 문법입니다. XML 역시 이와 동일한 개념의 Xpath가 있습니다. 웹페이지에서 Xpath를 찾는 법은 다음과 같습니다. 그림 5.5: Xpath 복사하기 먼저 크롤링하고자 하는 내용에 마우스 커서를 올린 채 마우스 오른쪽 버튼을 클릭한 후 [검사]를 선택합니다. 그러면 개발자 도구 화면이 열리며 해당 지점의 HTML 부분이 선택됩니다. 그 후 HTML 화면에서 마우스 오른쪽 버튼을 클릭하고 [Copy → Copy Xpath]를 선택하면 해당 지점의 Xpath가 복사됩니다. //*[@id=&quot;type_0&quot;]/div/ul[2]/li/span //*[@id=\"type_0\"]/div/ul[2]/li/span 위에서 구한 날짜의 Xpath를 이용해 해당 데이터를 크롤링하겠습니다. library(httr) library(rvest) library(stringr) url = &#39;https://finance.naver.com/sise/sise_deposit.nhn&#39; biz_day = GET(url) %&gt;% read_html(encoding = &#39;EUC-KR&#39;) %&gt;% html_nodes(xpath = &#39;//*[@id=&quot;type_1&quot;]/div/ul[2]/li/span&#39;) %&gt;% html_text() %&gt;% str_match((&#39;[0-9]+.[0-9]+.[0-9]+&#39;) ) %&gt;% str_replace_all(&#39;\\\\.&#39;, &#39;&#39;) print(biz_day) ## [1] &quot;20211103&quot; 페이지의 url을 저장합니다. GET() 함수를 통해 해당 페이지 내용을 받습니다. read_html() 함수를 이용해 해당 페이지의 HTML 내용을 읽어오며, 인코딩은 EUC-KR로 설정합니다. html_node() 함수 내에 위에서 구한 Xpath를 입력해서 해당 지점의 데이터를 추출합니다. html_text() 함수를 통해 텍스트 데이터만을 추출합니다. str_match() 함수 내에서 정규표현식11을 이용해 숫자.숫자.숫자 형식의 데이터를 추출합니다. str_replace_all() 함수를 이용해 마침표(.)를 모두 없애줍니다. 이처럼 Xpath를 이용하면 태그나 속성을 분해하지 않고도 원하는 지점의 데이터를 크롤링할 수 있습니다. 위 과정을 통해 yyyymmdd 형태의 날짜만 남게 되었습니다. 이를 위의 date와 schdate에 입력하면 산업별 현황과 개별종목 지표를 최근일자 기준으로 다운로드하게 됩니다. 전체 코드는 다음과 같습니다. library(httr) library(rvest) library(stringr) library(readr) # 최근 영업일 구하기 url = &#39;https://finance.naver.com/sise/sise_deposit.nhn&#39; biz_day = GET(url) %&gt;% read_html(encoding = &#39;EUC-KR&#39;) %&gt;% html_nodes(xpath = &#39;//*[@id=&quot;type_1&quot;]/div/ul[2]/li/span&#39;) %&gt;% html_text() %&gt;% str_match((&#39;[0-9]+.[0-9]+.[0-9]+&#39;) ) %&gt;% str_replace_all(&#39;\\\\.&#39;, &#39;&#39;) # 코스피 업종분류 OTP 발급 gen_otp_url = &#39;http://data.krx.co.kr/comm/fileDn/GenerateOTP/generate.cmd&#39; gen_otp_data = list( mktId = &#39;STK&#39;, trdDd = biz_day, # 최근영업일로 변경 money = &#39;1&#39;, csvxls_isNo = &#39;false&#39;, name = &#39;fileDown&#39;, url = &#39;dbms/MDC/STAT/standard/MDCSTAT03901&#39; ) otp = POST(gen_otp_url, query = gen_otp_data) %&gt;% read_html() %&gt;% html_text() # 코스피 업종분류 데이터 다운로드 down_url = &#39;http://data.krx.co.kr/comm/fileDn/download_csv/download.cmd&#39; down_sector_KS = POST(down_url, query = list(code = otp), add_headers(referer = gen_otp_url)) %&gt;% read_html(encoding = &#39;EUC-KR&#39;) %&gt;% html_text() %&gt;% read_csv() # 코스닥 업종분류 OTP 발급 gen_otp_data = list( mktId = &#39;KSQ&#39;, trdDd = biz_day, # 최근영업일로 변경 money = &#39;1&#39;, csvxls_isNo = &#39;false&#39;, name = &#39;fileDown&#39;, url = &#39;dbms/MDC/STAT/standard/MDCSTAT03901&#39; ) otp = POST(gen_otp_url, query = gen_otp_data) %&gt;% read_html() %&gt;% html_text() # 코스닥 업종분류 데이터 다운로드 down_sector_KQ = POST(down_url, query = list(code = otp), add_headers(referer = gen_otp_url)) %&gt;% read_html(encoding = &#39;EUC-KR&#39;) %&gt;% html_text() %&gt;% read_csv() down_sector = rbind(down_sector_KS, down_sector_KQ) ifelse(dir.exists(&#39;data&#39;), FALSE, dir.create(&#39;data&#39;)) write.csv(down_sector, &#39;data/krx_sector.csv&#39;) # 개별종목 지표 OTP 발급 gen_otp_url = &#39;http://data.krx.co.kr/comm/fileDn/GenerateOTP/generate.cmd&#39; gen_otp_data = list( searchType = &#39;1&#39;, mktId = &#39;ALL&#39;, trdDd = biz_day, # 최근영업일로 변경 csvxls_isNo = &#39;false&#39;, name = &#39;fileDown&#39;, url = &#39;dbms/MDC/STAT/standard/MDCSTAT03501&#39; ) otp = POST(gen_otp_url, query = gen_otp_data) %&gt;% read_html() %&gt;% html_text() # 개별종목 지표 데이터 다운로드 down_url = &#39;http://data.krx.co.kr/comm/fileDn/download_csv/download.cmd&#39; down_ind = POST(down_url, query = list(code = otp), add_headers(referer = gen_otp_url)) %&gt;% read_html(encoding = &#39;EUC-KR&#39;) %&gt;% html_text() %&gt;% read_csv() write.csv(down_ind, &#39;data/krx_ind.csv&#39;) 5.1.4 거래소 데이터 정리하기 위에서 다운로드한 데이터는 중복된 열이 있으며, 불필요한 데이터 역시 있습니다. 따라서 하나의 테이블로 합친 후 정리할 필요가 있습니다. 먼저 다운로드한 csv 파일을 읽어옵니다. down_sector = read.csv(&#39;data/krx_sector.csv&#39;, row.names = 1, stringsAsFactors = FALSE) down_ind = read.csv(&#39;data/krx_ind.csv&#39;, row.names = 1, stringsAsFactors = FALSE) read.csv() 함수를 이용해 csv 파일을 불러옵니다. row.names = 1을 통해 첫 번째 열을 행 이름으로 지정하고, stringsAsFactors = FALSE를 통해 문자열 데이터가 팩터 형태로 변형되지 않게 합니다. intersect(names(down_sector), names(down_ind)) ## [1] &quot;종목코드&quot; &quot;종목명&quot; &quot;종가&quot; &quot;대비&quot; &quot;등락률&quot; 먼저 intersect() 함수를 통해 두 데이터 간 중복되는 열 이름을 살펴보면 종목코드와 종목명 등이 동일한 위치에 있습니다. setdiff(down_sector[, &#39;종목명&#39;], down_ind[ ,&#39;종목명&#39;]) ## [1] &quot;ESR켄달스퀘어리츠&quot; &quot;NH프라임리츠&quot; &quot;SK리츠&quot; ## [4] &quot;디앤디플랫폼리츠&quot; &quot;롯데리츠&quot; &quot;맥쿼리인프라&quot; ## [7] &quot;맵스리얼티1&quot; &quot;모두투어리츠&quot; &quot;미래에셋맵스리츠&quot; ## [10] &quot;바다로19호&quot; &quot;베트남개발1&quot; &quot;신한알파리츠&quot; ## [13] &quot;에이리츠&quot; &quot;엘브이엠씨홀딩스&quot; &quot;이리츠코크렙&quot; ## [16] &quot;이지스레지던스리츠&quot; &quot;이지스밸류리츠&quot; &quot;제이알글로벌리츠&quot; ## [19] &quot;케이탑리츠&quot; &quot;코람코에너지리츠&quot; &quot;프레스티지바이오파마&quot; ## [22] &quot;하이골드12호&quot; &quot;하이골드3호&quot; &quot;한국ANKOR유전&quot; ## [25] &quot;한국패러랠&quot; &quot;현대두산인프라코어&quot; &quot;GRT&quot; ## [28] &quot;JTC&quot; &quot;SBI핀테크솔루션즈&quot; &quot;SNK&quot; ## [31] &quot;골든센츄리&quot; &quot;글로벌에스엠&quot; &quot;네오이뮨텍(Reg.S)&quot; ## [34] &quot;로스웰&quot; &quot;미투젠&quot; &quot;소마젠&quot; ## [37] &quot;씨케이에이치&quot; &quot;애머릿지&quot; &quot;엑세스바이오&quot; ## [40] &quot;오가닉티코스메틱&quot; &quot;윙입푸드&quot; &quot;이스트아시아홀딩스&quot; ## [43] &quot;잉글우드랩&quot; &quot;컬러레이&quot; &quot;코오롱티슈진&quot; ## [46] &quot;크리스탈신소재&quot; &quot;헝셩그룹&quot; setdiff() 함수를 통해 두 데이터에 공통적으로 없는 종목명, 즉 하나의 데이터에만 있는 종목을 살펴보면 위와 같습니다. 해당 종목들은 선박펀드, 광물펀드, 해외종목 등 일반적이지 않은 종목들이므로 제외하는 것이 좋습니다. 따라서 둘 사이에 공통적으로 존재하는 종목을 기준으로 데이터를 합쳐주겠습니다. KOR_ticker = merge(down_sector, down_ind, by = intersect(names(down_sector), names(down_ind)), all = FALSE ) merge() 함수는 by를 기준으로 두 데이터를 하나로 합치며, 공통으로 존재하는 종목코드, 종목명, 종가, 대비, 등락률을 기준으로 입력해줍니다. 또한 all 값을 TRUE로 설정하면 합집합을 반환하고, FALSE로 설정하면 교집합을 반환합니다. 공통으로 존재하는 항목을 원하므로 여기서는 FALSE를 입력합니다. KOR_ticker = KOR_ticker[order(-KOR_ticker[&#39;시가총액&#39;]), ] print(head(KOR_ticker)) ## 종목코드 종목명 종가 대비 등락률 시장구분 업종명 시가총액 ## 326 005930 삼성전자 70400 -1100 -1.54 KOSPI 전기전자 4.203e+14 ## 45 000660 SK하이닉스 105500 -2000 -1.86 KOSPI 전기전자 7.680e+13 ## 837 035420 NAVER 402500 -7500 -1.83 KOSPI 서비스업 6.612e+13 ## 1920 207940 삼성바이오로직스 874000 0 0.00 KOSPI 의약품 5.783e+13 ## 843 035720 카카오 124500 -3500 -2.73 KOSPI 서비스업 5.545e+13 ## 1062 051910 LG화학 784000 -47000 -5.66 KOSPI 화학 5.534e+13 ## EPS PER BPS PBR 주당배당금 배당수익률 ## 326 3841 18.33 39406 1.79 2994 4.25 ## 45 6952 15.18 71275 1.48 1170 1.11 ## 837 6877 58.53 44850 8.97 402 0.10 ## 1920 3642 239.98 69505 12.57 0 0.00 ## 843 369 337.40 14286 8.71 30 0.02 ## 1062 6666 117.61 230440 3.40 10000 1.28 데이터를 시가총액 기준으로 내림차순 정렬할 필요도 있습니다. order() 함수를 통해 상대적인 순서를 구할 수 있습니다. R은 기본적으로 오름차순으로 순서를 구하므로 앞에 마이너스(-)를 붙여 내림차순 형태로 바꿉니다. 결과적으로 시가총액 기준 내림차 순으로 해당 데이터가 정렬됩니다. 마지막으로 스팩, 우선주 종목 역시 제외해야 합니다. library(stringr) KOR_ticker[grepl(&#39;스팩&#39;, KOR_ticker[, &#39;종목명&#39;]), &#39;종목명&#39;] ## [1] &quot;엔에이치스팩19호&quot; &quot;엔에이치스팩20호&quot; &quot;삼성스팩4호&quot; ## [4] &quot;IBKS제14호스팩&quot; &quot;삼성머스트스팩5호&quot; &quot;하나금융17호스팩&quot; ## [7] &quot;엔에이치스팩17호&quot; &quot;대신밸런스제9호스팩&quot; &quot;케이비제18호스팩&quot; ## [10] &quot;엔에이치스팩21호&quot; &quot;신한제8호스팩&quot; &quot;상상인이안1호스팩&quot; ## [13] &quot;유안타제5호스팩&quot; &quot;대신밸런스제8호스팩&quot; &quot;케이비제20호스팩&quot; ## [16] &quot;유안타제8호스팩&quot; &quot;미래에셋대우스팩3호&quot; &quot;하나금융19호스팩&quot; ## [19] &quot;DB금융스팩8호&quot; &quot;한화플러스제1호스팩&quot; &quot;대신밸런스제7호스팩&quot; ## [22] &quot;한화플러스제2호스팩&quot; &quot;SK6호스팩&quot; &quot;유안타제7호스팩&quot; ## [25] &quot;한국9호스팩&quot; &quot;대신밸런스제10호스팩&quot; &quot;엔에이치스팩18호&quot; ## [28] &quot;하이제6호스팩&quot; &quot;교보10호스팩&quot; &quot;케이비17호스팩&quot; ## [31] &quot;한국제8호스팩&quot; &quot;IBKS제13호스팩&quot; &quot;유진스팩7호&quot; ## [34] &quot;에이치엠씨제5호스팩&quot; &quot;하이제5호스팩&quot; &quot;신한제6호스팩&quot; ## [37] &quot;미래에셋대우스팩 5호&quot; &quot;DB금융스팩9호&quot; &quot;하나금융15호스팩&quot; ## [40] &quot;신한제7호스팩&quot; &quot;한화에스비아이스팩&quot; &quot;하나머스트7호스팩&quot; ## [43] &quot;하나금융14호스팩&quot; &quot;유안타제4호스팩&quot; &quot;SK5호스팩&quot; ## [46] &quot;신영스팩6호&quot; &quot;에이치엠씨제4호스팩&quot; &quot;케이비제19호스팩&quot; ## [49] &quot;하나금융16호스팩&quot; &quot;IBKS제15호스팩&quot; &quot;교보9호스팩&quot; ## [52] &quot;상상인이안제2호스팩&quot; &quot;이베스트스팩5호&quot; &quot;IBKS제16호스팩&quot; ## [55] &quot;신영스팩5호&quot; &quot;IBKS제12호스팩&quot; &quot;유진스팩6호&quot; ## [58] &quot;이베스트이안스팩1호&quot; KOR_ticker[str_sub(KOR_ticker[, &#39;종목코드&#39;], -1, -1) != 0, &#39;종목명&#39;] ## [1] &quot;삼성전자우&quot; &quot;현대차2우B&quot; &quot;LG화학우&quot; ## [4] &quot;현대차우&quot; &quot;LG생활건강우&quot; &quot;LG전자우&quot; ## [7] &quot;아모레퍼시픽우&quot; &quot;미래에셋증권2우B&quot; &quot;삼성SDI우&quot; ## [10] &quot;삼성화재우&quot; &quot;대신증권우&quot; &quot;신영증권우&quot; ## [13] &quot;한국금융지주우&quot; &quot;한화3우B&quot; &quot;CJ4우(전환)&quot; ## [16] &quot;금호석유우&quot; &quot;두산우&quot; &quot;삼성전기우&quot; ## [19] &quot;아모레G3우(전환)&quot; &quot;CJ제일제당 우&quot; &quot;S-Oil우&quot; ## [22] &quot;NH투자증권우&quot; &quot;현대차3우B&quot; &quot;두산퓨얼셀1우&quot; ## [25] &quot;LG우&quot; &quot;SK이노베이션우&quot; &quot;대신증권2우B&quot; ## [28] &quot;삼성물산우B&quot; &quot;DL이앤씨우&quot; &quot;SK케미칼우&quot; ## [31] &quot;솔루스첨단소재1우&quot; &quot;신풍제약우&quot; &quot;CJ우&quot; ## [34] &quot;SK우&quot; &quot;아모레G우&quot; &quot;두산2우B&quot; ## [37] &quot;코오롱인더우&quot; &quot;미래에셋증권우&quot; &quot;한화투자증권우&quot; ## [40] &quot;부국증권우&quot; &quot;유한양행우&quot; &quot;DL우&quot; ## [43] &quot;GS우&quot; &quot;호텔신라우&quot; &quot;대교우B&quot; ## [46] &quot;두산퓨얼셀2우B&quot; &quot;유안타증권우&quot; &quot;녹십자홀딩스2우&quot; ## [49] &quot;롯데칠성우&quot; &quot;SK디스커버리우&quot; &quot;롯데지주우&quot; ## [52] &quot;솔루스첨단소재2우B&quot; &quot;유화증권우&quot; &quot;한화솔루션우&quot; ## [55] &quot;대한항공우&quot; &quot;덕성우&quot; &quot;BYC우&quot; ## [58] &quot;남양유업우&quot; &quot;LX하우시스우&quot; &quot;티와이홀딩스우&quot; ## [61] &quot;삼성중공우&quot; &quot;대덕전자1우&quot; &quot;세방우&quot; ## [64] &quot;대상우&quot; &quot;하이트진로2우B&quot; &quot;유유제약1우&quot; ## [67] &quot;대한제당우&quot; &quot;코오롱우&quot; &quot;넥센타이어1우B&quot; ## [70] &quot;삼양홀딩스우&quot; &quot;코리아써우&quot; &quot;LX홀딩스1우&quot; ## [73] &quot;한진칼우&quot; &quot;한화우&quot; &quot;태영건설우&quot; ## [76] &quot;NPC우&quot; &quot;삼양사우&quot; &quot;SK증권우&quot; ## [79] &quot;일양약품우&quot; &quot;대덕1우&quot; &quot;넥센우&quot; ## [82] &quot;크라운제과우&quot; &quot;성신양회우&quot; &quot;노루페인트우&quot; ## [85] &quot;DB하이텍1우&quot; &quot;한양증권우&quot; &quot;현대건설우&quot; ## [88] &quot;대상홀딩스우&quot; &quot;코오롱글로벌우&quot; &quot;계양전기우&quot; ## [91] &quot;태양금속우&quot; &quot;SK네트웍스우&quot; &quot;서울식품우&quot; ## [94] &quot;금호건설우&quot; &quot;노루홀딩스우&quot; &quot;동부건설우&quot; ## [97] &quot;대원전선우&quot; &quot;동원시스템즈우&quot; &quot;깨끗한나라우&quot; ## [100] &quot;현대비앤지스틸우&quot; &quot;루트로닉3우C&quot; &quot;크라운해태홀딩스우&quot; ## [103] &quot;하이트진로홀딩스우&quot; &quot;CJ씨푸드1우&quot; &quot;금강공업우&quot; ## [106] &quot;남선알미우&quot; &quot;유유제약2우B&quot; &quot;코리아써키트2우B&quot; ## [109] &quot;흥국화재우&quot; &quot;대호특수강우&quot; &quot;JW중외제약우&quot; ## [112] &quot;성문전자우&quot; &quot;JW중외제약2우B&quot; &quot;KG동부제철우&quot; ## [115] &quot;진흥기업우B&quot; &quot;동양우&quot; &quot;동양2우B&quot; ## [118] &quot;소프트센우&quot; &quot;신원우&quot; &quot;흥국화재2우B&quot; ## [121] &quot;진흥기업2우B&quot; &quot;동양3우B&quot; grepl() 함수를 통해 종목명에 ‘스팩’이 들어가는 종목을 찾고, stringr 패키지의 str_sub() 함수를 통해 종목코드 끝이 0이 아닌 우선주 종목을 찾을 수 있습니다. KOR_ticker = KOR_ticker[!grepl(&#39;스팩&#39;, KOR_ticker[, &#39;종목명&#39;]), ] KOR_ticker = KOR_ticker[str_sub(KOR_ticker[, &#39;종목코드&#39;], -1, -1) == 0, ] 마지막으로 행 이름을 초기화한 후 정리된 데이터를 csv 파일로 저장합니다. rownames(KOR_ticker) = NULL write.csv(KOR_ticker, &#39;data/KOR_ticker.csv&#39;) 5.2 WICS 기준 섹터정보 크롤링 일반적으로 주식의 섹터를 나누는 기준은 MSCI와 S&amp;P가 개발한 GICS12를 가장 많이 사용합니다. 국내 종목의 GICS 기준 정보 역시 한국거래소에서 제공하고 있으나, 이는 독점적 지적재산으로 명시했기에 사용하는 데 무리가 있습니다. 그러나 지수제공업체인 와이즈인덱스13에서는 GICS와 비슷한 WICS 산업분류를 발표하고 있습니다. WICS를 크롤링해 필요한 정보를 수집해보겠습니다. 먼저 웹페이지에 접속해 [Index → WISE SECTOR INDEX → WICS → 에너지]를 클릭합니다. 그 후 [Components] 탭을 클릭하면 해당 섹터의 구성종목을 확인할 수 있습니다. 그림 5.6: WICS 기준 구성종목 개발자도구 화면(그림 5.7)을 통해 해당 페이지의 데이터전송 과정을 살펴보도록 하겠습니다. 그림 5.7: WICS 페이지 개발자도구 화면 일자를 선택하면 [Network] 탭의 GetIndexComponets 항목을 통해 데이터 전송 과정이 나타납니다. Request URL의 주소를 살펴보면 다음과 같습니다. http://www.wiseindex.com/Index/GetIndexComponets: 데이터를 요청하는 url 입니다. ceil_yn = 0: 실링 여부를 나타내며, 0은 비실링을 의미합니다. dt=20190607: 조회일자를 나타냅니다. sec_cd=G10: 섹터 코드를 나타냅니다. 이번엔 위 주소의 페이지를 열어보겠습니다. 그림 5.8: WICS 데이터 페이지 글자들은 페이지에 출력된 내용이지만 매우 특이한 형태로 구성되어 있는데 이것은 JSON 형식의 데이터입니다. 기존에 우리가 살펴보았던 대부분의 웹페이지는 XML 형식으로 표현되어 있습니다. XML 형식은 문법이 복잡하고 표현 규칙이 엄격해 데이터의 용량이 커지는 단점이 있습니다. 반면 JSON 형식은 문법이 단순하고 데이터의 용량이 작아 빠른 속도로 데이터를 교환할 수 있습니다. R에서는 jsonlite 패키지의 fromJSON() 함수를 사용해 매우 손쉽게 JSON 형식의 데이터를 크롤링할 수 있습니다. library(jsonlite) url = &#39;http://www.wiseindex.com/Index/GetIndexComponets?ceil_yn=0&amp;dt=20190607&amp;sec_cd=G10&#39; data = fromJSON(url) lapply(data, head) ## $info ## $info$TRD_DT ## [1] &quot;/Date(1559833200000)/&quot; ## ## $info$MKT_VAL ## [1] 19850082 ## ## $info$TRD_AMT ## [1] 70030 ## ## $info$CNT ## [1] 23 ## ## ## $list ## IDX_CD IDX_NM_KOR ALL_MKT_VAL CMP_CD CMP_KOR MKT_VAL WGT S_WGT ## 1 G10 WICS 에너지 19850082 096770 SK이노베이션 9052841 45.61 45.61 ## 2 G10 WICS 에너지 19850082 010950 S-Oil 3403265 17.14 62.75 ## 3 G10 WICS 에너지 19850082 267250 현대중공업지주 2873204 14.47 77.23 ## 4 G10 WICS 에너지 19850082 078930 GS 2491805 12.55 89.78 ## 5 G10 WICS 에너지 19850082 067630 에이치엘비생명과학 624986 3.15 92.93 ## 6 G10 WICS 에너지 19850082 006120 SK디스커버리 257059 1.30 94.22 ## CAL_WGT SEC_CD SEC_NM_KOR SEQ TOP60 APT_SHR_CNT ## 1 1 G10 에너지 1 2 56403994 ## 2 1 G10 에너지 2 2 41655633 ## 3 1 G10 에너지 3 2 9283372 ## 4 1 G10 에너지 4 2 49245150 ## 5 1 G10 에너지 5 2 39307272 ## 6 1 G10 에너지 6 2 10470820 ## ## $sector ## SEC_CD SEC_NM_KOR SEC_RATE IDX_RATE ## 1 G25 경기관련소비재 16.05 0 ## 2 G35 건강관리 9.27 0 ## 3 G50 커뮤니케이션서비스 2.26 0 ## 4 G40 금융 10.31 0 ## 5 G10 에너지 2.37 100 ## 6 G20 산업재 12.68 0 ## ## $size ## SEC_CD SEC_NM_KOR SEC_RATE IDX_RATE ## 1 WMI510 WMI500 대형주 69.40 89.78 ## 2 WMI520 WMI500 중형주 13.56 4.44 ## 3 WMI530 WMI500 소형주 17.04 5.78 $list 항목에는 해당 섹터의 구성종목 정보가 있으며, $sector 항목을 통해 다른 섹터의 코드도 확인할 수 있습니다. for loop 구문을 이용해 URL의 sec_cd=에 해당하는 부분만 변경하면 모든 섹터의 구성종목을 매우 쉽게 얻을 수 있습니다. sector_code = c(&#39;G25&#39;, &#39;G35&#39;, &#39;G50&#39;, &#39;G40&#39;, &#39;G10&#39;, &#39;G20&#39;, &#39;G55&#39;, &#39;G30&#39;, &#39;G15&#39;, &#39;G45&#39;) data_sector = list() for (i in sector_code) { url = paste0( &#39;http://www.wiseindex.com/Index/GetIndexComponets&#39;, &#39;?ceil_yn=0&amp;dt=&#39;,biz_day,&#39;&amp;sec_cd=&#39;,i) data = fromJSON(url) data = data$list data_sector[[i]] = data Sys.sleep(1) } data_sector = do.call(rbind, data_sector) 해당 데이터를 csv 파일로 저장해주도록 합니다. write.csv(data_sector, &#39;data/KOR_sector.csv&#39;) 특정한 규칙을 가진 문자열의 집합을 표현하는데 사용하는 형식 언어↩︎ https://en.wikipedia.org/wiki/Global_Industry_Classification_Standard↩︎ http://www.wiseindex.com/↩︎ "],["금융-데이터-수집하기-심화.html", "Chapter 6 금융 데이터 수집하기 (심화) 6.1 수정주가 크롤링 6.2 재무제표 및 가치지표 크롤링 6.3 DART의 Open API를 이용한 데이터 수집하기", " Chapter 6 금융 데이터 수집하기 (심화) 지난 CHAPTER에서 수집한 주식티커를 바탕으로 이번 CHAPTER에서는 퀀트 투자의 핵심 자료인 수정주가, 재무제표, 가치지표를 크롤링하는 방법을 알아보겠습니다. 6.1 수정주가 크롤링 주가 데이터는 투자를 함에 있어 반드시 필요한 데이터이며, 인터넷에서 주가를 수집할 수 있는 방법은 매우 많습니다. 먼저 API를 이용한 데이터 수집에서 살펴본 것과 같이, getSymbols() 함수를 이용해 데이터를 받을 수 있습니다. 그러나 야후 파이낸스에서 제공하는 데이터 중 미국 주가는 이상 없이 다운로드되지만, 국내 중소형주는 주가가 없는 경우가 있습니다. 또한 단순 주가를 구할 수 있는 방법은 많지만, 투자에 필요한 수정주가를 구할 수 있는 방법은 찾기 힘듭니다. 다행히 네이버 금융에서 제공하는 정보를 통해 모든 종목의 수정주가를 매우 손쉽게 구할 수 있습니다. 6.1.1 개별종목 주가 크롤링 먼저 네이버 금융에서 특정종목(예: 삼성전자)의 [차트] 탭14을 선택합니다. 해당 차트는 주가 데이터를 받아 그래프를 그려주는 형태입니다. 따라서 해당 데이터가 어디에서 오는지 알기 위해 개발자 도구 화면을 이용합니다. 그림 6.1: 네이버금융 차트의 통신기록 화면을 연 상태에서 [일] 탭을 선택하면 나오는 항목 중 가장 상단 항목의 Request URL이 주가 데이터를 요청하는 주소입니다. 해당 URL에 접속해보겠습니다. URL: https://fchart.stock.naver.com/siseJson.nhn?symbol=005930&amp;requestType=1&amp;startTime=20191117&amp;endTime=20210124&amp;timeframe=day 그림 6.2: 주가 데이터 페이지 각 날짜별로 시가, 고가, 저가, 종가, 거래량, 외국인소지율이 있으며, 주가는 모두 수정주가 기준입니다. URL에서 symbol= 뒤에 6자리 티커만 변경하면 해당 종목의 주가 데이터가 있는 페이지로 이동할 수 있으며, 이를 통해 우리가 원하는 모든 종목의 주가 데이터를 크롤링할 수 있습니다. 또한 startTime= 에는 시작일자를, endTime= 에는 종료일자를 입력하여 원하는 기간 만큼의 데이터를 받을 수도 있습니다. library(stringr) KOR_ticker = read.csv(&#39;data/KOR_ticker.csv&#39;, row.names = 1) print(KOR_ticker$&#39;종목코드&#39;[1]) ## [1] 5930 KOR_ticker$&#39;종목코드&#39; = str_pad(KOR_ticker$&#39;종목코드&#39;, 6, side = c(&#39;left&#39;), pad = &#39;0&#39;) 먼저 저장해두었던 티커 항목의 csv 파일을 불러옵니다. 종목코드를 살펴보면 005930이어야 할 삼성전자의 티커가 5930으로 입력되어 있습니다. 이는 파일을 불러오는 과정에서 0으로 시작하는 숫자들이 지워졌기 때문입니다. stringr 패키지의 str_pad() 함수를 사용해 6자리가 되지 않는 문자는 왼쪽에 0을 추가해 강제로 6자리로 만들어주도록 합니다. 다음은 첫 번째 종목인 삼성전자의 주가를 크롤링한 후 가공하는 방법입니다. library(xts) ifelse(dir.exists(&#39;data/KOR_price&#39;), FALSE, dir.create(&#39;data/KOR_price&#39;)) ## [1] FALSE i = 1 name = KOR_ticker$&#39;종목코드&#39;[i] price = xts(NA, order.by = Sys.Date()) print(price) ## [,1] ## 2021-11-05 NA data 폴더 내에 KOR_price 폴더를 생성합니다. i = 1을 입력합니다. 향후 for loop 구문을 통해 i 값만 변경하면 모든 종목의 주가를 다운로드할 수 있습니다. name에 해당 티커를 입력합니다. xts() 함수를 이용해 빈 시계열 데이터를 생성하며, 인덱스는 Sys.Date()를 통해 현재 날짜를 입력합니다. library(httr) library(rvest) library(lubridate) library(stringr) library(readr) from = (Sys.Date() - years(3)) %&gt;% str_remove_all(&#39;-&#39;) to = Sys.Date() %&gt;% str_remove_all(&#39;-&#39;) url = paste0(&#39;https://fchart.stock.naver.com/siseJson.nhn?symbol=&#39;, name, &#39;&amp;requestType=1&amp;startTime=&#39;, from, &#39;&amp;endTime=&#39;, to, &#39;&amp;timeframe=day&#39;) data = GET(url) data_html = data %&gt;% read_html %&gt;% html_text() %&gt;% read_csv() print(data_html) ## # A tibble: 743 x 8 ## `[[&#39;날짜&#39;` `&#39;시가&#39;` `&#39;고가&#39;` `&#39;저가&#39;` `&#39;종가&#39;` `&#39;거래량&#39;` `&#39;외국인소진율&#39;~ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 &quot;[\\&quot;20181105\\&quot;&quot; 43750 43800 42900 43800 9426777 52.32] ## 2 &quot;[\\&quot;20181106\\&quot;&quot; 43750 43800 42950 43750 7713625 52.32] ## 3 &quot;[\\&quot;20181107\\&quot;&quot; 43600 44500 43400 44000 11553998 52.33] ## 4 &quot;[\\&quot;20181108\\&quot;&quot; 44900 45050 44050 44050 12617397 52.35] ## 5 &quot;[\\&quot;20181109\\&quot;&quot; 44450 44850 43900 44300 7318500 52.37] ## 6 &quot;[\\&quot;20181112\\&quot;&quot; 43850 45250 43700 45200 8552566 52.4] ## 7 &quot;[\\&quot;20181113\\&quot;&quot; 43900 44500 43400 44500 9311126 52.35] ## 8 &quot;[\\&quot;20181114\\&quot;&quot; 44500 44500 43800 44100 6783344 52.33] ## 9 &quot;[\\&quot;20181115\\&quot;&quot; 44050 44350 43500 44250 5864067 52.32] ## 10 &quot;[\\&quot;20181116\\&quot;&quot; 44600 44750 43700 44000 7777124 52.32] ## # ... with 733 more rows, and 1 more variable: ...8 &lt;lgl&gt; 먼저 시작일(from)과 종료일(to)에 해당하는 날짜를 입력합니다. Sys.Date()를 통해 오늘 날짜를 불러온 후, 시작일은 years() 함수를 이용해 3년을 빼줍니다. (본인이 원하는 기간 만큼을 빼주면 됩니다.) 그 후 str_remove_all() 함수를 이용해 - 부분을 제거해 yyyymmdd 형식을 만들어 줍니다. paste0() 함수를 이용해 원하는 종목의 url을 생성합니다. url 중 티커에 해당하는 6자리 부분에 위에서 입력한 name을 설정합니다. GET() 함수를 통해 페이지의 데이터를 불러옵니다. read_html() 함수를 통해 HTML 정보를 읽어옵니다. html_text() 함수를 통해 텍스트 데이터만을 추출합니다. read_csv() 함수로 csv 형태의 데이터를 불러옵니다. 결과적으로 날짜 및 주가, 거래량, 외국인소진율 데이터가 추출됩니다. 우리에게 필요한 날짜와 종가에 해당하는 열만 선택하고, 클렌징 작업을 해주도록 하겠습니다. library(timetk) price = data_html[c(1, 5)] colnames(price) = (c(&#39;Date&#39;, &#39;Price&#39;)) price = na.omit(price) price$Date = parse_number(price$Date) price$Date = ymd(price$Date) price = tk_xts(price, date_var = Date) print(tail(price)) ## Price ## 2021-10-29 69800 ## 2021-11-01 69900 ## 2021-11-02 71500 ## 2021-11-03 70400 ## 2021-11-04 70600 ## 2021-11-05 70200 날짜에 해당하는 첫 번째 열과, 종가에 해당하는 다섯 번째 열만 선택해 저장합니다. 열 이름을 Date와 Price로 변경합니다. na.omit() 함수를 통해 NA 데이터를 삭제해줍니다. Date 열에서 숫자만을 추출하기 위해 readr 패키지의 parse_number() 함수를 적용합니다. 해당 함수는 문자형 데이터에서 콤마와 같은 불필요한 문자를 제거한 후 숫자형 데이터로 변경해줍니다. lubridate 패키지의 ymd() 함수를 이용하면 yyyymmdd 형태가 yyyy-mm-dd로 변경되며 데이터 형태 또한 Date 타입으로 변경됩니다. timetk 패키지의 tk_xts() 함수를 이용해 시계열 형태로 변경하며, 인덱스는 Date 열을 설정합니다. 형태를 변경한 후 해당 열은 자동으로 삭제됩니다. 데이터를 확인해보면 우리에게 필요한 형태로 정리되었습니다. write.csv(data.frame(price), paste0(&#39;data/KOR_price/&#39;, name, &#39;_price.csv&#39;)) 마지막으로 해당 데이터를 data 폴더의 KOR_price 폴더 내에 티커_price.csv 이름으로 저장합니다. 6.1.2 전 종목 주가 크롤링 위의 코드에서 for loop 구문을 이용해 i 값만 변경해주면 모든 종목의 주가를 다운로드할 수 있습니다. 전 종목 주가를 다운로드하는 전체 코드는 다음과 같습니다. library(httr) library(rvest) library(stringr) library(xts) library(lubridate) library(readr) library(timetk) KOR_ticker = read.csv(&#39;data/KOR_ticker.csv&#39;, row.names = 1) print(KOR_ticker$&#39;종목코드&#39;[1]) KOR_ticker$&#39;종목코드&#39; = str_pad(KOR_ticker$&#39;종목코드&#39;, 6, side = c(&#39;left&#39;), pad = &#39;0&#39;) ifelse(dir.exists(&#39;data/KOR_price&#39;), FALSE, dir.create(&#39;data/KOR_price&#39;)) for(i in 1 : nrow(KOR_ticker) ) { price = xts(NA, order.by = Sys.Date()) # 빈 시계열 데이터 생성 name = KOR_ticker$&#39;종목코드&#39;[i] # 티커 부분 선택 from = (Sys.Date() - years(3)) %&gt;% str_remove_all(&#39;-&#39;) # 시작일 to = Sys.Date() %&gt;% str_remove_all(&#39;-&#39;) # 종료일 # 오류 발생 시 이를 무시하고 다음 루프로 진행 tryCatch({ # url 생성 url = paste0(&#39;https://fchart.stock.naver.com/siseJson.nhn?symbol=&#39;, name, &#39;&amp;requestType=1&amp;startTime=&#39;, from, &#39;&amp;endTime=&#39;, to, &#39;&amp;timeframe=day&#39;) # 이 후 과정은 위와 동일함 # 데이터 다운로드 data = GET(url) data_html = data %&gt;% read_html %&gt;% html_text() %&gt;% read_csv() # 필요한 열만 선택 후 클렌징 price = data_html[c(1, 5)] colnames(price) = (c(&#39;Date&#39;, &#39;Price&#39;)) price = na.omit(price) price$Date = parse_number(price$Date) price$Date = ymd(price$Date) price = tk_xts(price, date_var = Date) }, error = function(e) { # 오류 발생시 해당 종목명을 출력하고 다음 루프로 이동 warning(paste0(&quot;Error in Ticker: &quot;, name)) }) # 다운로드 받은 파일을 생성한 폴더 내 csv 파일로 저장 write.csv(data.frame(price), paste0(&#39;data/KOR_price/&#39;, name, &#39;_price.csv&#39;)) # 타임슬립 적용 Sys.sleep(2) } 위 코드에서 추가된 점은 다음과 같습니다. 페이지 오류, 통신 오류 등 오류가 발생할 경우 for loop 구문은 멈춰버리는데 전체 데이터를 처음부터 다시 받는 일은 매우 귀찮은 작업입니다. 따라서 tryCatch() 함수를 이용해 오류가 발생할 때 해당 티커를 출력한 후 다음 루프로 넘어가게 합니다. 또한 오류가 발생하면 xts() 함수를 통해 만들어둔 빈 데이터를 저장하게 됩니다. 마지막으로 무한 크롤링을 방지하기 위해 한 번의 루프가 끝날 때마다 2초의 타임슬립을 적용했습니다. 위 코드가 모두 돌아가는 데는 수 시간이 걸립니다. 작업이 끝난 후 data/KOR_price 폴더를 확인해보면 전 종목 주가가 csv 형태로 저장되어 있습니다. 6.2 재무제표 및 가치지표 크롤링 주가와 더불어 재무제표와 가치지표 역시 투자에 있어 핵심이 되는 데이터입니다. 해당 데이터 역시 여러 웹사이트에서 구할 수 있지만, 국내 데이터 제공업체인 FnGuide에서 운영하는 Company Guide 웹사이트15에서 손쉽게 구할 수 있습니다. 6.2.1 재무제표 다운로드 먼저 개별종목의 재무제표를 탭을 선택하면 포괄손익계산서, 재무상태표, 현금흐름표 항목이 보이게 되며, 티커에 해당하는 A005930 뒤의 주소는 불필요한 내용이므로, 이를 제거한 주소로 접속합니다. A 뒤의 6자리 티커만 변경한다면 해당 종목의 재무제표 페이지로 이동하게 됩니다. http://comp.fnguide.com/SVO2/ASP/SVD_Finance.asp?pGB=1&amp;gicode=A005930 우리가 원하는 재무제표 항목들은 모두 테이블 형태로 제공되고 있으므로 html_table() 함수를 이용해 추출할 수 있습니다. library(httr) library(rvest) ifelse(dir.exists(&#39;data/KOR_fs&#39;), FALSE, dir.create(&#39;data/KOR_fs&#39;)) Sys.setlocale(&quot;LC_ALL&quot;, &quot;English&quot;) url = paste0(&#39;http://comp.fnguide.com/SVO2/ASP/SVD_Finance.asp?pGB=1&amp;gicode=A005930&#39;) data = GET(url, user_agent(&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36&#39;)) data = data %&gt;% read_html() %&gt;% html_table() Sys.setlocale(&quot;LC_ALL&quot;, &quot;Korean&quot;) lapply(data, function(x) { head(x, 3)}) ## [[1]] ## # A tibble: 3 x 7 ## `IFRS(연결)` `2018/12` `2019/12` `2020/12` `2021/06` 전년동기 `전년동기(%)` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 매출액 2,437,714 2,304,009 2,368,070 1,290,601 1,082,913 19.2 ## 2 매출원가 1,323,944 1,472,395 1,444,883 785,659 667,129 17.8 ## 3 매출총이익 1,113,770 831,613 923,187 504,942 415,784 21.4 ## ## [[2]] ## # A tibble: 3 x 7 ## `IFRS(연결)` `2020/09` `2020/12` `2021/03` `2021/06` 전년동기 `전년동기(%)` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 매출액 669,642 615,515 653,885 636,716 529,661 20.2 ## 2 매출원가 399,705 378,049 415,000 370,659 319,062 16.2 ## 3 매출총이익 269,937 237,466 238,885 266,057 210,599 26.3 ## ## [[3]] ## # A tibble: 3 x 5 ## `IFRS(연결)` `2018/12` `2019/12` `2020/12` `2021/06` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 자산 3,393,572 3,525,645 3,782,357 3,847,777 ## 2 유동자산계산에 참여한 계정 펼치기 1,746,974 1,813,853 1,982,156 1,911,185 ## 3 재고자산 289,847 267,665 320,431 335,924 ## ## [[4]] ## # A tibble: 3 x 5 ## `IFRS(연결)` `2020/09` `2020/12` `2021/03` `2021/06` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 자산 3,757,887 3,782,357 3,928,263 3,847,777 ## 2 유동자산계산에 참여한 계정 펼치기 2,036,349 1,982,156 2,091,554 1,911,185 ## 3 재고자산 324,429 320,431 306,200 335,924 ## ## [[5]] ## # A tibble: 3 x 5 ## `IFRS(연결)` `2018/12` `2019/12` `2020/12` `2021/06` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 영업활동으로인한현금흐름 &quot;670,319&quot; &quot;453,829&quot; &quot;652,870&quot; &quot;258,895&quot; ## 2 당기순손익 &quot;443,449&quot; &quot;217,389&quot; &quot;264,078&quot; &quot;167,762&quot; ## 3 법인세비용차감전계속사업이익 &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ## ## [[6]] ## # A tibble: 3 x 5 ## `IFRS(연결)` `2020/09` `2020/12` `2021/03` `2021/06` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 영업활동으로인한현금흐름 &quot;141,444&quot; &quot;245,146&quot; &quot;138,031&quot; &quot;120,865&quot; ## 2 당기순손익 &quot;93,607&quot; &quot;66,071&quot; &quot;71,417&quot; &quot;96,345&quot; ## 3 법인세비용차감전계속사업이익 &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; data 폴더 내에 KOR_fs 폴더를 생성합니다. Sys.setlocale() 함수를 통해 로케일 언어를 English로 설정합니다. url을 입력한 후 GET() 함수를 통해 페이지 내용을 받아오며, user_agent() 항목에 웹브라우저 구별을 입력해줍니다. 해당 사이트는 크롤러와 같이 정체가 불분명한 웹브라우저를 통한 접속이 막혀 있어, 마치 모질라 혹은 크롬을 통해 접속한 것 처럼 데이터를 요청합니다. 다양한 웹브라우저 리스트는 아래 링크에 나와있습니다. http://www.useragentstring.com/pages/useragentstring.php read_html() 함수를 통해 HTML 내용을 읽어오며, html_table() 함수를 통해 테이블 내용만 추출합니다. 로케일 언어를 다시 Korean으로 설정합니다. 위의 과정을 거치면 data 변수에는 리스트 형태로 총 6개의 테이블이 들어오게 되며, 그 내용은 표 6.1와 같습니다. 표 6.1: 재무제표 테이블 내역 순서 내용 1 포괄손익계산서 (연간) 2 포괄손익계산서 (분기) 3 재무상태표 (연간) 4 재무상태표 (분기) 5 현금흐름표 (연간) 6 현금흐름표 (분기) 이 중 연간 기준 재무제표에 해당하는 첫 번째, 세 번째, 다섯 번째 테이블을 선택합니다. data_IS = data[[1]] data_BS = data[[3]] data_CF = data[[5]] print(names(data_IS)) ## [1] &quot;IFRS(연결)&quot; &quot;2018/12&quot; &quot;2019/12&quot; &quot;2020/12&quot; &quot;2021/06&quot; ## [6] &quot;전년동기&quot; &quot;전년동기(%)&quot; data_IS = data_IS[, 1:(ncol(data_IS)-2)] 포괄손익계산서 테이블(data_IS)에는 전년동기, 전년동기(%) 열이 있는데 통일성을 위해 해당 열을 삭제합니다. 이제 테이블을 묶은 후 클렌징하겠습니다. data_fs = rbind(data_IS, data_BS, data_CF) %&gt;% data.frame() data_fs[, 1] = gsub(&#39;계산에 참여한 계정 펼치기&#39;, &#39;&#39;, data_fs[, 1]) data_fs = data_fs[!duplicated(data_fs[, 1]), ] rownames(data_fs) = NULL rownames(data_fs) = data_fs[, 1] data_fs[, 1] = NULL data_fs = data_fs[, substr(colnames(data_fs), 7, 8) == &#39;12&#39;] rbind() 함수를 이용해 세 테이블을 행으로 묶은 후 데이터프레임 형태로 변경하여, data_fs에 저장합니다. 첫 번째 열인 계정명에는 ‘계산에 참여한 계정 펼치기’라는 글자가 들어간 항목이 있습니다. 이는 페이지 내에서 펼치기 역할을 하는 (+) 항목에 해당하며 gsub() 함수를 이용해 해당 글자를 삭제합니다. 중복되는 계정명이 다수 있는데 대부분 불필요한 항목입니다. !duplicated() 함수를 사용해 중복되지 않는 계정명만 선택합니다. 행 이름을 초기화한 후 첫 번째 열의 계정명을 행 이름으로 변경합니다. 그 후 첫 번째 열은 삭제합니다. 간혹 12월 결산법인이 아닌 종목이거나 연간 재무제표임에도 불구하고 분기 재무제표가 들어간 경우가 있습니다. 비교의 통일성을 위해 substr() 함수를 이용해 끝 글자가 12인 열, 즉 12월 결산 데이터만 선택합니다. print(head(data_fs)) ## X2018.12 X2019.12 X2020.12 ## 매출액 2,437,714 2,304,009 2,368,070 ## 매출원가 1,323,944 1,472,395 1,444,883 ## 매출총이익 1,113,770 831,613 923,187 ## 판매비와관리비 524,903 553,928 563,248 ## 인건비 64,514 64,226 70,429 ## 유무형자산상각비 14,477 20,408 20,857 sapply(data_fs, typeof) ## X2018.12 X2019.12 X2020.12 ## &quot;character&quot; &quot;character&quot; &quot;character&quot; 데이터를 확인해보면 연간 기준 재무제표가 정리되었습니다. 문자형 데이터이므로 숫자형으로 변경합니다. library(stringr) data_fs = sapply(data_fs, function(x) { str_replace_all(x, &#39;,&#39;, &#39;&#39;) %&gt;% as.numeric() }) %&gt;% data.frame(., row.names = rownames(data_fs)) print(head(data_fs)) ## X2018.12 X2019.12 X2020.12 ## 매출액 2437714 2304009 2368070 ## 매출원가 1323944 1472395 1444883 ## 매출총이익 1113770 831613 923187 ## 판매비와관리비 524903 553928 563248 ## 인건비 64514 64226 70429 ## 유무형자산상각비 14477 20408 20857 sapply(data_fs, typeof) ## X2018.12 X2019.12 X2020.12 ## &quot;double&quot; &quot;double&quot; &quot;double&quot; sapply() 함수를 이용해 각 열에 stringr 패키지의 str_replace_all() 함수를 적용해 콤마(,)를 제거한 후 as.numeric() 함수를 통해 숫자형 데이터로 변경합니다. data.frame() 함수를 이용해 데이터 프레임 형태로 만들어주며, 행 이름은 기존 내용을 그대로 유지합니다. 정리된 데이터를 출력해보면 문자형이던 데이터가 숫자형으로 변경되었습니다. write.csv(data_fs, &#39;data/KOR_fs/005930_fs.csv&#39;) data 폴더의 KOR_fs 폴더 내에 티커_fs.csv 이름으로 저장합니다. 6.2.2 가치지표 계산하기 위에서 구한 재무제표 데이터를 이용해 가치지표를 계산할 수 있습니다. 흔히 사용되는 가치지표는 PER, PBR, PCR, PSR이며 분자는 주가, 분모는 재무제표 데이터가 사용됩니다. 표 6.2: 가치지표의 종류 순서 분모 PER Earnings (순이익) PBR Book Value (순자산) PCR Cashflow (영업활동현금흐름) PSR Sales (매출액) 위에서 구한 재무제표 항목에서 분모 부분에 해당하는 데이터만 선택해보겠습니다. ifelse(dir.exists(&#39;data/KOR_value&#39;), FALSE, dir.create(&#39;data/KOR_value&#39;)) ## [1] FALSE value_type = c(&#39;지배주주순이익&#39;, &#39;자본&#39;, &#39;영업활동으로인한현금흐름&#39;, &#39;매출액&#39;) value_index = data_fs[match(value_type, rownames(data_fs)), ncol(data_fs)] print(value_index) ## [1] 260908 2759480 652870 2368070 data 폴더 내에 KOR_value 폴더를 생성합니다. 분모에 해당하는 항목을 저장한 후 match() 함수를 이용해 해당 항목이 위치하는 지점을 찾습니다. ncol() 함수를 이용해 맨 오른쪽, 즉 최근년도 재무제표 데이터를 선택합니다. 다음으로 분자 부분에 해당하는 현재 주가를 수집해야 합니다. 이 역시 Company Guide 접속 화면에서 구할 수 있습니다. 불필요한 부분을 제거한 URL은 다음과 같습니다. http://comp.fnguide.com/SVO2/ASP/SVD_main.asp?pGB=1&amp;gicode=A005930 위의 주소 역시 A 뒤의 6자리 티커만 변경하면 해당 종목의 스냅샷 페이지로 이동하게 됩니다. 그림 6.3: Company Guide 스냅샷 화면 주가추이 부분에 우리가 원하는 현재 주가가 있습니다. 해당 데이터의 Xpath는 다음과 같습니다. //*[@id=&quot;svdMainChartTxt11&quot;] //*[@id=\"svdMainChartTxt11\"] 위에서 구한 주가의 Xpath를 이용해 해당 데이터를 크롤링하겠습니다. library(readr) url = &#39;http://comp.fnguide.com/SVO2/ASP/SVD_main.asp?pGB=1&amp;gicode=A005930&#39; data = GET(url, user_agent(&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36&#39;)) price = read_html(data) %&gt;% html_node(xpath = &#39;//*[@id=&quot;svdMainChartTxt11&quot;]&#39;) %&gt;% html_text() %&gt;% parse_number() print(price) ## [1] 70600 url을 입력한 후, GET() 함수를 이용해 데이터를 불러오며, 역시나 user_agent를 추가해 줍니다. read_html() 함수를 이용해 HTML 데이터를 불러온 후 html_node() 함수에 앞서 구한 Xpath를 입력해 해당 지점의 데이터를 추출합니다. html_text() 함수를 통해 텍스트 데이터만을 추출하며, readr 패키지의 parse_number() 함수를 적용합니다. 가치지표를 계산하려면 발행주식수 역시 필요합니다. 예를 들어 PER를 계산하는 방법은 다음과 같습니다. \\[ PER = Price / EPS = 주가 / 주당순이익\\] 주당순이익은 순이익을 전체 주식수로 나눈 값이므로, 해당 값의 계산하려면 전체 주식수를 구해야 합니다. 전체 주식수 데이터 역시 웹페이지에 있으므로 앞서 주가를 크롤링한 방법과 동일한 방법으로 구할 수 있습니다. 전체 주식수 데이터의 Xpath는 다음과 같습니다. //*[@id=&quot;svdMainGrid1&quot;]/table/tbody/tr[7]/td[1] //*[@id=\"svdMainGrid1\"]/table/tbody/tr[7]/td[1] 이를 이용해 발행주식수 중 보통주를 선택하는 방법은 다음과 같습니다. share = read_html(data) %&gt;% html_node( xpath = &#39;//*[@id=&quot;svdMainGrid1&quot;]/table/tbody/tr[7]/td[1]&#39;) %&gt;% html_text() print(share) ## [1] &quot;5,969,782,550/ 822,886,700&quot; read_html() 함수와 html_node() 함수를 이용해, HTML 내에서 Xpath에 해당하는 데이터를 추출합니다. 그 후 html_text() 함수를 통해 텍스트 부분만 추출합니다. 해당 과정을 거치면 보통주/우선주의 형태로 발행주식주가 저장됩니다. 이 중 우리가 원하는 데이터는 / 앞에 있는 보통주 발행주식수입니다. share = share %&gt;% strsplit(&#39;/&#39;) %&gt;% unlist() %&gt;% .[1] %&gt;% parse_number() print(share) ## [1] 5969782550 strsplit() 함수를 통해 /를 기준으로 데이터를 나눕니다. 해당 결과는 리스트 형태로 저장됩니다. unlist() 함수를 통해 리스트를 벡터 형태로 변환합니다. .[1].[1]을 통해 보통주 발행주식수인 첫 번째 데이터를 선택합니다. parse_number() 함수를 통해 문자형 데이터를 숫자형으로 변환합니다. 재무 데이터, 현재 주가, 발행주식수를 이용해 가치지표를 계산해보겠습니다. data_value = price / (value_index * 100000000 / share) names(data_value) = c(&#39;PER&#39;, &#39;PBR&#39;, &#39;PCR&#39;, &#39;PSR&#39;) data_value[data_value &lt; 0] = NA print(data_value) ## PER PBR PCR PSR ## 16.154 1.527 6.456 1.780 분자에는 현재 주가를 입력하며, 분모에는 재무 데이터를 보통주 발행주식수로 나눈 값을 입력합니다. 단, 주가는 원 단위, 재무 데이터는 억 원 단위이므로, 둘 사이에 단위를 동일하게 맞춰주기 위해 분모에 억을 곱합니다. 또한 가치지표가 음수인 경우는 NA로 변경해줍니다. 결과를 확인해보면 4가지 가치지표가 잘 계산되었습니다.16 write.csv(data_value, &#39;data/KOR_value/005930_value.csv&#39;) data 폴더의 KOR_value 폴더 내에 티커_value.csv 이름으로 저장합니다. 6.2.3 전 종목 재무제표 및 가치지표 다운로드 위 코드에서 for loop 구문을 이용해 URL 중 6자리 티커에 해당하는 값만 변경해주면 모든 종목의 재무제표를 다운로드하고 이를 바탕으로 가치지표를 계산할 수 있습니다. 해당 코드는 다음과 같습니다. library(stringr) library(httr) library(rvest) library(readr) KOR_ticker = read.csv(&#39;data/KOR_ticker.csv&#39;, row.names = 1) KOR_ticker$&#39;종목코드&#39; = str_pad(KOR_ticker$&#39;종목코드&#39;, 6,side = c(&#39;left&#39;), pad = &#39;0&#39;) ifelse(dir.exists(&#39;data/KOR_fs&#39;), FALSE, dir.create(&#39;data/KOR_fs&#39;)) ifelse(dir.exists(&#39;data/KOR_value&#39;), FALSE, dir.create(&#39;data/KOR_value&#39;)) for(i in 1 : nrow(KOR_ticker) ) { data_fs = c() data_value = c() name = KOR_ticker$&#39;종목코드&#39;[i] # 오류 발생 시 이를 무시하고 다음 루프로 진행 tryCatch({ Sys.setlocale(&#39;LC_ALL&#39;, &#39;English&#39;) # url 생성 url = paste0( &#39;http://comp.fnguide.com/SVO2/ASP/&#39; ,&#39;SVD_Finance.asp?pGB=1&amp;gicode=A&#39;, name) # 이 후 과정은 위와 동일함 # 데이터 다운로드 후 테이블 추출 data = GET(url, user_agent(&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36&#39;)) %&gt;% read_html() %&gt;% html_table() Sys.setlocale(&#39;LC_ALL&#39;, &#39;Korean&#39;) # 3개 재무제표를 하나로 합치기 data_IS = data[[1]] data_BS = data[[3]] data_CF = data[[5]] data_IS = data_IS[, 1:(ncol(data_IS)-2)] data_fs = rbind(data_IS, data_BS, data_CF) %&gt;% data.frame() # 데이터 클랜징 data_fs[, 1] = gsub(&#39;계산에 참여한 계정 펼치기&#39;, &#39;&#39;, data_fs[, 1]) data_fs = data_fs[!duplicated(data_fs[, 1]), ] rownames(data_fs) = NULL rownames(data_fs) = data_fs[, 1] data_fs[, 1] = NULL # 12월 재무제표만 선택 data_fs = data_fs[, substr(colnames(data_fs), 7, 8) == &quot;12&quot;] data_fs = sapply(data_fs, function(x) { str_replace_all(x, &#39;,&#39;, &#39;&#39;) %&gt;% as.numeric() }) %&gt;% data.frame(., row.names = rownames(data_fs)) # 가치지표 분모부분 value_type = c(&#39;지배주주순이익&#39;, &#39;자본&#39;, &#39;영업활동으로인한현금흐름&#39;, &#39;매출액&#39;) # 해당 재무데이터만 선택 value_index = data_fs[match(value_type, rownames(data_fs)), ncol(data_fs)] # Snapshot 페이지 불러오기 url = paste0( &#39;http://comp.fnguide.com/SVO2/ASP/SVD_Main.asp&#39;, &#39;?pGB=1&amp;gicode=A&#39;,name) data = GET(url, user_agent(&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36&#39;)) # 현재 주가 크롤링 price = read_html(data) %&gt;% html_node(xpath = &#39;//*[@id=&quot;svdMainChartTxt11&quot;]&#39;) %&gt;% html_text() %&gt;% parse_number() # 보통주 발행주식수 크롤링 share = read_html(data) %&gt;% html_node( xpath = &#39;//*[@id=&quot;svdMainGrid1&quot;]/table/tbody/tr[7]/td[1]&#39;) %&gt;% html_text() %&gt;% strsplit(&#39;/&#39;) %&gt;% unlist() %&gt;% .[1] %&gt;% parse_number() # 가치지표 계산 data_value = price / (value_index * 100000000/ share) names(data_value) = c(&#39;PER&#39;, &#39;PBR&#39;, &#39;PCR&#39;, &#39;PSR&#39;) data_value[data_value &lt; 0] = NA }, error = function(e) { # 오류 발생시 해당 종목명을 출력하고 다음 루프로 이동 data_fs &lt;&lt;- NA data_value &lt;&lt;- NA warning(paste0(&quot;Error in Ticker: &quot;, name)) }) # 다운로드 받은 파일을 생성한 각각의 폴더 내 csv 파일로 저장 # 재무제표 저장 write.csv(data_fs, paste0(&#39;data/KOR_fs/&#39;, name, &#39;_fs.csv&#39;)) # 가치지표 저장 write.csv(data_value, paste0(&#39;data/KOR_value/&#39;, name, &#39;_value.csv&#39;)) # 2초간 타임슬립 적용 Sys.sleep(2) } 전 종목 주가 데이터를 받는 과정과 동일하게 KOR_ticker.csv 파일을 불러온 후 for loop를 통해 i 값이 변함에 따라 티커를 변경해가며 모든 종목의 재무제표 및 가치지표를 다운로드합니다. tryCatch() 함수를 이용해 오류가 발생하면 NA로 이루어진 빈 데이터를 저장한 후 다음 루프로 넘어가게 됩니다. data/KOR_fs 폴더에는 전 종목의 재무제표 데이터가 저장되고, data/KOR_value 폴더에는 전 종목의 가치지표 데이터가 csv 형태로 저장됩니다. 6.3 DART의 Open API를 이용한 데이터 수집하기 DART(Data Analysis, Retrieval and Transfer System)는 금융감독원 전자공시시스템으로써, 상장법인 등이 공시서류를 인터넷으로 제출하고, 투자자 등 이용자는 제출 즉시 인터넷을 통해 조회할 수 있도록 하는 종합적 기업공시 시스템입니다. 홈페이지에서도 각종 공시내역을 확인할 수 있지만, 해당 사이트에서 제공하는 API를 이용할 경우 더욱 쉽게 공시 내용을 수집할 수 있습니다. 6.3.1 API Key발급 및 추가하기 먼저 https://opendart.fss.or.kr/에 접속한 후 [인증키 신청/관리] → [인증키 신청]을 통해 API Key를 발급 받습니다. 그림 6.4: OpenAPI 인증키 신청 계정을 생성하고 이메일을 통해 이용자 등록을 한 후 로그인을 합니다. 그 후 [오픈API 이용현황]을 살펴보면 API Key 부분에 발급받은 Key가 있으며, 금일 몇번의 API를 요청했는지가 일일이용현황에 나옵니다. 하루 총 10,000번까지 데이터를 요청할 수 있습니다. 그림 6.5: OpenAPI 이용현황 다음으로 발급받은 API Key를 .Renviron 파일에 추가하도록 합니다. 해당 파일에는 여러 패스워드를 추가해 안전하게 관리할 수 있습니다. file.edit(&quot;~/.Renviron&quot;) .Renviron 파일이 열리면 다음과 같이 입력을 해줍니다. dart_api_key = &#39;발급받은 API&#39; 파일을 저장한 후 해당 파일을 적용하기 위해 R의 Session을 재시작합니다. 그 후 아래 명령어를 실행하여 API Key를 불러오도록 합니다. (재시작하지 않으면 Key를 불러올 수 없습니다.) dart_api = Sys.getenv(&quot;dart_api_key&quot;) 6.3.2 고유번호 다운로드 Open API에서 각 기업의 데이터를 받기 위해서는 종목에 해당하는 고유번호를 알아야 합니다. 이에 대한 개발가이드는 아래 페이지에 나와 있습니다. https://opendart.fss.or.kr/guide/detail.do?apiGrpCd=DS001&amp;apiId=2019018 위 페이지의 내용을 코드로 나타내보도록 합니다. library(httr) library(rvest) codezip_url = paste0( &#39;https://opendart.fss.or.kr/api/corpCode.xml?crtfc_key=&#39;,dart_api) codezip_data = GET(codezip_url) print(codezip_data) ## Response [https://opendart.fss.or.kr/api/corpCode.xml?crtfc_key=b1a630e527b0e5ff5bd58ed81b49825017fa80b8] ## Date: 2021-11-05 07:43 ## Status: 200 ## Content-Type: application/x-msdownload ## Size: 1.5 MB ## &lt;BINARY BODY&gt; ## NULL https://opendart.fss.or.kr/api/corpCode.xml?crtfc_key= 뒤에 본인의 API 키를 입력합니다. GET() 함수를 통해 해당 페이지 내용을 받습니다. 다운로드 받은 내용을 확인해보면 , 즉 바이너리 형태의 데이터가 첨부되어 있습니다. 이에 대해 좀더 자세히 알아보도록 하겠습니다. codezip_data$headers[[&quot;content-disposition&quot;]] ## [1] &quot;: attachment; filename=CORPCODE.zip&quot; headers의 “content-disposition” 부분을 확인해보면 CORPCODE.zip 파일이 첨부되어 있습니다. 해당 파일의 압축을 풀어 첨부된 내용을 확인합니다. tf = tempfile(fileext = &#39;.zip&#39;) writeBin( content(codezip_data, as = &quot;raw&quot;), file.path(tf) ) nm = unzip(tf, list = TRUE) print(nm) ## Name Length Date ## 1 CORPCODE.xml 17114213 &lt;NA&gt; tempfile() 함수 통해 빈 .zip 파일을 만듭니다. writeBin() 함수는 바이너리 형태의 파일을 저장하는 함수이며, content()를 통해 첨부 파일 내용을 raw 형태로 저장합니다. 파일명은 위에서 만든 tf로 합니다. unzip() 함수를 통해 zip 내 파일 리스트를 확인합니다. zip 파일 내에는 CORPCODE.xml 파일이 있으며, xml2 패키지의 read_xml() 함수를 통해 이를 불러오도록 합니다. library(xml2) code_data = read_xml(unzip(tf, nm$Name)) print(code_data) ## {xml_document} ## &lt;result&gt; ## [1] &lt;list&gt;\\n &lt;corp_code&gt;00434003&lt;/corp_code&gt;\\n &lt;corp_name&gt;다코&lt;/corp_name&gt;\\n ... ## [2] &lt;list&gt;\\n &lt;corp_code&gt;00434456&lt;/corp_code&gt;\\n &lt;corp_name&gt;일산약품&lt;/corp_name&gt; ... ## [3] &lt;list&gt;\\n &lt;corp_code&gt;00430964&lt;/corp_code&gt;\\n &lt;corp_name&gt;굿앤엘에스&lt;/corp_name ... ## [4] &lt;list&gt;\\n &lt;corp_code&gt;00432403&lt;/corp_code&gt;\\n &lt;corp_name&gt;한라판지&lt;/corp_name&gt; ... ## [5] &lt;list&gt;\\n &lt;corp_code&gt;00388953&lt;/corp_code&gt;\\n &lt;corp_name&gt;크레디피아제이십오차유동화전문회 ... ## [6] &lt;list&gt;\\n &lt;corp_code&gt;00179984&lt;/corp_code&gt;\\n &lt;corp_name&gt;연방건설산업&lt;/corp_nam ... ## [7] &lt;list&gt;\\n &lt;corp_code&gt;00420143&lt;/corp_code&gt;\\n &lt;corp_name&gt;브룩스피알아이오토메이션잉크&lt;/ ... ## [8] &lt;list&gt;\\n &lt;corp_code&gt;00401111&lt;/corp_code&gt;\\n &lt;corp_name&gt;매경아이비아이&lt;/corp_na ... ## [9] &lt;list&gt;\\n &lt;corp_code&gt;00435534&lt;/corp_code&gt;\\n &lt;corp_name&gt;캐드뱅크&lt;/corp_name&gt; ... ## [10] &lt;list&gt;\\n &lt;corp_code&gt;00430186&lt;/corp_code&gt;\\n &lt;corp_name&gt;엠와이오피삼차유동화전문유한회사 ... ## [11] &lt;list&gt;\\n &lt;corp_code&gt;00430201&lt;/corp_code&gt;\\n &lt;corp_name&gt;엠와이오피이차유동화전문유한회사 ... ## [12] &lt;list&gt;\\n &lt;corp_code&gt;00430210&lt;/corp_code&gt;\\n &lt;corp_name&gt;엠와이오피일차유동화전문유한회사 ... ## [13] &lt;list&gt;\\n &lt;corp_code&gt;00430229&lt;/corp_code&gt;\\n &lt;corp_name&gt;포스미디어&lt;/corp_name ... ## [14] &lt;list&gt;\\n &lt;corp_code&gt;00140432&lt;/corp_code&gt;\\n &lt;corp_name&gt;축복할렐루야&lt;/corp_nam ... ## [15] &lt;list&gt;\\n &lt;corp_code&gt;00426208&lt;/corp_code&gt;\\n &lt;corp_name&gt;한국전자화학&lt;/corp_nam ... ## [16] &lt;list&gt;\\n &lt;corp_code&gt;00433262&lt;/corp_code&gt;\\n &lt;corp_name&gt;ConnachtCapitalM ... ## [17] &lt;list&gt;\\n &lt;corp_code&gt;00433749&lt;/corp_code&gt;\\n &lt;corp_name&gt;선진아이티&lt;/corp_name ... ## [18] &lt;list&gt;\\n &lt;corp_code&gt;00433785&lt;/corp_code&gt;\\n &lt;corp_name&gt;팀스코리아&lt;/corp_name ... ## [19] &lt;list&gt;\\n &lt;corp_code&gt;00196079&lt;/corp_code&gt;\\n &lt;corp_name&gt;에넥스하이테크&lt;/corp_na ... ## [20] &lt;list&gt;\\n &lt;corp_code&gt;00435048&lt;/corp_code&gt;\\n &lt;corp_name&gt;세이스텝바이스텝혼합형펀드&lt;/c ... ## ... 해당 파일은 HTML 형식으로 되어 있으며 중요부분은 다음과 같습니다. corp_code: 고유번호 corp_name: 종목명 corp_stock: 거래소 상장 티커 HTML의 태그를 이용해 각 부분을 추출한 후 하나의 데이터로 합치도록 하겠습니다. corp_code = code_data %&gt;% html_nodes(&#39;corp_code&#39;) %&gt;% html_text() corp_name = code_data %&gt;% html_nodes(&#39;corp_name&#39;) %&gt;% html_text() corp_stock = code_data %&gt;% html_nodes(&#39;stock_code&#39;) %&gt;% html_text() corp_list = data.frame( &#39;code&#39; = corp_code, &#39;name&#39; = corp_name, &#39;stock&#39; = corp_stock, stringsAsFactors = FALSE ) html_nodes() 함수를 이용해 고유번호, 종목명, 상장티커를 선택한 후, html_text() 함수를 이용해 문자열만 추출하도록 합니다. data.frame() 함수를 통해 데이터프레임 형식으로 묶어주도록 합니다. nrow(corp_list) ## [1] 88754 head(corp_list) ## code name stock ## 1 00434003 다코 ## 2 00434456 일산약품 ## 3 00430964 굿앤엘에스 ## 4 00432403 한라판지 ## 5 00388953 크레디피아제이십오차유동화전문회사 ## 6 00179984 연방건설산업 종목수를 확인해보면 88754 개가 확인되며, 이 중 stock 열이 빈 종목은 거래소에 상장되지 않은 종목입니다. 따라서 해당 데이터는 삭제하여 거래소 상장 종목만을 남긴 후, csv 파일로 저장하도록 합니다. corp_list = corp_list[corp_list$stock != &quot; &quot;, ] write.csv(corp_list, &#39;data/corp_list.csv&#39;) 6.3.3 공시검색 6.3.3.1 전체 공시 검색 먼저 공시검색 API에 대한 이해를 위해 전체 종목의 공시를 수집하도록 하며, 해당 개발가이드는 아래 페이지에 나와 있습니다. https://opendart.fss.or.kr/guide/detail.do?apiGrpCd=DS001&amp;apiId=2019001 각종 요청인자를 통해 url을 생성 후 전송하여, 요청에 맞는 데이터를 받을 수 있습니다. 공시 검색에 해당하는 인자는 다음과 같습니다. 그림 6.6: OpenAPI 요청 인자 예시 페이지 하단에서 인자를 입력 후 [검색]을 누르면 각 인자에 맞게 생성된 url과 그 결과를 볼 수 있습니다. 그림 6.7: OpenAPI 테스트 예시 먼저 시작일과 종료일을 토대로 최근 공시 100건에 해당하는 url을 생성하도록 하겠습니다. library(lubridate) library(stringr) library(jsonlite) bgn_date = (Sys.Date() - days(7)) %&gt;% str_remove_all(&#39;-&#39;) end_date = (Sys.Date() ) %&gt;% str_remove_all(&#39;-&#39;) notice_url = paste0(&#39;https://opendart.fss.or.kr/api/list.json?crtfc_key=&#39;,dart_api,&#39;&amp;bgn_de=&#39;, bgn_date,&#39;&amp;end_de=&#39;,end_date,&#39;&amp;page_no=1&amp;page_count=100&#39;) bgn_date에는 현재로부터 일주일 전을, end_date는 오늘 날짜를, 페이지별 건수에 해당하는 page_count에는 100을 입력하도록 합니다. 그 후 홈페이지에 나와있는 예시에 맞게 url을 작성해주도록 합니다. XML 보다는 JSON 형식으로 url을 생성 후 요청하는 것이 데이터 처리 측면에서 훨씬 효율적입니다. notice_data = fromJSON(notice_url) notice_data = notice_data[[&#39;list&#39;]] head(notice_data) ## corp_code corp_name stock_code corp_cls ## 1 00111722 미래에셋증권 006800 Y ## 2 00356361 LG화학 051910 Y ## 3 00232821 클라우드에어 036170 K ## 4 00363510 얍엑스 060230 K ## 5 00186452 릭스솔루션 029480 K ## 6 00107613 이수페타시스 007660 Y ## report_nm rcept_no flr_nm rcept_dt ## 1 증권발행실적보고서 20211105000388 미래에셋증권 20211105 ## 2 기업설명회(IR)개최(안내공시) 20211105800629 LG화학 20211105 ## 3 임원ㆍ주요주주특정증권등소유상황보고서 20211105000385 케이앤커 20211105 ## 4 [기재정정]주주총회소집결의 20211105900534 얍엑스 20211105 ## 5 주식등의대량보유상황보고서(약식) 20211105000383 에스엘파워 20211105 ## 6 증권발행실적보고서 20211105000382 이수페타시스 20211105 ## rm ## 1 ## 2 유 ## 3 ## 4 코 ## 5 ## 6 fromJSON() 함수를 통해 JSON 데이터를 받은 후 list를 확인해보면 우리가 원하는 공시정보, 즉 일주일 전부터 100건의 공시 정보가 다운로드 되어 있습니다. 6.3.3.2 특정 기업의 공시 검색 이번에는 고유번호를 추가하여 원하는 기업의 공시만 확인해보록 하겠습니다. 고유번호는 위에서 다운받은 corp_list.csv 파일을 통해 확인해볼 수 있으며, 예시로 살펴볼 삼성전자의 고유번호는 00126380 입니다. bgn_date = (Sys.Date() - days(30)) %&gt;% str_remove_all(&#39;-&#39;) end_date = (Sys.Date() ) %&gt;% str_remove_all(&#39;-&#39;) corp_code = &#39;00126380&#39; notice_url_ss = paste0( &#39;https://opendart.fss.or.kr/api/list.json?crtfc_key=&#39;,dart_api, &#39;&amp;corp_code=&#39;, corp_code, &#39;&amp;bgn_de=&#39;, bgn_date,&#39;&amp;end_de=&#39;, end_date,&#39;&amp;page_no=1&amp;page_count=100&#39;) 시작일을 과거 30일로 수정하였으며, 기존 url에 &amp;corp_code= 부분을 추가하였습니다. notice_data_ss = fromJSON(notice_url_ss) notice_data_ss = notice_data_ss[[&#39;list&#39;]] head(notice_data_ss) ## corp_code corp_name stock_code corp_cls ## 1 00126380 삼성전자 005930 Y ## 2 00126380 삼성전자 005930 Y ## 3 00126380 삼성전자 005930 Y ## 4 00126380 삼성전자 005930 Y ## 5 00126380 삼성전자 005930 Y ## 6 00126380 삼성전자 005930 Y ## report_nm rcept_no flr_nm rcept_dt ## 1 주식등의대량보유상황보고서(약식) 20211103000100 국민연금공단 20211103 ## 2 주식등의대량보유상황보고서(일반) 20211029000589 삼성물산 20211029 ## 3 임원ㆍ주요주주특정증권등소유상황보고서 20211029000179 안규리 20211029 ## 4 기타경영사항(자율공시) 20211028800081 삼성전자 20211028 ## 5 특수관계인에대한출자 20211028000016 삼성전자 20211028 ## 6 특수관계인에대한출자 20211028000015 삼성전자 20211028 ## rm ## 1 ## 2 ## 3 ## 4 유 ## 5 공 ## 6 공 역시나 JSON 형태로 손쉽게 공시정보를 다운로드 받을 수 있습니다. 이 중 rcept_no는 공시번호에 해당하며, 해당 데이터를 이용해 공시에 해당하는 url에 접속을 할 수도 있습니다. notice_url_exam = notice_data_ss[1, &#39;rcept_no&#39;] notice_dart_url = paste0( &#39;http://dart.fss.or.kr/dsaf001/main.do?rcpNo=&#39;,notice_url_exam) print(notice_dart_url) ## [1] &quot;http://dart.fss.or.kr/dsaf001/main.do?rcpNo=20211103000100&quot; dart 홈페이지의 공시에 해당하는 url과 첫번째 공시에 해당하는 공시번호를 합쳐주도록 합니다. 위 url에 접속하여 해당 공시를 좀 더 자세하게 확인할 수 있습니다. 그림 6.8: 공시 정보의 확인 6.3.4 사업보고서 주요 정보 API를 이용하여 사업보고서의 주요 정보 역시 다운로드 받을 수 있으며, 제공하는 목록은 다음과 같습니다. https://opendart.fss.or.kr/guide/main.do?apiGrpCd=DS002 이 중 예시로써 [배당에 관한 사항]을 다운로드 받도록 하며, 개발가이드 페이지는 다음과 같습니다. https://opendart.fss.or.kr/guide/detail.do?apiGrpCd=DS002&amp;apiId=2019005 url 생성에 필요한 요청 인자는 다음과 같습니다. 표 6.3: 배당에 관한 사항 주요 인자 키 명칭 설명 crtfc_key API 인증키 발급받은 인증키 corp_code 고유번호 공시대상회사의 고유번호(8자리) bsns_year 사업년도 사업연도(4자리) reprt_code 보고서 코드 1분기보고서 : 11013 반기보고서 : 11012 3분기보고서 : 11014 사업보고서 : 11011 이를 바탕으로 삼성전자의 2019년 사업보고서를 통해 배당에 관한 사항을 살펴보도록 하겠습니다. corp_code = &#39;00126380&#39; bsns_year = &#39;2019&#39; reprt_code = &#39;11011&#39; url_div = paste0(&#39;https://opendart.fss.or.kr/api/alotMatter.json?crtfc_key=&#39;, dart_api, &#39;&amp;corp_code=&#39;, corp_code, &#39;&amp;bsns_year=&#39;, bsns_year, &#39;&amp;reprt_code=&#39;, reprt_code ) API 인증키, 고유번호, 사업년도, 보고서 코드에 각각 해당하는 데이터를 입력하여 url 생성하도록 합니다. div_data_ss = fromJSON(url_div) div_data_ss = div_data_ss[[&#39;list&#39;]] head(div_data_ss) ## rcept_no corp_cls corp_code corp_name se ## 1 20200330003851 Y 00126380 삼성전자 주당액면가액(원) ## 2 20200330003851 Y 00126380 삼성전자 (연결)당기순이익(백만원) ## 3 20200330003851 Y 00126380 삼성전자 (별도)당기순이익(백만원) ## 4 20200330003851 Y 00126380 삼성전자 (연결)주당순이익(원) ## 5 20200330003851 Y 00126380 삼성전자 현금배당금총액(백만원) ## 6 20200330003851 Y 00126380 삼성전자 주식배당금총액(백만원) ## thstrm frmtrm lwfr stock_knd ## 1 100 100 100 &lt;NA&gt; ## 2 21,505,054 43,890,877 41,344,569 &lt;NA&gt; ## 3 15,353,323 32,815,127 28,800,837 &lt;NA&gt; ## 4 3,166 6,461 5,997 &lt;NA&gt; ## 5 9,619,243 9,619,243 5,826,302 &lt;NA&gt; ## 6 - - - &lt;NA&gt; JSON 파일을 다운로드 받은 후 데이터를 확인해보면, 사업보고서 중 배당에 관한 사항만이 나타나 있습니다. 위 url의 alotMatter 부분을 각 사업보고서에 해당하는 값으로 변경해주면 다른 정보 역시 동일한 방법으로 수집이 가능합니다. 6.3.5 상장기업 재무정보 Open API에서는 상장기업의 재무정보 중 주요계정, 전체 재무제표, 원본파일을 제공하고 있습니다. 이 중 주요계정 및 전체 재무제표를 다운로드 받는법에 대해 알아보도록 하겠습니다. 6.3.5.1 단일회사 및 다중회사 주요계정 API를 통해 단일회사의 주요계정을, 혹은 한번에 여러 회사의 주요계정을 받을수 있습니다. 각각의 개발가이드는 다음과 같습니다. 단일회사 주요계정: https://opendart.fss.or.kr/guide/detail.do?apiGrpCd=DS003&amp;apiId=2019016 다중회사 주요계정: https://opendart.fss.or.kr/guide/detail.do?apiGrpCd=DS003&amp;apiId=2019017 먼저 단일회사(삼성전자)의 주요계정을 다운로드 받도록 하겠습니다. corp_code = &#39;00126380&#39; bsns_year = &#39;2019&#39; reprt_code = &#39;11011&#39; url_single = paste0( &#39;https://opendart.fss.or.kr/api/fnlttSinglAcnt.json?crtfc_key=&#39;, dart_api, &#39;&amp;corp_code=&#39;, corp_code, &#39;&amp;bsns_year=&#39;, bsns_year, &#39;&amp;reprt_code=&#39;, reprt_code ) url을 생성하는 방법이 기존 사업보고서 주요 정보 에서 살펴본 바와 매우 비슷하며, /api 뒷부분을 [fnlttSinglAcnt.json] 으로 변경하기만 하면 됩니다. fs_data_single = fromJSON(url_single) fs_data_single = fs_data_single[[&#39;list&#39;]] head(fs_data_single) ## rcept_no reprt_code bsns_year corp_code stock_code fs_div fs_nm ## 1 20200330003851 11011 2019 00126380 005930 CFS 연결재무제표 ## 2 20200330003851 11011 2019 00126380 005930 CFS 연결재무제표 ## 3 20200330003851 11011 2019 00126380 005930 CFS 연결재무제표 ## 4 20200330003851 11011 2019 00126380 005930 CFS 연결재무제표 ## 5 20200330003851 11011 2019 00126380 005930 CFS 연결재무제표 ## 6 20200330003851 11011 2019 00126380 005930 CFS 연결재무제표 ## sj_div sj_nm account_nm thstrm_nm thstrm_dt thstrm_amount ## 1 BS 재무상태표 유동자산 제 51 기 2019.12.31 현재 181,385,260,000,000 ## 2 BS 재무상태표 비유동자산 제 51 기 2019.12.31 현재 171,179,237,000,000 ## 3 BS 재무상태표 자산총계 제 51 기 2019.12.31 현재 352,564,497,000,000 ## 4 BS 재무상태표 유동부채 제 51 기 2019.12.31 현재 63,782,764,000,000 ## 5 BS 재무상태표 비유동부채 제 51 기 2019.12.31 현재 25,901,312,000,000 ## 6 BS 재무상태표 부채총계 제 51 기 2019.12.31 현재 89,684,076,000,000 ## frmtrm_nm frmtrm_dt frmtrm_amount bfefrmtrm_nm bfefrmtrm_dt ## 1 제 50 기 2018.12.31 현재 174,697,424,000,000 제 49 기 2017.12.31 현재 ## 2 제 50 기 2018.12.31 현재 164,659,820,000,000 제 49 기 2017.12.31 현재 ## 3 제 50 기 2018.12.31 현재 339,357,244,000,000 제 49 기 2017.12.31 현재 ## 4 제 50 기 2018.12.31 현재 69,081,510,000,000 제 49 기 2017.12.31 현재 ## 5 제 50 기 2018.12.31 현재 22,522,557,000,000 제 49 기 2017.12.31 현재 ## 6 제 50 기 2018.12.31 현재 91,604,067,000,000 제 49 기 2017.12.31 현재 ## bfefrmtrm_amount ord ## 1 146,982,464,000,000 1 ## 2 154,769,626,000,000 3 ## 3 301,752,090,000,000 5 ## 4 67,175,114,000,000 7 ## 5 20,085,548,000,000 9 ## 6 87,260,662,000,000 11 연결재무제표와 재무상태표에 해당하는 주요 내용이 수집되었으며, 각 열에 해당하는 내용은 페이지의 개발가이드의 [응답 결과]에서 확인할 수 있습니다. 그림 6.9: 단일회사 주요계정 응답 결과 이번에는 url을 수정하여 여러 회사의 주요계정을 한번에 받도록 하겠으며, 그 예로써 삼성전자, 셀트리온, KT의 데이터를 다운로드 받도록 합니다. corp_code = c(&#39;00126380,00413046,00190321&#39;) bsns_year = &#39;2019&#39; reprt_code = &#39;11011&#39; url_multiple = paste0( &#39;https://opendart.fss.or.kr/api/fnlttMultiAcnt.json?crtfc_key=&#39;, dart_api, &#39;&amp;corp_code=&#39;, corp_code, &#39;&amp;bsns_year=&#39;, bsns_year, &#39;&amp;reprt_code=&#39;, reprt_code ) 먼저 corp에 원하는 기업들의 고유번호를 나열해주며, url 중 [fnlttSinglAcnt]을 [fnlttMultiAcnt]로 수정합니다. fs_data_multiple = fromJSON(url_multiple) fs_data_multiple = fs_data_multiple[[&#39;list&#39;]] 3개 기업의 주요계정이 하나의 데이터 프레임으로 다운로드 됩니다. 마지막으로 각 회사별로 데이터를 나눠주도록 하겠습니다. fs_data_list = fs_data_multiple %&gt;% split(f = .$corp_code) lapply(fs_data_list, head, 2) ## $`00126380` ## rcept_no reprt_code bsns_year corp_code stock_code fs_div fs_nm ## 1 20200330003851 11011 2019 00126380 005930 CFS 연결재무제표 ## 2 20200330003851 11011 2019 00126380 005930 CFS 연결재무제표 ## sj_div sj_nm account_nm thstrm_nm thstrm_dt thstrm_amount ## 1 BS 재무상태표 유동자산 제 51 기 2019.12.31 현재 181,385,260,000,000 ## 2 BS 재무상태표 비유동자산 제 51 기 2019.12.31 현재 171,179,237,000,000 ## frmtrm_nm frmtrm_dt frmtrm_amount bfefrmtrm_nm bfefrmtrm_dt ## 1 제 50 기 2018.12.31 현재 174,697,424,000,000 제 49 기 2017.12.31 현재 ## 2 제 50 기 2018.12.31 현재 164,659,820,000,000 제 49 기 2017.12.31 현재 ## bfefrmtrm_amount ord ## 1 146,982,464,000,000 1 ## 2 154,769,626,000,000 3 ## ## $`00190321` ## rcept_no reprt_code bsns_year corp_code stock_code fs_div fs_nm ## 27 20200330004658 11011 2019 00190321 030200 CFS 연결재무제표 ## 28 20200330004658 11011 2019 00190321 030200 CFS 연결재무제표 ## sj_div sj_nm account_nm thstrm_nm thstrm_dt thstrm_amount ## 27 BS 재무상태표 유동자산 제 38 기 2019.12.31 현재 11,898,255,000,000 ## 28 BS 재무상태표 비유동자산 제 38 기 2019.12.31 현재 22,163,037,000,000 ## frmtrm_nm frmtrm_dt frmtrm_amount bfefrmtrm_nm bfefrmtrm_dt ## 27 제 37 기 2018.12.31 현재 11,894,252,000,000 제 36 기 2017.12.31 현재 ## 28 제 37 기 2018.12.31 현재 20,294,578,000,000 제 36 기 2017.12.31 현재 ## bfefrmtrm_amount ord ## 27 9,672,412,000,000 1 ## 28 20,058,498,000,000 3 ## ## $`00413046` ## rcept_no reprt_code bsns_year corp_code stock_code fs_div fs_nm ## 53 20200410002837 11011 2019 00413046 068270 CFS 연결재무제표 ## 54 20200410002837 11011 2019 00413046 068270 CFS 연결재무제표 ## sj_div sj_nm account_nm thstrm_nm thstrm_dt thstrm_amount ## 53 BS 재무상태표 유동자산 제 29 기 2019.12.31 현재 1,787,340,254,600 ## 54 BS 재무상태표 비유동자산 제 29 기 2019.12.31 현재 2,106,351,351,846 ## frmtrm_nm frmtrm_dt frmtrm_amount bfefrmtrm_nm bfefrmtrm_dt ## 53 제 28 기 2018.12.31 현재 1,664,478,918,682 제 27 기 2017.12.31 현재 ## 54 제 28 기 2018.12.31 현재 1,876,147,755,272 제 27 기 2017.12.31 현재 ## bfefrmtrm_amount ord ## 53 1,614,033,788,024 1 ## 54 1,701,493,916,629 3 split() 함수 내 f 인자를 통해 corp_code, 즉 고유번호 단위로 각각의 리스트에 데이터가 저장됩니다. 6.3.6 단일회사 전체 재무제표 단일회사의 전체 재무제표 데이터 역시 다운로드 받을 수 있으며 개발가이드는 다음과 같습니다. https://opendart.fss.or.kr/guide/detail.do?apiGrpCd=DS003&amp;apiId=2019020 예제로써 삼성전자의 2019년 사업보고서에 나와있는 전체 재무제표를 다운로드 받도록 하겠습니다. corp_code = &#39;00126380&#39; bsns_year = 2019 reprt_code = &#39;11011&#39; url_fs_all = paste0( &#39;https://opendart.fss.or.kr/api/fnlttSinglAcntAll.json?crtfc_key=&#39;, dart_api, &#39;&amp;corp_code=&#39;, corp_code, &#39;&amp;bsns_year=&#39;, bsns_year, &#39;&amp;reprt_code=&#39;, reprt_code,&#39;&amp;fs_div=CFS&#39; ) 역시나 앞선 예제들과 거의 동일화며, url의 api/ 뒷 부분을 [fnlttSinglAcntAll.json] 으로 변경해주도록 합니다. 연결재무제표와 일반재무제표를 구분하는 fs_div 인자는 연결재무제표를 의미하는 CFS로 선택해줍니다. fs_data_all = fromJSON(url_fs_all) fs_data_all = fs_data_all[[&#39;list&#39;]] head(fs_data_all) ## rcept_no reprt_code bsns_year corp_code sj_div sj_nm ## 1 20200330003851 11011 2019 00126380 BS 재무상태표 ## 2 20200330003851 11011 2019 00126380 BS 재무상태표 ## 3 20200330003851 11011 2019 00126380 BS 재무상태표 ## 4 20200330003851 11011 2019 00126380 BS 재무상태표 ## 5 20200330003851 11011 2019 00126380 BS 재무상태표 ## 6 20200330003851 11011 2019 00126380 BS 재무상태표 ## account_id ## 1 ifrs-full_CurrentAssets ## 2 ifrs-full_CashAndCashEquivalents ## 3 dart_ShortTermDepositsNotClassifiedAsCashEquivalents ## 4 -표준계정코드 미사용- ## 5 -표준계정코드 미사용- ## 6 ifrs-full_CurrentFinancialAssetsAtFairValueThroughProfitOrLossMandatorilyMeasuredAtFairValue ## account_nm account_detail thstrm_nm thstrm_amount ## 1 유동자산 - 제 51 기 181385260000000 ## 2 현금및현금성자산 - 제 51 기 26885999000000 ## 3 단기금융상품 - 제 51 기 76252052000000 ## 4 단기매도가능금융자산 - 제 51 기 ## 5 단기상각후원가금융자산 - 제 51 기 3914216000000 ## 6 단기당기손익-공정가치금융자산 - 제 51 기 1727436000000 ## frmtrm_nm frmtrm_amount bfefrmtrm_nm bfefrmtrm_amount ord thstrm_add_amount ## 1 제 50 기 174697424000000 제 49 기 146982464000000 1 &lt;NA&gt; ## 2 제 50 기 30340505000000 제 49 기 30545130000000 2 &lt;NA&gt; ## 3 제 50 기 65893797000000 제 49 기 49447696000000 3 &lt;NA&gt; ## 4 제 50 기 제 49 기 3191375000000 4 &lt;NA&gt; ## 5 제 50 기 2703693000000 제 49 기 5 &lt;NA&gt; ## 6 제 50 기 2001948000000 제 49 기 6 &lt;NA&gt; 총 210개의 재무제표 항목이 다운로드 됩니다. 이 중 thstrm_nm와 thstrm_amount는 당기(금년), frmtrm_nm과 frmtrm_amount는 전기, bfefrmtrm_nm과 bfefrmtrm_amount는 전전기를 의미합니다. 따라서 해당 열을 통해 최근 3년 재무제표 만을 선택할 수도 있습니다. yr_count = str_detect(colnames(fs_data_all), &#39;trm_amount&#39;) %&gt;% sum() yr_name = seq(bsns_year, (bsns_year - yr_count + 1)) fs_data_all = fs_data_all[, c(&#39;corp_code&#39;, &#39;sj_nm&#39;, &#39;account_nm&#39;, &#39;account_detail&#39;)] %&gt;% cbind(fs_data_all[, str_which(colnames(fs_data_all), &#39;trm_amount&#39;)]) colnames(fs_data_all)[str_which(colnames(fs_data_all), &#39;amount&#39;)] = yr_name head(fs_data_all) ## corp_code sj_nm account_nm account_detail ## 1 00126380 재무상태표 유동자산 - ## 2 00126380 재무상태표 현금및현금성자산 - ## 3 00126380 재무상태표 단기금융상품 - ## 4 00126380 재무상태표 단기매도가능금융자산 - ## 5 00126380 재무상태표 단기상각후원가금융자산 - ## 6 00126380 재무상태표 단기당기손익-공정가치금융자산 - ## 2019 2018 2017 ## 1 181385260000000 174697424000000 146982464000000 ## 2 26885999000000 30340505000000 30545130000000 ## 3 76252052000000 65893797000000 49447696000000 ## 4 3191375000000 ## 5 3914216000000 2703693000000 ## 6 1727436000000 2001948000000 str_detect() 함수를 이용해 열 이름에 trm_amount 들어간 갯수를 확인합니다. 이는 최근 3개년 데이터가 없는 경우도 고려하기 위함입니다. (일반적으로 3이 반환될 것이며, 재무데이터가 2년치 밖에 없는 경우 2가 반환될 것입니다.) 위에서 계산된 갯수를 이용해 열이름에 들어갈 년도를 생성합니다. corp_code(고유번호), sj_nm(재무제표명), account_nm(계정명), account_detail(계정상세) 및 연도별 금액에 해당하는 trm_amount가 포함된 열을 선택합니다. 연도별 데이터에 해당하는 열의 이름을 yr_name, 즉 각 연도로 변경합니다. 6.3.6.1 전 종목 전체 재무제표 데이터 수집하기 for loop 구문을 이용해 고유번호에 해당하는 corp_code 부분만 변경해주면 전 종목의 API를 통해 재무제표 데이터를 손쉽게 수집할 수도 있습니다. 단, 일부 종목(대부분 금융주)의 경우 API로 파일이 제공되지 않습니다. library(stringr) KOR_ticker = read.csv(&#39;data/KOR_ticker.csv&#39;, row.names = 1) corp_list = read.csv(&#39;data/corp_list.csv&#39;, row.names = 1) KOR_ticker$&#39;종목코드&#39; = str_pad(KOR_ticker$&#39;종목코드&#39;, 6, side = c(&#39;left&#39;), pad = &#39;0&#39;) corp_list$&#39;code&#39; = str_pad(corp_list$&#39;code&#39;, 8, side = c(&#39;left&#39;), pad = &#39;0&#39;) corp_list$&#39;stock&#39; = str_pad(corp_list$&#39;stock&#39;, 6, side = c(&#39;left&#39;), pad = &#39;0&#39;) ticker_list = KOR_ticker %&gt;% left_join(corp_list, by = c(&#39;종목코드&#39; = &#39;stock&#39;)) %&gt;% select(&#39;종목코드&#39;, &#39;종목명&#39;, &#39;code&#39;) ifelse(dir.exists(&#39;data/dart_fs&#39;), FALSE, dir.create(&#39;data/dart_fs&#39;)) 먼저 거래소에서 받은 티커 파일과 API를 통해 받은 고유번호 파일을 불러온 후, str_pad() 함수를 통해 0을 채워주며, 고유번호의 경우 8자리로 구성되어 있습니다. 그 후 dart_fs 폴더를 생성해 줍니다. bsns_year = 2019 reprt_code = &#39;11011&#39; for(i in 1 : nrow(ticker_list) ) { data_fs = c() name = ticker_list$code[i] # 오류 발생 시 이를 무시하고 다음 루프로 진행 tryCatch({ # url 생성 url = paste0(&#39;https://opendart.fss.or.kr/api/fnlttSinglAcntAll.json?crtfc_key=&#39;, dart_api, &#39;&amp;corp_code=&#39;, name, &#39;&amp;bsns_year=&#39;, bsns_year, &#39;&amp;reprt_code=&#39;, reprt_code,&#39;&amp;fs_div=CFS&#39; ) # JSON 다운로드 fs_data_all = fromJSON(url) fs_data_all = fs_data_all[[&#39;list&#39;]] # 만일 연결재무제표 없어서 NULL 반환시 # reprt_code를 OFS 즉 재무제표 다운로드 if (is.null(fs_data_all)) { url = paste0(&#39;https://opendart.fss.or.kr/api/fnlttSinglAcntAll.json?crtfc_key=&#39;, dart_api, &#39;&amp;corp_code=&#39;, name, &#39;&amp;bsns_year=&#39;, bsns_year, &#39;&amp;reprt_code=&#39;, reprt_code,&#39;&amp;fs_div=OFS&#39; ) fs_data_all = fromJSON(url) fs_data_all = fs_data_all[[&#39;list&#39;]] } # 데이터 선택 후 열이름을 연도로 변경 yr_count = str_detect(colnames(fs_data_all), &#39;trm_amount&#39;) %&gt;% sum() yr_name = seq(bsns_year, (bsns_year - yr_count + 1)) fs_data_all = fs_data_all[, c(&#39;corp_code&#39;, &#39;sj_nm&#39;, &#39;account_nm&#39;, &#39;account_detail&#39;)] %&gt;% cbind(fs_data_all[, str_which(colnames(fs_data_all), &#39;trm_amount&#39;)]) colnames(fs_data_all)[str_which(colnames(fs_data_all), &#39;amount&#39;)] = yr_name }, error = function(e) { # 오류 발생시 해당 종목명을 출력하고 다음 루프로 이동 data_fs &lt;&lt;- NA warning(paste0(&quot;Error in Ticker: &quot;, name)) }) # 다운로드 받은 파일을 생성한 각각의 폴더 내 csv 파일로 저장 # 재무제표 저장 write.csv(fs_data_all, paste0(&#39;data/dart_fs/&#39;, ticker_list$종목코드[i], &#39;_fs_dart.csv&#39;)) # 2초간 타임슬립 적용 Sys.sleep(2) } for loop 구문을 이용해 고유번호에 해당하는 값을 변경합니다. 일부 종목의 경우 연결재무제표가 아닌 재무제표를 업로드 하는 경우가 있으며, if (is.null(fs_data_all)) 부분을 통해 연결재무제표가 없을 경우 fs_div를 OFS로 변경하여 재무제표를 다운로드 받습니다. 이를 제외하고는 앞서 살펴본 예제와 동일합니다. 데이터 수집 및 정리를 해준 후, data 폴더의 dart_fs 폴더 내에 티커_fs_dart.csv 이름으로 저장해 줍니다. Open API 내에서는 2015년 이후 재무제표 데이터를 API 형태로 제공하고 있으므로 bsns_year 부분에도 for loop 구문을 이용하면 해당 데이터를 모두 수집할 수 있습니다. 그러나 간단한 퀀트 투자를 하기에는 최근 3년의 재무제표 데이터만 있어도 충분하며, 시간이 너무 오래 걸린다는 점, API 요청한도를 초과한다는 단점이 있으므로 본 책에서는 다루지 않도록 하겠습니다. https://finance.naver.com/item/fchart.nhn?code=005930↩︎ http://comp.fnguide.com/↩︎ 분모에 사용되는 재무데이터의 구체적인 항목과 발행주식수를 계산하는 방법의 차이로 인해 여러 업체에서 제공하는 가치지표와 다소 차이가 발생할 수 있습니다.↩︎ "],["데이터-정리하기.html", "Chapter 7 데이터 정리하기 7.1 주가 정리하기 7.2 재무제표 정리하기 7.3 가치지표 정리하기", " Chapter 7 데이터 정리하기 앞 CHAPTER에서는 API와 크롤링을 통해 주가, 재무제표, 가치지표를 수집하는 방법을 배웠습니다. 이번 CHAPTER에서는 각각 csv 파일로 저장된 데이터들을 하나로 합친 후 저장하는 과정을 살펴보겠습니다. 7.1 주가 정리하기 주가는 data/KOR_price 폴더 내에 티커_price.csv 파일로 저장되어 있습니다. 해당 파일들을 불러온 후 데이터를 묶는 작업을 통해 하나의 파일로 합치는 방법을 알아보겠습니다. library(stringr) library(xts) library(magrittr) KOR_ticker = read.csv(&#39;data/KOR_ticker.csv&#39;, row.names = 1) KOR_ticker$&#39;종목코드&#39; = str_pad(KOR_ticker$&#39;종목코드&#39;, 6, side = c(&#39;left&#39;), pad = &#39;0&#39;) price_list = list() for (i in 1 : nrow(KOR_ticker)) { name = KOR_ticker[i, &#39;종목코드&#39;] price_list[[i]] = read.csv(paste0(&#39;data/KOR_price/&#39;, name, &#39;_price.csv&#39;),row.names = 1) %&gt;% as.xts() } price_list = do.call(cbind, price_list) %&gt;% na.locf() colnames(price_list) = KOR_ticker$&#39;종목코드&#39; head(price_list[, 1:5]) ## X X005930 X000660 X035420 X207940 ## 1 2018-11-05 43800 70500 113500 399000 ## 2 2018-11-06 43750 70100 117000 401000 ## 3 2018-11-07 44000 70800 115500 400000 ## 4 2018-11-08 44050 72900 116500 384500 ## 5 2018-11-09 44300 72900 115000 368000 ## 6 2018-11-12 45200 74500 115000 285500 tail(price_list[, 1:5]) ## X X005930 X000660 X035420 X207940 ## 737 2021-10-29 69800 103000 407000 871000 ## 738 2021-11-01 69900 106500 408500 874000 ## 739 2021-11-02 71500 107500 410000 874000 ## 740 2021-11-03 70400 105500 402500 874000 ## 741 2021-11-04 70600 106000 411500 865000 ## 742 2021-11-05 70600 107000 409000 856000 티커가 저장된 csv 파일을 불러온 후 티커를 6자리로 맞춰줍니다. 빈 리스트인 price_list를 생성합니다. for loop 구문을 이용해 종목별 가격 데이터를 불러온 후 as.xts()를 통해 시계열 형태로 데이터를 변경하고 리스트에 저장합니다. do.call() 함수를 통해 리스트를 열 형태로 묶습니다. 간혹 결측치가 발생할 수 있으므로, na.locf() 함수를 통해 결측치에는 전일 데이터를 사용합니다. 행 이름을 각 종목의 티커로 변경합니다. 해당 작업을 통해 개별 csv 파일로 흩어져 있던 가격 데이터가 하나의 데이터로 묶이게 됩니다. write.csv(data.frame(price_list), &#39;data/KOR_price.csv&#39;) 마지막으로 해당 데이터를 data 폴더에 KOR_price.csv 파일로 저장합니다. 시계열 형태 그대로 저장하면 인덱스가 삭제되므로 데이터 프레임 형태로 변경한 후 저장해야 합니다. 7.2 재무제표 정리하기 재무제표는 data/KOR_fs 폴더 내 티커_fs.csv 파일로 저장되어 있습니다. 주가는 하나의 열로 이루어져 있어 데이터를 정리하는 것이 간단했지만, 재무제표는 각 종목별 재무 항목이 모두 달라 정리하기 번거롭습니다. library(stringr) library(magrittr) library(dplyr) KOR_ticker = read.csv(&#39;data/KOR_ticker.csv&#39;, row.names = 1) KOR_ticker$&#39;종목코드&#39; = str_pad(KOR_ticker$&#39;종목코드&#39;, 6, side = c(&#39;left&#39;), pad = &#39;0&#39;) data_fs = list() for (i in 1 : nrow(KOR_ticker)){ name = KOR_ticker[i, &#39;종목코드&#39;] data_fs[[i]] = read.csv(paste0(&#39;data/KOR_fs/&#39;, name, &#39;_fs.csv&#39;), row.names = 1) } 위와 동일하게 티커 데이터를 읽어옵니다. 이를 바탕으로 종목별 재무제표 데이터를 읽어온 후 리스트에 저장합니다. fs_item = data_fs[[1]] %&gt;% rownames() length(fs_item) ## [1] 237 print(head(fs_item)) ## [1] &quot;매출액&quot; &quot;매출원가&quot; &quot;매출총이익&quot; &quot;판매비와관리비&quot; ## [5] &quot;인건비&quot; &quot;유무형자산상각비&quot; 다음으로 재무제표 항목의 기준을 정해줄 필요가 있습니다. 재무제표 작성 항목은 각 업종별로 상이하므로, 이를 모두 고려하면 지나치게 데이터가 커지게 됩니다. 또한 퀀트 투자에는 일반적이고 공통적인 항목을 주로 사용하므로 대표적인 재무 항목을 정해 이를 기준으로 데이터를 정리해도 충분합니다. 따라서 기준점으로 첫 번째 리스트, 즉 삼성전자의 재무 항목을 선택하며, 총 237개 재무 항목이 있습니다. 해당 기준을 바탕으로 재무제표 데이터를 정리하며, 전체 항목에 대한 정리 이전에 간단한 예시로 첫 번째 항목인 매출액 기준 데이터 정리를 살펴보겠습니다. select_fs = lapply(data_fs, function(x) { # 해당 항목이 있을시 데이터를 선택 if ( &#39;매출액&#39; %in% rownames(x) ) { x[which(rownames(x) == &#39;매출액&#39;), ] # 해당 항목이 존재하지 않을 시, NA로 된 데이터프레임 생성 } else { data.frame(NA) } }) select_fs = bind_rows(select_fs) print(head(select_fs)) ## X2018.12 X2019.12 X2020.12 NA. ## 매출액...1 2437714 2304009 2368070 NA ## 매출액...2 404451 269907 319004 NA ## 매출액...3 55869 43562 53041 NA ## 매출액...4 5358 7016 11648 NA ## 매출액...5 24170 30701 41568 NA ## 매출액...6 281830 273531 300765 NA 먼저 lapply() 함수를 이용해 모든 재무 데이터가 들어 있는 data_fs 데이터를 대상으로 함수를 적용합니다. %in% 함수를 통해 만일 매출액이라는 항목이 행 이름에 있으면 해당 부분의 데이터를 select_fs 리스트에 저장하고, 해당 항목이 없는 경우 NA로 이루어진 데이터 프레임을 저장합니다. 그 후, dplyr 패키지의 bind_rows() 함수를 이용해 리스트 내 데이터들을 행으로 묶어줍니다. rbind()에서는 리스트 형태를 테이블로 묶으려면 모든 데이터의 열 개수가 동일해야 하는 반면, bind_rows()에서는 열 개수가 다를 경우 나머지 부분을 NA로 처리해 합쳐주는 장점이 있습니다. 합쳐진 데이터를 살펴보면, 먼저 열 이름이 . 혹은 NA.인 부분이 있습니다. 이는 매출액 항목이 없는 종목의 경우 NA 데이터 프레임을 저장해 생긴 결과입니다. 또한 연도가 순서대로 저장되지 않은 경우가 있습니다. 이 두 가지를 고려해 데이터를 클렌징합니다. select_fs = select_fs[!colnames(select_fs) %in% c(&#39;.&#39;, &#39;NA.&#39;)] select_fs = select_fs[, order(names(select_fs))] rownames(select_fs) = KOR_ticker[, &#39;종목코드&#39;] print(head(select_fs)) ## X2018.12 X2019.12 X2020.12 ## 5930 2437714 2304009 2368070 ## 660 404451 269907 319004 ## 35420 55869 43562 53041 ## 207940 5358 7016 11648 ## 35720 24170 30701 41568 ## 51910 281830 273531 300765 !와 %in% 함수를 이용해, 열 이름에 . 혹은 NA.가 들어가지 않은 열만 선택합니다. order() 함수를 이용해 열 이름의 연도별 순서를 구한 후 이를 바탕으로 열을 다시 정리합니다. 행 이름을 티커들로 변경합니다. 해당 과정을 통해 전 종목의 매출액 데이터가 연도별로 정리되었습니다. for loop 구문을 이용해 모든 재무 항목에 대한 데이터를 정리하는 방법은 다음과 같습니다. fs_list = list() for (i in 1 : length(fs_item)) { select_fs = lapply(data_fs, function(x) { # 해당 항목이 있을시 데이터를 선택 if ( fs_item[i] %in% rownames(x) ) { x[which(rownames(x) == fs_item[i]), ] # 해당 항목이 존재하지 않을 시, NA로 된 데이터프레임 생성 } else { data.frame(NA) } }) # 리스트 데이터를 행으로 묶어줌 select_fs = bind_rows(select_fs) # 열이름이 &#39;.&#39; 혹은 &#39;NA.&#39;인 지점은 삭제 (NA 데이터) select_fs = select_fs[!colnames(select_fs) %in% c(&#39;.&#39;, &#39;NA.&#39;)] # 연도 순별로 정리 select_fs = select_fs[, order(names(select_fs))] # 행이름을 티커로 변경 rownames(select_fs) = KOR_ticker[, &#39;종목코드&#39;] # 리스트에 최종 저장 fs_list[[i]] = select_fs } # 리스트 이름을 재무 항목으로 변경 names(fs_list) = fs_item 위 과정을 거치면 fs_list에 총 237개 리스트가 생성됩니다. 각 리스트에는 해당 재무 항목에 대한 전 종목의 연도별 데이터가 정리되어 있습니다. saveRDS(fs_list, &#39;data/KOR_fs.Rds&#39;) 마지막으로 해당 데이터를 data 폴더 내에 저장합니다. 리스트 형태 그대로 저장하기 위해 saveRDS() 함수를 이용해 KOR_fs.Rds 파일로 저장합니다. Rds 형식은 파일을 더블 클릭한 후 연결 프로그램을 R Studio로 설정해 파일을 불러올 수 있습니다. 혹은 readRDS() 함수를 이용해 파일을 읽어올 수도 있습니다. 7.3 가치지표 정리하기 가치지표는 data/KOR_value 폴더 내 티커_value.csv 파일로 저장되어 있습니다. 재무제표를 정리하는 방법과 거의 동일합니다. library(stringr) library(magrittr) library(dplyr) KOR_ticker = read.csv(&#39;data/KOR_ticker.csv&#39;, row.names = 1) KOR_ticker$&#39;종목코드&#39; = str_pad(KOR_ticker$&#39;종목코드&#39;, 6, side = c(&#39;left&#39;), pad = &#39;0&#39;) data_value = list() for (i in 1 : nrow(KOR_ticker)){ name = KOR_ticker[i, &#39;종목코드&#39;] data_value[[i]] = read.csv(paste0(&#39;data/KOR_value/&#39;, name, &#39;_value.csv&#39;), row.names = 1) %&gt;% t() %&gt;% data.frame() } 먼저 티커에 해당하는 파일을 불러온 후 for loop 구문을 통해 가치지표 데이터를 data_value 리스트에 저장합니다. 단, csv 내에 데이터가 7.1와 같이 행의 형태로 저장되어 있으므로, t() 함수를 이용해 열의 형태로 바꿔주며, 데이터 프레임 형태로 저장합니다. 표 7.1: 가치지표의 저장 예시 value x PER Number 1 PBR Number 2 PCR Number 3 PSR Number 4 data_value = bind_rows(data_value) print(head(data_value)) ## PER PBR PCR PSR X1 ## x...1 16.15 1.527 6.456 1.780 NA ## x...2 16.23 1.487 6.266 2.419 NA ## x...3 67.45 8.188 46.707 12.744 NA ## x...4 237.48 12.445 283.190 49.135 NA ## x...5 372.09 7.795 59.620 13.928 NA ## x...6 108.79 2.968 9.548 1.854 NA bind_rows() 함수를 이용하여 리스트 내 데이터들을 행으로 묶어준 후 데이터를 확인해보면 PER, PBR, PCR, PSR 열 외에 불필요한 NA로 이루어진 열이 존재합니다. 해당 열을 삭제한 후 정리 작업을 하겠습니다. data_value = data_value[colnames(data_value) %in% c(&#39;PER&#39;, &#39;PBR&#39;, &#39;PCR&#39;, &#39;PSR&#39;)] data_value = data_value %&gt;% mutate_all(list(~na_if(., Inf))) rownames(data_value) = KOR_ticker[, &#39;종목코드&#39;] print(head(data_value)) ## PER PBR PCR PSR ## 005930 16.15 1.527 6.456 1.780 ## 000660 16.23 1.487 6.266 2.419 ## 035420 67.45 8.188 46.707 12.744 ## 207940 237.48 12.445 283.190 49.135 ## 035720 372.09 7.795 59.620 13.928 ## 051910 108.79 2.968 9.548 1.854 write.csv(data_value, &#39;data/KOR_value.csv&#39;) 열 이름이 가치지표에 해당하는 부분만 선택합니다. 일부 종목은 재무 데이터가 0으로 표기되어 가치지표가 Inf로 계산되는 경우가 있습니다. mutate_all() 내에 na_if() 함수를 이용해 Inf 데이터를 NA로 변경합니다. 행 이름을 티커들로 변경합니다. data 폴더 내에 KOR_value.csv 파일로 저장합니다. "],["데이터-분석-및-시각화하기.html", "Chapter 8 데이터 분석 및 시각화하기 8.1 종목정보 데이터 분석 8.2 ggplot() 기초 8.3 종목정보 시각화 8.4 주가 및 수익률 시각화", " Chapter 8 데이터 분석 및 시각화하기 데이터 수집 및 정리가 끝났다면, 내가 가지고 있는 데이터가 어떠한 특성을 가지고 있는지에 대한 분석 및 시각화 과정, 즉 탐색적 데이터 분석(Exploratory Data Analysis)을 할 필요가 있습니다. 이 과정을 통해 데이터를 더 잘 이해할 수 있으며, 극단치나 결측치 등 데이터가 가지고 있는 잠재적인 문제를 발견하고 이를 어떻게 처리할지 고민할 수 있습니다. 이 CHAPTER에서는 dplyr 패키지를 이용한 데이터 분석과 ggplot2 패키지를 이용한 데이터 시각화에 대해 알아보겠습니다. 8.1 종목정보 데이터 분석 먼저 거래소를 통해 수집한 산업별 현황과 개별지표를 정리한 파일, WICS 기준 섹터 지표를 정리한 파일을 통해 국내 상장종목의 데이터를 분석해보겠습니다. library(stringr) KOR_ticker = read.csv(&#39;data/KOR_ticker.csv&#39;, row.names = 1, stringsAsFactors = FALSE) KOR_sector = read.csv(&#39;data/KOR_sector.csv&#39;, row.names = 1, stringsAsFactors = FALSE) KOR_ticker$&#39;종목코드&#39; = str_pad(KOR_ticker$&#39;종목코드&#39;, 6,&#39;left&#39;, 0) KOR_sector$&#39;CMP_CD&#39; = str_pad(KOR_sector$&#39;CMP_CD&#39;, 6, &#39;left&#39;, 0) 각 파일을 불러온 후 티커에 해당하는 종목코드와 CMP_CD 열을 6자리 숫자로 만들어줍니다. 이제 dplyr 패키지의 여러 함수들을 이용해 데이터를 분석해보겠습니다. 해당 패키지는 데이터 처리에 특화된 패키지이며, C++로 작성되어 매우 빠른 처리 속도를 자랑합니다. 또한 문법이 SQL과 매우 비슷해 함수의 내용을 직관적으로 이해할 수 있습니다. 8.1.1 *_join: 데이터 합치기 두 테이블을 하나로 합치기 위해 *_join() 함수를 이용합니다. 해당 함수는 기존에 살펴본 merge() 함수와 동일하며, 합치는 방법은 그림 8.1과 표 8.1과 같이 크게 네가지 종류가 있습니다. 그림 8.1: *_ join() 함수의 종류 표 8.1: join 함수의 종류 함수 내용 inner_join() 교집합 full_join() 합집합 left_join() 좌측 기준 right_join() 우측 기준 이 중 거래소 티커 기준으로 데이터를 맞추기 위해 left_join() 함수를 사용해 두 데이터를 합치겠습니다. library(dplyr) data_market = left_join(KOR_ticker, KOR_sector, by = c(&#39;종목코드&#39; = &#39;CMP_CD&#39;, &#39;종목명&#39; = &#39;CMP_KOR&#39;)) head(data_market) ## 종목코드 종목명 종가 대비 등락률 시장구분 업종명 시가총액 ## 1 005930 삼성전자 70400 -1100 -1.54 KOSPI 전기전자 4.203e+14 ## 2 000660 SK하이닉스 105500 -2000 -1.86 KOSPI 전기전자 7.680e+13 ## 3 035420 NAVER 402500 -7500 -1.83 KOSPI 서비스업 6.612e+13 ## 4 207940 삼성바이오로직스 874000 0 0.00 KOSPI 의약품 5.783e+13 ## 5 035720 카카오 124500 -3500 -2.73 KOSPI 서비스업 5.545e+13 ## 6 051910 LG화학 784000 -47000 -5.66 KOSPI 화학 5.534e+13 ## EPS PER BPS PBR 주당배당금 배당수익률 IDX_CD IDX_NM_KOR ## 1 3841 18.33 39406 1.79 2994 4.25 G45 WICS IT ## 2 6952 15.18 71275 1.48 1170 1.11 G45 WICS IT ## 3 6877 58.53 44850 8.97 402 0.10 G50 WICS 커뮤니케이션서비스 ## 4 3642 239.98 69505 12.57 0 0.00 G35 WICS 건강관리 ## 5 369 337.40 14286 8.71 30 0.02 G50 WICS 커뮤니케이션서비스 ## 6 6666 117.61 230440 3.40 10000 1.28 G15 WICS 소재 ## ALL_MKT_VAL MKT_VAL WGT S_WGT CAL_WGT SEC_CD SEC_NM_KOR SEQ TOP60 ## 1 551957421 315204519 57.11 57.11 1 G45 IT 1 2 ## 2 551957421 56835145 10.30 67.40 1 G45 IT 2 2 ## 3 180662521 51570493 28.55 28.55 1 G50 커뮤니케이션서비스 1 4 ## 4 136785726 14457053 10.57 26.66 1 G35 건강관리 2 27 ## 5 180662521 38258764 21.18 49.72 1 G50 커뮤니케이션서비스 2 4 ## 6 122898119 35420414 28.82 28.82 1 G15 소재 1 8 ## APT_SHR_CNT ## 1 4477336913 ## 2 538721750 ## 3 128125448 ## 4 16541250 ## 5 307299311 ## 6 45179100 left_join() 함수를 이용해 KOR_ticker와 KOR_sector 데이터를 합쳐줍니다. by 인자는 데이터를 합치는 기준점을 의미하며, x 데이터(KOR_ticker)의 종목코드와 y 데이터(KOR_sector)의 CMP_CD는 같음을, x 데이터의 종목명과 y 데이터의 CMP_KOR는 같음을 정의합니다. 8.1.2 glimpse(): 데이터 구조 확인하기 glimpse(data_market) ## Rows: 2,237 ## Columns: 26 ## $ 종목코드 &lt;chr&gt; &quot;005930&quot;, &quot;000660&quot;, &quot;035420&quot;, &quot;2~ ## $ 종목명 &lt;chr&gt; &quot;삼성전자&quot;, &quot;SK하이닉스&quot;, &quot;NAVE~ ## $ 종가 &lt;dbl&gt; 70400, 105500, 402500, 874000,~ ## $ 대비 &lt;int&gt; -1100, -2000, -7500, 0, -3500,~ ## $ 등락률 &lt;dbl&gt; -1.54, -1.86, -1.83, 0.00, -2.7~ ## $ 시장구분 &lt;chr&gt; &quot;KOSPI&quot;, &quot;KOSPI&quot;, &quot;KOSPI&quot;, &quot;KOSP~ ## $ 업종명 &lt;chr&gt; &quot;전기전자&quot;, &quot;전기전자&quot;, &quot;서비스~ ## $ 시가총액 &lt;dbl&gt; 4.203e+14, 7.680e+13, 6.612e+13,~ ## $ EPS &lt;int&gt; 3841, 6952, 6877, 3642, 369,~ ## $ PER &lt;dbl&gt; 18.33, 15.18, 58.53, 239.98,~ ## $ BPS &lt;int&gt; 39406, 71275, 44850, 69505, ~ ## $ PBR &lt;dbl&gt; 1.79, 1.48, 8.97, 12.57, 8.7~ ## $ 주당배당금 &lt;int&gt; 2994, 1170, 402, 0, 30, 10000, 10~ ## $ 배당수익률 &lt;dbl&gt; 4.25, 1.11, 0.10, 0.00, 0.02, 1.2~ ## $ IDX_CD &lt;chr&gt; &quot;G45&quot;, &quot;G45&quot;, &quot;G50&quot;, &quot;G35&quot;, ~ ## $ IDX_NM_KOR &lt;chr&gt; &quot;WICS IT&quot;, &quot;WICS IT&quot;, &quot;WICS ~ ## $ ALL_MKT_VAL &lt;int&gt; 551957421, 551957421, 180662~ ## $ MKT_VAL &lt;int&gt; 315204519, 56835145, 5157049~ ## $ WGT &lt;dbl&gt; 57.11, 10.30, 28.55, 10.57, ~ ## $ S_WGT &lt;dbl&gt; 57.11, 67.40, 28.55, 26.66, ~ ## $ CAL_WGT &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1~ ## $ SEC_CD &lt;chr&gt; &quot;G45&quot;, &quot;G45&quot;, &quot;G50&quot;, &quot;G35&quot;, ~ ## $ SEC_NM_KOR &lt;chr&gt; &quot;IT&quot;, &quot;IT&quot;, &quot;커뮤니케이션서~ ## $ SEQ &lt;int&gt; 1, 2, 1, 2, 2, 1, 3, 1, 2, 1~ ## $ TOP60 &lt;int&gt; 2, 2, 4, 27, 4, 8, 2, 9, 9, ~ ## $ APT_SHR_CNT &lt;dbl&gt; 4477336913, 538721750, 12812~ glimpse() 함수는 데이터 내용, 구조, 형식을 확인하는 함수입니다. 기본 함수인 str()과 그 역할은 비슷하지만, tidy 형태로 결과물이 훨씬 깔끔하게 출력됩니다. 총 관측값 및 열의 개수, 각 열의 이름과 데이터 형식, 앞부분 데이터를 확인할 수 있습니다. 8.1.3 rename(): 열 이름 바꾸기 head(names(data_market), 15) ## [1] &quot;종목코드&quot; &quot;종목명&quot; &quot;종가&quot; &quot;대비&quot; &quot;등락률&quot; ## [6] &quot;시장구분&quot; &quot;업종명&quot; &quot;시가총액&quot; &quot;EPS&quot; &quot;PER&quot; ## [11] &quot;BPS&quot; &quot;PBR&quot; &quot;주당배당금&quot; &quot;배당수익률&quot; &quot;IDX_CD&quot; data_market = data_market %&gt;% rename(`배당수익률(%)` = `배당수익률`) head(names(data_market), 15) ## [1] &quot;종목코드&quot; &quot;종목명&quot; &quot;종가&quot; &quot;대비&quot; ## [5] &quot;등락률&quot; &quot;시장구분&quot; &quot;업종명&quot; &quot;시가총액&quot; ## [9] &quot;EPS&quot; &quot;PER&quot; &quot;BPS&quot; &quot;PBR&quot; ## [13] &quot;주당배당금&quot; &quot;배당수익률(%)&quot; &quot;IDX_CD&quot; rename() 함수는 열 이름을 바꾸는 함수로서, rename(tbl, new_name = old_name) 형태로 입력합니다. 위의 경우 배당수익률 열 이름이 배당수익률(%)로 변경되었습니다. 8.1.4 distinct(): 고유한 값 확인 data_market %&gt;% distinct(SEC_NM_KOR) %&gt;% c() ## $SEC_NM_KOR ## [1] &quot;IT&quot; &quot;커뮤니케이션서비스&quot; &quot;건강관리&quot; ## [4] &quot;소재&quot; &quot;경기관련소비재&quot; &quot;금융&quot; ## [7] NA &quot;에너지&quot; &quot;산업재&quot; ## [10] &quot;유틸리티&quot; &quot;필수소비재&quot; distinct() 함수는 고유한 값을 반환하며, 기본 함수 중 unique()와 동일한 기능을 합니다. 데이터의 섹터 정보를 확인해보면, WICS 기준 10개 섹터 및 섹터 정보가 없는 종목인 NA 값이 있습니다. 8.1.5 select(): 원하는 열만 선택 data_market %&gt;% select(`종목명`) %&gt;% head() ## 종목명 ## 1 삼성전자 ## 2 SK하이닉스 ## 3 NAVER ## 4 삼성바이오로직스 ## 5 카카오 ## 6 LG화학 data_market %&gt;% select(`종목명`, `PBR`, `SEC_NM_KOR`) %&gt;% head() ## 종목명 PBR SEC_NM_KOR ## 1 삼성전자 1.79 IT ## 2 SK하이닉스 1.48 IT ## 3 NAVER 8.97 커뮤니케이션서비스 ## 4 삼성바이오로직스 12.57 건강관리 ## 5 카카오 8.71 커뮤니케이션서비스 ## 6 LG화학 3.40 소재 select() 함수는 원하는 열을 선택해주는 함수이며, 원하는 열 이름을 입력하면 됩니다. 하나의 열뿐만 아니라 다수의 열을 입력하면 해당 열들이 선택됩니다. data_market %&gt;% select(starts_with(&#39;시&#39;)) %&gt;% head() ## 시장구분 시가총액 ## 1 KOSPI 4.203e+14 ## 2 KOSPI 7.680e+13 ## 3 KOSPI 6.612e+13 ## 4 KOSPI 5.783e+13 ## 5 KOSPI 5.545e+13 ## 6 KOSPI 5.534e+13 data_market %&gt;% select(ends_with(&#39;R&#39;)) %&gt;% head() ## PER PBR IDX_NM_KOR SEC_NM_KOR ## 1 18.33 1.79 WICS IT IT ## 2 15.18 1.48 WICS IT IT ## 3 58.53 8.97 WICS 커뮤니케이션서비스 커뮤니케이션서비스 ## 4 239.98 12.57 WICS 건강관리 건강관리 ## 5 337.40 8.71 WICS 커뮤니케이션서비스 커뮤니케이션서비스 ## 6 117.61 3.40 WICS 소재 소재 data_market %&gt;% select(contains(&#39;가&#39;)) %&gt;% head() ## 종가 시가총액 ## 1 70400 4.203e+14 ## 2 105500 7.680e+13 ## 3 402500 6.612e+13 ## 4 874000 5.783e+13 ## 5 124500 5.545e+13 ## 6 784000 5.534e+13 해당 함수는 다양한 응용 기능도 제공합니다. starts_with()는 특정 문자로 시작하는 열들을 선택하고, ends_with()는 특정 문자로 끝나는 열들을 선택하며, contains()는 특정 문자가 포함되는 열들을 선택합니다. 8.1.6 mutate(): 열 생성 및 데이터 변형 data_market = data_market %&gt;% mutate(`PBR` = as.numeric(PBR), `PER` = as.numeric(PER), `ROE` = PBR / PER, `ROE` = round(ROE, 4), `size` = ifelse(`시가총액` &gt;= median(`시가총액`, na.rm = TRUE), &#39;big&#39;, &#39;small&#39;) ) data_market %&gt;% select(`종목명`, `ROE`, `size`) %&gt;% head() ## 종목명 ROE size ## 1 삼성전자 0.0977 big ## 2 SK하이닉스 0.0975 big ## 3 NAVER 0.1533 big ## 4 삼성바이오로직스 0.0524 big ## 5 카카오 0.0258 big ## 6 LG화학 0.0289 big mutate() 함수는 원하는 형태로 열을 생성하거나 변형하는 함수입니다. 위 예제에 서는 먼저 PBR과 PER 열을 as.numeric() 함수를 통해 숫자형으로 변경한 후 PBR을 PER로 나눈 값을 ROE 열에 생성합니다. 그 후 round() 함수를 통해 ROE 값을 반올림하며, ifelse() 함수를 통해 시가총액의 중앙값보다 큰 기업은 big, 아닐 경우 small임을 size 열에 저장합니다. 이 외에도 mutate_*() 계열 함수에는 mutate_all(), mutate_if(), mutate_at() 처럼 각 상황에 맞게 쓸 수 있는 다양한 함수들이 있습니다. 8.1.7 filter(): 조건을 충족하는 행 선택 data_market %&gt;% select(`종목명`, `PBR`) %&gt;% filter(`PBR` &lt; 1) %&gt;% head() ## 종목명 PBR ## 1 현대차 0.83 ## 2 POSCO 0.59 ## 3 현대모비스 0.72 ## 4 KB금융 0.54 ## 5 삼성물산 0.73 ## 6 신한지주 0.46 data_market %&gt;% select(`종목명`, `PBR`, `PER`, `ROE`) %&gt;% filter(PBR &lt; 1 &amp; PER &lt; 20 &amp; ROE &gt; 0.1 ) %&gt;% head() ## 종목명 PBR PER ROE ## 1 미래에셋증권 0.75 7.21 0.1040 ## 2 한국금융지주 0.96 5.91 0.1624 ## 3 DB손해보험 0.64 6.36 0.1006 ## 4 메리츠증권 0.76 5.43 0.1400 ## 5 KCC 0.58 4.39 0.1321 ## 6 키움증권 0.94 3.48 0.2701 filter() 함수는 조건을 충족하는 부분의 데이터를 반환하는 함수입니다. 첫 번째 예제와 같이 PBR이 1 미만인 단일 조건을 입력할 수도 있으며, 두 번째 예제와 같이 PBR 1 미만, PER 20 미만, ROE 0.1 초과 등 복수 조건을 입력할 수도 있습니다. 8.1.8 summarize(): 요약 통곗값 계산 data_market %&gt;% summarize(PBR_max = max(PBR, na.rm = TRUE), PBR_min = min(PBR, na.rm = TRUE)) ## PBR_max PBR_min ## 1 680 0.15 summarize() 혹은 summarise() 함수는 원하는 요약 통곗값을 계산합니다. PBR_max는 PBR 열에서 최댓값을, PBR_min은 최솟값을 계산해줍니다. 8.1.9 arrange(): 데이터 정렬 data_market %&gt;% select(PBR) %&gt;% arrange(PBR) %&gt;% head(5) ## PBR ## 1 0.15 ## 2 0.19 ## 3 0.20 ## 4 0.21 ## 5 0.24 data_market %&gt;% select(ROE) %&gt;% arrange(desc(ROE)) %&gt;% head(5) ## ROE ## 1 2.5574 ## 2 2.4804 ## 3 2.1714 ## 4 1.0249 ## 5 0.8228 arrange() 함수는 선택한 열을 기준으로 데이터를 정렬해주며, 오름차순으로 정렬합니다. 내림차순으로 데이터를 정렬하려면 arrange() 내에 desc() 함수를 추가로 입력해주면 됩니다. 8.1.10 row_number(): 순위 계산 data_market %&gt;% mutate(PBR_rank = row_number(PBR)) %&gt;% select(`종목명`, PBR, PBR_rank) %&gt;% arrange(PBR) %&gt;% head(5) ## 종목명 PBR PBR_rank ## 1 지스마트글로벌 0.15 1 ## 2 세원정공 0.19 2 ## 3 경동인베스트 0.20 3 ## 4 한국전력 0.21 4 ## 5 한화생명 0.24 5 data_market %&gt;% mutate(ROE_rank = row_number(desc(ROE))) %&gt;% select(`종목명`, ROE, ROE_rank) %&gt;% arrange(desc(ROE)) %&gt;% head(5) ## 종목명 ROE ROE_rank ## 1 샘씨엔에스 2.5574 1 ## 2 이지바이오 2.4804 2 ## 3 솔브레인홀딩스 2.1714 3 ## 4 한컴라이프케어 1.0249 4 ## 5 에스디바이오센서 0.8228 5 row_number() 함수는 선택한 열의 순위를 구해줍니다. 기본적으로 오름차순으로 순위를 구하며, 내림차순으로 순위를 구하려면 desc() 함수를 추가해주면 됩니다. 순위를 구하는 함수는 이 외에도 min_rank(), dense_rank(), percent_rank()가 있습니다. 8.1.11 ntile(): 분위수 계산 data_market %&gt;% mutate(PBR_tile = ntile(PBR, n = 5)) %&gt;% select(PBR, PBR_tile) %&gt;% head() ## PBR PBR_tile ## 1 1.79 3 ## 2 1.48 3 ## 3 8.97 5 ## 4 12.57 5 ## 5 8.71 5 ## 6 3.40 4 ntile() 함수는 분위수를 계산해주며, n 인자를 통해 몇 분위로 나눌지 선택할 수 있습니다. 해당 함수 역시 오름차순으로 분위수를 나눕니다. 8.1.12 group_by(): 그룹별로 데이터를 묶기 data_market %&gt;% group_by(`SEC_NM_KOR`) %&gt;% summarize(n()) ## # A tibble: 11 x 2 ## SEC_NM_KOR `n()` ## &lt;chr&gt; &lt;int&gt; ## 1 IT 579 ## 2 건강관리 288 ## 3 경기관련소비재 342 ## 4 금융 79 ## 5 산업재 349 ## 6 소재 228 ## 7 에너지 28 ## 8 유틸리티 19 ## 9 커뮤니케이션서비스 116 ## 10 필수소비재 103 ## 11 &lt;NA&gt; 106 group_by() 함수는 선택한 열 중 동일한 데이터를 기준으로 데이터를 묶어줍니다. 위 예제에서는 섹터를 나타내는 SEC_NM_KOR 기준으로 데이터를 묶었으며, n() 함수를 통해 해당 그룹 내 데이터의 개수를 구할 수 있습니다. data_market %&gt;% group_by(`SEC_NM_KOR`) %&gt;% summarize(PBR_median = median(PBR, na.rm = TRUE)) %&gt;% arrange(PBR_median) ## # A tibble: 11 x 2 ## SEC_NM_KOR PBR_median ## &lt;chr&gt; &lt;dbl&gt; ## 1 유틸리티 0.65 ## 2 금융 0.745 ## 3 필수소비재 1.05 ## 4 산업재 1.21 ## 5 소재 1.24 ## 6 경기관련소비재 1.33 ## 7 에너지 1.46 ## 8 IT 2.07 ## 9 &lt;NA&gt; 2.15 ## 10 커뮤니케이션서비스 2.9 ## 11 건강관리 3.12 위 예제는 섹터를 기준으로 데이터를 묶은 후 summarize()를 통해 각 섹터에 속하는 종목의 PBR 중앙값을 구한 후 정렬했습니다. data_market %&gt;% group_by(`시장구분`, `SEC_NM_KOR`) %&gt;% summarize(PBR_median = median(PBR, na.rm = TRUE)) %&gt;% arrange(PBR_median) ## # A tibble: 22 x 3 ## # Groups: 시장구분 [2] ## 시장구분 SEC_NM_KOR PBR_median ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 KOSPI 금융 0.62 ## 2 KOSPI 유틸리티 0.65 ## 3 KOSPI 필수소비재 0.825 ## 4 KOSPI 에너지 0.87 ## 5 KOSPI 경기관련소비재 1.02 ## 6 KOSPI 산업재 1.02 ## 7 KOSPI 소재 1.07 ## 8 KOSDAQ 유틸리티 1.34 ## 9 KOSDAQ 소재 1.42 ## 10 KOSDAQ 산업재 1.45 ## # ... with 12 more rows 위 예제는 시장과 섹터를 기준으로 데이터를 그룹화한 후 각 그룹별 PBR 중앙값을 구했습니다. 이처럼 그룹은 하나만이 아닌 원하는 만큼 나눌 수 있습니다. 8.2 ggplot() 기초 R에서 기본적으로 제공하는 plot() 함수를 이용해도 시각화가 충분히 가능합니다. 그러나 데이터 과학자들에게 가장 많이 사랑받는 패키지 중 하나인 ggplot2 패키지의 ggplot() 함수를 사용하면 그림을 훨씬 아름답게 표현할 수 있으며 다양한 기능들을 매우 쉽게 사용할 수도 있습니다. ggplot() 함수는 플러스(+) 기호를 사용한다는 점과 문법이 다소 어색하다는 점 때문에 처음에 배우기가 쉽지는 않습니다. 그러나 해당 패키지의 근본이 되는 철학인 그래픽 문법(The Grammar of Graphics)를 이해하고 조금만 연습해본다면, 충분히 손쉽게 사용이 가능합니다. 그래픽 문법(Grammar of Graphics)은 릴랜드 윌킨스(Leland Wilkinson)의 책 The Grammar of Graphics(Wilkinson 2012)에서 따온 것으로써, 데이터를 어떻게 표현할 것인지에 대한 내용입니다. 문법은 언어의 표현을 풍부하게 만든다. 단어만 있고 문법이 없는 언어가 있다면(단어 = 문장), 오직 단어의 갯수만큼만 생각을 표현할 수 있다. 문장 내에서 단어가 어떻게 구성되는 지를 규정함으로써, 문법은 언어의 범위를 확장한다. — Leland Wilkinson, 《The Grammar of Graphics》 그래픽 문법에서 말하는 요소는 다음과 같습니다. Data: 시각화에 사용될 데이터 Aesthetics: 데이터를 나타내는 시각적인 요소(x축, y축, 사이즈, 색깔, 모양 등) Geometrics: 데이터를 나타내는 도형 Facets: 하위 집합으로 분할하여 시각화 Statistics: 통계값을 표현 Coordinates: 데이터를 표현 할 이차원 좌표계 Theme: 그래프를 꾸밈 그림 8.2: The Grammar of Graphics ggplot2 패키지의 앞글자가 gg인 것에서 알 수 있듯이, 해당 패키지는 그래픽 문법을 토대로 시각화를 표현하며, 전반적인 시각화의 순서는 그래픽 문법의 순서와 같습니다. ggplot2 패키지의 특징은 각 요소를 연결할 때 플러스(+) 기호를 사용한다는 점이며, 이는 그래픽 문법의 순서에 따라 요소들을 쌓아나간 후 최종적인 그래픽을 완성하는 패키지의 특성 때문입니다. 본 책에서 설명하는 것 외에도 다양한 예제와 함수가 궁금하신 분은 아래 링크를 참조하시길 바랍니다. http://r-statistics.co/ggplot2-Tutorial-With-R.html https://ggplot2.tidyverse.org/reference/ 8.2.1 diamonds 데이터셋 ggplot2 패키지에는 데이터분석 및 시각화 연습을 위한 각종 데이터셋이 있으며, 그 중에서도 diamonds 데이터셋이 널리 사용됩니다. 먼저 해당 데이터를 불러오도록 하겠습니다. library(ggplot2) data(diamonds) head(diamonds) ## # A tibble: 6 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 ## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 ## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 ## 4 0.29 Premium I VS2 62.4 58 334 4.2 4.23 2.63 ## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 ## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 데이터의 각 변수는 다음과 같습니다. carat: 다이아몬드 무게 cut: 컷팅의 가치 color: 다이아몬스 색상 clarity: 깨끗한 정도 depth: 깊이 비율, z / mean(x, y) table: 가장 넓은 부분의 너비 대비 다이아몬드 꼭대기의 너비 price: 가격 x: 길이 y: 너비 z: 깊이 8.2.2 Data, Aesthetics, Geometrics Data는 사용될 데이터이며, Aesthetics는 x축, y축, 사이즈 등 시각적인 요소를 의미합니다. ggplot(data = diamonds, aes(x = carat, y = price)) ggplot() 함수 내부의 data에 diamonds를 지정해줍니다. aes() 함수를 통해 데이터를 매핑해주며 x축에 carat을, y축에 price를 지정해줍니다. x축과 y축에 우리가 매핑한 carat과 price가 표현되었지만, 어떠한 모양(Geometrics)으로 시각화를 할지 정의하지 않았으므로 빈 그림이 생성됩니다. 다음으로 Geometrics을 통해 데이터를 그림으로 표현해주도록 하겠습니다. ggplot(data = diamonds, aes(x = carat, y = price)) + geom_point() 사전에 정의된 Data와 Aesthetics 위에, 플러스(+) 기호를 통해 geom_point() 함수를 입력하여 산점도가 표현되었습니다. geom은 Geometrics의 약자이며, 이처럼 geom_*() 함수를 통해 원하는 형태로 시각화를 할 수 있습니다. 일반적으로 Data는 ggplot() 함수 내에서 정의하기 보다는, dplyr 패키지의 함수들을 이용하여 데이터를 가공한 후 파이프 오퍼레이터를 통해 연결합니다. 이에 대해서는 나중에 다시 다루도록 하겠습니다. library(magrittr) diamonds %&gt;% ggplot(aes(x = carat, y = price)) + geom_point(aes(color = cut)) diamonds 데이터를 파이프 오퍼레이터(%&gt;%)로 이을 경우 그대로 시각화가 가능하며, ggplot() 함수 내에 데이터를 입력하지 않아도 됩니다. geom_point() 내부에서 aes()를 통해 점의 색깔을 매핑해줄 수 있습니다. color = cut을 지정하여 cut에 따라 점의 색깔이 다르게 표현하였습니다. 이 외에도 shape, size를 통해 모양과 크기를 각각 다르게 표현할 수 있습니다. 8.2.3 Facets Facets은 여러 집합을 하나의 그림에 표현하기 보다 하위 집합으로 나누어 시각화하는 요소입니다. diamonds %&gt;% ggplot(aes(x = carat, y = price)) + geom_point() + facet_grid(. ~ cut) facet_grid() 혹은 facet_wrap() 함수를 통해 그림을 분할할 수 있습니다. 물결 표시(~)를 통해 하위 집합으로 나누고자 하는 변수를 선택할 수 있으며, 위 예제에서는 cut에 따라 각기 다른 그림으로 표현되었습니다. 8.2.4 Statistics Statistics는 통계값을 나타내는 요소입니다. diamonds %&gt;% ggplot(aes(x = cut, y = carat)) + stat_summary_bin(fun.y = &#39;mean&#39;, geom = &#39;bar&#39;) stat_summary_*() 함수를 사용하여 통계값을 표현하였습니다. cut에 따른 carat의 평균값을 구하고자 할 경우, fun.y 인자에 mean을 입력하여 평균값을 구하고, geom 인자에 bar를 입력하여 막대그래프 형태로 표현하였습니다. 8.2.5 Coordinates Coordinates는 좌표를 의미합니다. ggplot2에서는 coord_*() 함수를 이용하여 x축 혹은 y축 정보를 변형할 수 있습니다. diamonds %&gt;% ggplot(aes(x = carat, y = price)) + geom_point(aes(color = cut)) + coord_cartesian(xlim = c(0, 3), ylim = c(0, 20000)) coord_cartesian() 함수를 통해 x축과 y축 범위를 지정해 줄 수 있습니다. xlim과 ylim 내부에 범위의 최소 및 최댓값을 지정해주면, 해당 범위의 데이터만을 보여줍니다. diamonds %&gt;% ggplot(aes(x = carat, y = price)) + geom_boxplot(aes(group = cut)) + coord_flip() coord_flip() 함수는 x축과 y축을 뒤집어 표현합니다. ggplot() 함수의 aes 내부에서 x축은 carat을, y축은 price를 지정해 주었지만, coord_flip() 함수를 통해 x축과 y축이 서로 바뀌었습니다. 8.2.6 Theme Theme은 그림의 제목, 축 제목, 축 단위, 범례, 디자인 등 그림을 꾸며주는 역할을 담당합니다. diamonds %&gt;% ggplot(aes(x = carat, y = price)) + geom_point(aes(color = cut)) + theme_bw() + labs(title = &#39;Relation between Carat &amp; Price&#39;, x = &#39;Carat&#39;, y = &#39;Price&#39;) + theme(legend.position = &#39;bottom&#39;, panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), panel.grid.major.y = element_blank(), panel.grid.minor.y = element_blank() ) + scale_y_continuous( labels = function(x) { paste0(&#39;$&#39;, format(x, big.mark = &#39;,&#39;)) }) geom_point() 함수 이후 Theme에 해당하는 부분은 다음과 같습니다. theme_bw() 함수를 통해 배경을 흰색으로 설정합니다. labs() 함수를 통해 그래프의 제목 및 x축, y축 제목을 변경합니다. theme() 함수 내 legend.position을 통해 범례를 하단으로 이동합니다. theme() 함수 내 panel.grid를 통해 격자를 제거합니다. scale_y_continuous() 함수를 통해 y축에서 천원 단위로 콤마(,)를 붙여주며, 이를 달러($) 표시와 합쳐줍니다. 8.3 종목정보 시각화 이번에는 앞서 배운 내용을 바탕으로 종목정보를 시각화하도록 하겠습니다. 8.3.1 geom_point(): 산점도 나타내기 library(ggplot2) ggplot(data_market, aes(x = ROE, y = PBR)) + geom_point() ggplot() 함수 내에 사용될 데이터인 data_market을 입력합니다. aes 인자 내부에 x축은 ROE 열을 사용하고, y축은 PBR 열을 사용하도록 정의합니다. geom_point() 함수를 통해 산점도 그래프를 그려줍니다. 원하는 그림이 그려지기는 했으나, ROE와 PBR에 극단치 데이터가 있어 둘 사이에 관계가 잘 보이지 않습니다. ggplot(data_market, aes(x = ROE, y = PBR)) + geom_point() + coord_cartesian(xlim = c(0, 0.30), ylim = c(0, 3)) 이번에는 극단치 효과를 제거하기 위해 coord_cartesian() 함수 내에 xlim과 ylim, 즉 x축과 y축의 범위를 직접 지정해줍니다. 극단치가 제거되어 데이터를 한눈에 확인할 수 있습니다. ggplot(data_market, aes(x = ROE, y = PBR, color = `시장구분`, shape = `시장구분`)) + geom_point() + geom_smooth(method = &#39;lm&#39;) + coord_cartesian(xlim = c(0, 0.30), ylim = c(0, 3)) ggplot() 함수 내부 aes 인자에 color와 shape를 지정해주면, 해당 그룹별로 모양과 색이 나타납니다. 코스피와 코스닥 종목들에 해당하는 데이터의 색과 점 모양을 다르게 표시할 수 있습니다. geom_smooth() 함수를 통해 평활선을 추가할 수도 있으며, 방법으로 lm(linear model)을 지정할 경우 선형회귀선을 그려주게 됩니다. 이 외에도 glm, gam, loess 등의 다양한 회귀선을 그려줄 수 있습니다. 8.3.2 geom_histogram(): 히스토그램 나타내기 ggplot(data_market, aes(x = PBR)) + geom_histogram(binwidth = 0.1) + coord_cartesian(xlim = c(0, 10)) geom_histogram() 함수는 히스토그램을 나타내주며, binwidth 인자를 통해 막대의 너비를 선택해줄 수 있습니다. 국내 종목들의 PBR 데이터는 왼쪽에 쏠려 있고 오른쪽으로 꼬리가 긴 분포를 가지고 있습니다. ggplot(data_market, aes(x = PBR)) + geom_histogram(aes(y = ..density..), binwidth = 0.1, color = &#39;sky blue&#39;, fill = &#39;sky blue&#39;) + coord_cartesian(xlim = c(0, 10)) + geom_density(color = &#39;red&#39;) + geom_vline(aes(xintercept = median(PBR, na.rm = TRUE)), color = &#39;blue&#39;) + geom_text(aes(label = median(PBR, na.rm = TRUE), x = median(PBR, na.rm = TRUE), y = 0.05), col = &#39;black&#39;, size = 6, hjust = -0.5) PBR 히스토그램을 좀 더 자세하게 나타내보겠습니다. geom_histogram() 함수 내에 aes(y = ..density..)를 추가해 밀도함수로 바꿉니다. geom_density() 함수를 추가해 밀도곡선을 그려줍니다. geom_vline() 함수는 세로선을 그려주며, xintercept 즉 x축으로 PBR의 중앙값을 선택합니다. geom_text() 함수는 그림 내에 글자를 표현해주며, label 인자에 원하는 글자를 입력해준 후 글자가 표현될 x축, y축, 색상, 사이즈 등을 선택할 수 있습니다. 8.3.3 geom_boxplot(): 박스 플롯 나타내기 ggplot(data_market, aes(x = SEC_NM_KOR, y = PBR)) + geom_boxplot() + coord_flip() 박스 플롯 역시 데이터의 분포와 이상치를 확인하기 좋은 그림이며, geom_boxplot() 함수를 통해 나타낼 수 있습니다. x축 데이터로는 섹터 정보, y축 데이터로는 PBR을 선택합니다. geom_boxplot()을 통해 박스 플롯을 그려줍니다. coord_flip() 함수는 x축과 y축을 뒤집어 표현해주며 x축에 PBR, y축에 섹터 정보가 나타나게 됩니다. 결과를 살펴보면 유틸리티나 금융 섹터는 PBR이 잘 모여 있는 반면, IT나 건강관리 섹터 등은 매우 극단적인 PBR을 가지고 있는 종목이 있습니다. 8.3.4 dplyr과 ggplot을 연결하여 사용하기 data_market %&gt;% filter(!is.na(SEC_NM_KOR)) %&gt;% group_by(SEC_NM_KOR) %&gt;% summarize(ROE_sector = median(ROE, na.rm = TRUE), PBR_sector = median(PBR, na.rm = TRUE)) %&gt;% ggplot(aes(x = ROE_sector, y = PBR_sector, color = SEC_NM_KOR, label = SEC_NM_KOR)) + geom_point() + geom_text(color = &#39;black&#39;, size = 3, vjust = 1.3) + theme(legend.position = &#39;bottom&#39;, legend.title = element_blank()) 앞에서 배운 데이터 분석과 시각화를 동시에 연결해 사용할 수도 있습니다. 데이터 분석의 단계로 filter()를 통해 섹터가 NA가 아닌 종목을 선택합니다. group_by()를 통해 섹터별 그룹을 묶습니다. summarize()를 통해 ROE와 PBR의 중앙값을 계산해줍니다. 해당 과정을 거치면 다음의 결과가 계산됩니다. ## # A tibble: 10 x 3 ## SEC_NM_KOR ROE_sector PBR_sector ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 IT 0.0952 2.07 ## 2 건강관리 0.0927 3.12 ## 3 경기관련소비재 0.0584 1.33 ## 4 금융 0.100 0.745 ## 5 산업재 0.0624 1.21 ## 6 소재 0.0601 1.24 ## 7 에너지 0.0801 1.46 ## 8 유틸리티 0.0640 0.65 ## 9 커뮤니케이션서비스 0.0783 2.9 ## 10 필수소비재 0.0822 1.05 해당 결과를 파이프 오퍼레이터(%&gt;%)를 이용하여 ggplot() 함수와 연결해줍니다. x축과 y축을 설정한 후 색상과 라벨을 섹터로 지정해주면 각 섹터별로 색상이 다른 산점도가 그려집니다. geom_text() 함수를 통해 앞에서 라벨로 지정한 섹터 정보들을 출력해줍니다. theme() 함수를 통해 다양한 테마를 지정합니다. legend.position 인자로 범례를 하단에 배치했으며, legend.title 인자로 범례의 제목을 삭제했습니다. 8.3.5 geom_bar(): 막대 그래프 나타내기 data_market %&gt;% group_by(SEC_NM_KOR) %&gt;% summarize(n = n()) %&gt;% ggplot(aes(x = SEC_NM_KOR, y = n)) + geom_bar(stat = &#39;identity&#39;) + theme_classic() geom_bar()는 막대 그래프를 그려주는 함수입니다. group_by()를 통해 섹터별 그룹을 묶어줍니다. summarize() 함수 내부에 n()을 통해 각 그룹별 데이터 개수를 구합니다. ggplot() 함수에서 x축에는 SEC_NM_KOR, y축에는 n을 지정해줍니다. geom_bar()를 통해 막대 그래프를 그려줍니다. y축에 해당하는 n 데이터를 그대로 사용하기 위해서는 stat 인자를 identity로 지정해주어야 합니다. theme_*() 함수를 통해 배경 테마를 바꿀 수도 있습니다. 한편 위 그래프는 데이터 개수에 따라 순서대로 막대가 정렬되지 않아 보기에 좋은 형태는 아닙니다. 이를 반영해 더욱 보기 좋은 그래프로 나타내보겠습니다. data_market %&gt;% filter(!is.na(SEC_NM_KOR)) %&gt;% group_by(SEC_NM_KOR) %&gt;% summarize(n = n()) %&gt;% ggplot(aes(x = reorder(SEC_NM_KOR, n), y = n, label = n)) + geom_bar(stat = &#39;identity&#39;) + geom_text(color = &#39;black&#39;, size = 4, hjust = -0.3) + xlab(NULL) + ylab(NULL) + coord_flip() + scale_y_continuous(expand = c(0, 0, 0.1, 0)) + theme_classic() filter() 함수를 통해 NA 종목은 삭제해준 후 섹터별 종목 개수를 구해줍니다. ggplot()의 x축에 reorder() 함수를 적용해 SEC_NM_KOR 변수를 n 순서대로 정렬해줍니다. geom_bar()를 통해 막대 그래프를 그려준 후 geom_text()를 통해 라벨에 해당하는 종목 개수를 출력합니다. xlab()과 ylab()에 NULL을 입력해 라벨을 삭제합니다. coord_flip() 함수를 통해 x축과 y축을 뒤집어줍니다. scale_y_continuous() 함수를 통해 그림의 간격을 약간 넓혀줍니다. theme_classic()으로 테마를 변경해줍니다. 결과를 보면 종목수가 많은 섹터부터 순서대로 정렬되어 보기도 쉬우며, 종목수도 텍스트로 표현되어 한눈에 확인할 수 있습니다. 이처럼 데이터 시각화를 통해 정보의 분포나 특성을 한눈에 확인할 수 있으며, ggplot()을 이용하면 복잡한 형태의 그림도 매우 간단하고 아름답게 표현할 수 있습니다. 8.4 주가 및 수익률 시각화 주가 혹은 수익률을 그리는 것 역시 매우 중요합니다. R의 기본 함수로도 주가나 수익률을 나타낼 수 있지만, 패키지를 사용하면 더욱 보기 좋은 그래프를 그릴 수 있습니다. 또한 최근에 나온 여러 패키지들을 이용하면 매우 손쉽게 인터랙티브 그래프를 구현할 수도 있습니다. 8.4.1 주가 그래프 나타내기 library(quantmod) getSymbols(&#39;SPY&#39;) prices = Cl(SPY) getSymbols() 함수를 이용해 미국 S&amp;P 500 지수를 추종하는 ETF인 SPY의 데이터를 다운로드한 후 Cl() 함수를 이용해 종가에 해당하는 데이터만 추출합니다. 이제 해당 가격 및 수익률을 바탕으로 그래프를 그려보겠습니다. plot(prices, main = &#39;Price&#39;) getSymbols() 함수는 데이터를 xts 형식으로 다운로드합니다. R에서는 데이터가 xts 형식일 경우 기본 함수인 plot()으로 그래프를 그려도 x축에 시간을 나타내고 오른쪽 상단에 기간을 표시합니다. 그러나 완벽히 깔끔한 형태의 그래프라고 보기에 어려운 면이 있습니다. library(ggplot2) SPY %&gt;% ggplot(aes(x = Index, y = SPY.Close)) + geom_line() ggplot()을 이용하면 기본 plot()보다 한결 깔끔해지며, 패키지 내의 다양한 함수를 이용해 그래프를 꾸밀 수도 있습니다. 8.4.2 인터랙티브 그래프 나타내기 library(dygraphs) dygraph(prices) %&gt;% dyRangeSelector() dygraphs 패키지의 dygraph() 함수를 이용하면 사용자의 움직임에 따라 반응하는 그래프를 그릴 수 있습니다. 해당 패키지는 JavaScript를 이용해 인터랙티브한 그래프를 구현합니다. 그래프 위에 마우스 커서를 올리면 날짜 및 가격이 표시되기도 하며, 하단의 셀렉터를 이용해 원하는 기간의 수익률을 선택할 수도 있습니다. library(highcharter) highchart(type = &#39;stock&#39;) %&gt;% hc_add_series(prices) %&gt;% hc_scrollbar(enabled = FALSE) highcharter 패키지의 highchart() 함수 역시 이와 비슷하게 인터랙티브 그래프를 생성해줍니다. 왼쪽 상단의 기간을 클릭하면 해당 기간의 수익률만 확인할 수 있으며, 오른쪽 상단에 기간을 직접 입력할 수도 있습니다. library(plotly) p = SPY %&gt;% ggplot(aes(x = Index, y = SPY.Close)) + geom_line() ggplotly(p) plotly 패키지는 R뿐만 아니라 Python, MATLAB, Julia 등 여러 프로그래밍 언어에 사용될 수 있는 그래픽 패키지로서 최근에 많은 사랑을 받고 있습니다. R에서는 단순히 ggplot()을 이용해 나타낸 그림에 ggplotly() 함수를 추가하는 것만으로 인터랙티브한 그래프를 만들어줍니다. 또한 해당 패키지는 최근 샤이니에서도 많이 사용되고 있습니다. 따라서 샤이니를 이용한 웹페이지 제작을 생각하고 있는 분이라면, 원래의 함수 실행 방법도 알아두는 것이 좋습니다. prices %&gt;% fortify.zoo %&gt;% plot_ly(x= ~Index, y = ~SPY.Close ) %&gt;% add_lines() plot_ly() 함수 내부에 x축과 y축을 설정해주며, 변수명 앞에 물결표(~)를 붙여줍니다. 그 후 add_lines() 함수를 추가하면 선 그래프를 표시해줍니다. ggplot() 함수는 플러스 기호(+)를 통해 각 레이어를 연결해주었지만, plot_ly() 함수는 파이프 오퍼레이터(%&gt;%)를 통해 연결할 수 있다는 장점이 있습니다. 8.4.3 연도별 수익률 나타내기 주가 그래프 외에 연도별 수익률을 그리는 것도 중요합니다. ggplot()을 통해 연도별 수익률을 막대 그래프로 나타내는 방법을 살펴보겠습니다. library(PerformanceAnalytics) ret_yearly = prices %&gt;% Return.calculate() %&gt;% apply.yearly(., Return.cumulative) %&gt;% round(4) %&gt;% fortify.zoo() %&gt;% mutate(Index = as.numeric(substring(Index, 1, 4))) ggplot(ret_yearly, aes(x = Index, y = SPY.Close)) + geom_bar(stat = &#39;identity&#39;) + scale_x_continuous(breaks = ret_yearly$Index, expand = c(0.01, 0.01)) + geom_text(aes(label = paste(round(SPY.Close * 100, 2), &quot;%&quot;), vjust = ifelse(SPY.Close &gt;= 0, -0.5, 1.5)), position = position_dodge(width = 1), size = 3) + xlab(NULL) + ylab(NULL) apply.yearly() 함수를 이용해 연도별 수익률을 계산한 뒤 반올림합니다. fortify.zoo() 함수를 통해 인덱스에 있는 시간 데이터를 Index 열로 이동합니다. mutate() 함수 내에 substring() 함수를 통해 Index의 1번째부터 4번째 글자, 즉 연도에 해당하는 부분을 뽑아낸 후 숫자 형태로 저장합니다. ggplot() 함수를 이용해 x축에는 연도가 저장된 Index, y축에는 수익률이 저장된 SPY.Close를 입력합니다. geom_bar() 함수를 통해 막대 그래프를 그려줍니다. scale_x_continuous() 함수를 통해 x축에 모든 연도가 출력되도록 합니다. geom_text()를 통해 막대 그래프에 연도별 수익률이 표시되도록 합니다. vjust() 내에 ifelse() 함수를 사용해 수익률이 0보다 크면 위쪽에 표시하고, 0보다 작으면 아래쪽에 표시되도록 합니다. 해당 과정을 거치면 막대 그래프와 텍스트를 통해 연도별 수익률을 한눈에 확인할 수 있게 됩니다. References "],["퀀트-전략을-이용한-종목선정-기본.html", "Chapter 9 퀀트 전략을 이용한 종목선정 (기본) 9.1 베타 이해하기 9.2 저변동성 전략 9.3 모멘텀 전략 9.4 밸류 전략 9.5 퀄리티 전략", " Chapter 9 퀀트 전략을 이용한 종목선정 (기본) 투자에 필요한 주가, 재무제표, 가치지표 데이터가 준비되었다면 퀀트 전략을 활용해 투자하고자 하는 종목을 선정해야 합니다. 퀀트 투자는 크게 포트폴리오 운용 전략과 트레이딩 전략으로 나눌 수 있습니다. 포트폴리오 운용 전략은 과거 주식 시장을 분석해 좋은 주식의 기준을 찾아낸 후 해당 기준에 만족하는 종목을 매수하거나, 이와 반대에 있는 나쁜 주식을 공매도하기도 합니다. 투자의 속도가 느리며, 다수의 종목을 하나의 포트폴리오로 구성해 운용하는 특징이 있습니다. 반면 트레이딩 전략은 단기간에 발생되는 주식의 움직임을 연구한 후 예측해 매수 혹은 매도하는 전략입니다. 투자의 속도가 빠르며 소수의 종목을 대상으로 합니다. 표 9.1: 퀀트 투자 종류의 비교 기준 포트폴리오 운용 전략 트레이딩 전략 투자철학 규칙에 기반한 투자 규칙에 기반한 투자 투자목적 좋은 주식을 매수 좋은 시점을 매수 학문적 기반 경제학, 통계학 등 통계학, 공학, 정보처리 등 투자의 속도 느림 빠름 이 중 이 책에서는 포트폴리오에 기반한 운용 전략에 대해 다룹니다. 주식의 수익률에 영향을 미치는 요소를 팩터(Factor)라고 합니다. 즉 팩터의 강도가 양인 종목들로 구성한 포트폴리오는 향후 수익률이 높을 것으로 예상되며, 팩터의 강도가 음인 종목들로 구성한 포트폴리오는 반대로 향후 수익률이 낮을 것으로 예상됩니다. 팩터에 대한 연구는 학자들에 의해 오랫동안 진행되어 왔지만, 일반 투자자들이 이러한 논문을 모두 찾아보고 연구하기는 사실상 불가능에 가깝습니다. 그러나 최근에는 스마트 베타라는 이름으로 팩터 투자가 대중화되고 있습니다. 최근 유행하고 있는 스마트 베타 ETF는 팩터를 기준으로 포트폴리오를 구성한 상품으로서, 학계나 실무에서 검증된 팩터 전략을 기반으로 합니다. 해당 상품들의 웹사이트나 투자설명서에는 종목 선정 기준에 대해 자세히 나와 있으므로 스마트 베타 ETF에 나와 있는 투자 전략을 자세히 분석하는 것만으로도 훌륭한 퀀트 투자 전략을 만들 수 있습니다. 그림 9.1: 스마트베타 ETF 전략 예시 이 CHAPTER에서는 투자에 많이 활용되는 기본적인 팩터에 대해 알아보고, 우리가 구한 데이터를 바탕으로 각 팩터별 투자 종목을 선택하는 방법을 알아보겠습니다. 9.1 베타 이해하기 투자자들이라면 누구나 한 번은 베타(Beta)라는 용어를 들어봤을 것입니다. 기본적으로 주식시장의 움직임은 개별 주식의 수익률에 가장 크게 영향을 주는 요소일 수밖에 없습니다. 아무리 좋은 주식도 주식시장이 폭락한다면 같이 떨어지며, 아무리 나쁜 주식도 주식시장이 상승한다면 대부분 같이 오르기 마련입니다. 개별 주식이 전체 주식시장의 변동에 반응하는 정도를 나타낸 값이 베타입니다. 베타가 1이라는 뜻은 주식시장과 움직임이 정확히 같다는 뜻으로서 시장 그 자체를 나타냅니다. 베타가 1.5라는 뜻은 주식시장이 수익률이 +1%일 때 개별 주식의 수익률은 +1.5% 움직이며, 반대로 주식시장의 수익률이 -1%일 때 개별 주식의 수익률은 -1.5% 움직인다는 뜻입니다. 반면 베타가 0.5라면 주식시장 수익률의 절반 정도만 움직이게 됩니다. 표 9.2: 베타에 따른 개별 주식의 수익률 움직임 베타 주식시장이 +1% 일 경우 주식시장이 -1% 일 경우 0.5 +0.5% -0.5% 1.0 +1.0% -1.0% 1.5 +1.5% -1.5% 이처럼 베타가 큰 주식은 주식시장보다 수익률의 움직임이 크며, 반대로 베타가 낮은 주식은 주식시장보다 수익률의 움직임이 작습니다. 따라서 일반적으로 상승장이 기대될 때는 베타가 큰 주식에, 하락장이 기대될 때는 베타가 낮은 주식에 투자하는 것이 좋습니다. 주식시장에서 베타는 통계학의 회귀분석모형에서 기울기를 나타내는 베타와 정확히 의미가 같습니다. 회귀분석모형은 \\(y = a + bx\\) 형태로 나타나며, 회귀계수인 \\(b\\)는 \\(x\\)의 변화에 따른 \\(y\\)의 변화의 기울기입니다. 이를 주식에 적용한 모형이 자산가격결정모형(CAPM: Capital Asset Pricing Model)(Sharpe 1964)이며, 그 식은 다음과 같습니다. \\[회귀분석모형: y = a + bx\\] \\[자산가격결정모형: R_i = R_f + \\beta_i\\times[R_m - R_f]\\] 먼저 회귀분석모형의 상수항인 \\(a\\)에 해당하는 부분은 무위험 수익률을 나타내는 \\(R_f\\)입니다. 독립변수인 \\(x\\)에 해당하는 부분은 무위험 수익률 대비 주식 시장의 초과 수익률을 나타내는 시장위험 프리미엄인 \\(R_m - R_f\\)입니다. 종속변수인 \\(y\\)에 해당하는 부분은 개별주식의 수익률을 나타내는 \\(R_i\\)이며, 최종적으로 회귀계수인 \\(b\\)에 해당하는 부분은 개별 주식의 베타입니다. 표 9.3: 회귀분석모형과 자산가격결정모형의 비교 구분 회귀분석모형 자산가격결정모형 상수항 a \\(R_f\\) (무위험 수익률) 독립변수 x \\(R_m - R_f\\) (시장위험 프리미엄) 종속변수 y \\(R_i\\) (개별주식의 수익률) 회귀계수 b \\(\\beta_i\\) (개별주식의 베타) 통계학에서 회귀계수는 \\(\\beta = \\frac{cov(x,y)}{\\sigma_x^2}\\) 형태로 구할 수 있으며, \\(x\\)와 \\(y\\)에 각각 시장수익률과 개별주식의 수익률을 대입할 경우 개별주식의 베타는 \\(\\beta_i= \\rho(i,m) \\times\\frac{\\sigma_i}{\\sigma_m}\\) 형태로 구할 수 있습니다. 그러나 이러한 수식을 모르더라도 R에서는 간단히 베타를 구할 수 있습니다. 9.1.1 베타 계산하기 베타를 구하는 방법을 알아보기 위해 주식시장에 대한 대용치로 KOSPI 200 ETF, 개별주식으로는 전통적 고베타주인 증권주를 이용하겠습니다. library(quantmod) library(PerformanceAnalytics) library(magrittr) symbols = c(&#39;102110.KS&#39;, &#39;039490.KS&#39;) getSymbols(symbols) ## [1] &quot;102110.KS&quot; &quot;039490.KS&quot; prices = do.call(cbind, lapply(symbols, function(x)Cl(get(x)))) ret = Return.calculate(prices) ret = ret[&#39;2016-01::2018-12&#39;] KOSPI 200 ETF인 TIGER 200(102110.KS), 증권주인 키움증권(039490.KS)의 티커를 입력합니다. getSymbols() 함수를 이용하여 해당 티커들의 데이터를 다운로드 받습니다. lapply() 함수 내에 Cl()과 get()함수를 사용하여 종가에 해당하는 데이터만 추출하며, 리스트 형태의 데이터를 열의 형태로 묶어주기 위해 do.call() 함수와 cbind() 함수를 사용해 줍니다. Return.calculate() 함수를 통해 수익률을 계산해 줍니다. xts 형식의 데이터는 대괄호 속에 [‘시작일자::종료일자’]와 같은 형태로, 원하는 날짜를 편리하게 선택할 수 있으며, 위에서는 2016년 1월부터 2018년 12월 까지 데이터를 선택합니다. rm = ret[, 1] ri = ret[, 2] reg = lm(ri ~ rm) summary(reg) ## ## Call: ## lm(formula = ri ~ rm) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.06890 -0.01296 -0.00171 0.01082 0.09541 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.000400 0.000728 0.55 0.58 ## rm 1.764722 0.091131 19.36 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.0196 on 721 degrees of freedom ## (결측으로 인하여 8개의 관측치가 삭제되었습니다.) ## Multiple R-squared: 0.342, Adjusted R-squared: 0.341 ## F-statistic: 375 on 1 and 721 DF, p-value: &lt;2e-16 증권주를 대상으로 베타를 구하기 위한 회귀분석을 실시합니다. 자산가격결정모형의 수식인 \\(R_i = R_f + \\beta_i \\times [R_m - R_f]\\) 에서 편의를 위해 무위험 수익률인 \\(R_f\\)를 0으로 가정하면, \\(R_i = \\beta_i \\times R_m\\)의 형태로 나타낼 수 있습니다. 이 중 \\(R_m\\)는 독립변수인 주식시장의 수익률을 의미하고, \\(R_i\\)는 종속변수인 개별 주식의 수익률을 의미합니다. 독립변수는 첫 번째 열인 KOSPI 200 ETF의 수익률을 선택하며, 종속변수는 두번째 열인 증권주의 수익률을 선택합니다. lm() 함수를 통해 손쉽게 선형회귀분석을 실시할 수 있으며, 회귀분석의 결과를 reg 변수에 저장합니다. summary() 함수는 데이터의 요약 정보를 나타내며, 해당 예시에서는 회귀분석 결과에 대한 정보를 보여줍니다. 회귀분석의 결과 중 가장 중요한 부분은 계수를 나타내는 Coefficients입니다. Intercept는 회귀분석의 상수항에 해당하는 부분으로서, 값이 거의 0에 가깝고 t값 또한 매우 작아 유의하지 않음이 보입니다. 우리가 원하는 베타에 해당하는 부분 은 \\(x\\)의 Estimate로서, 베타값이 1.76으로 증권주의 특성인 고베타주임이 확인되며, t값 또한 19.36로 매우 유의한 결과입니다. 조정된 결정계수(Adjusted R-square)는 0.34를 보입니다. 9.1.2 베타 시각화 이제 구해진 베타를 그림으로 표현해보겠습니다. plot(as.numeric(rm), as.numeric(ri), pch = 4, cex = 0.3, xlab = &quot;KOSPI 200&quot;, ylab = &quot;Individual Stock&quot;, xlim = c(-0.02, 0.02), ylim = c(-0.02, 0.02)) abline(a = 0, b = 1, lty = 2) abline(reg, col = &#39;red&#39;) plot() 함수를 통해 그림을 그려주며, x축과 y축에 주식시장 수익률과 개별 주식 수익률을 입력합니다. pch는 점들의 모양을, cex는 점들의 크기를 나타내며, xlab과 ylab은 각각 x축과 y축에 들어갈 문구를 나타냅니다. xlim과 ylim은 x 축과 y축의 최소 및 최대 범위를 지정해줍니다. 첫번째 abline()에서 a는 상수, b는 직선의 기울기, lty는 선의 유형을 나타냅니다. 이를 통해 기울기, 즉 베타가 1일 경우의 선을 점선으로 표현합니다. 두번째 abline()에 회귀분석 결과를 입력해주면 자동적으로 회귀식을 그려줍니다. 검은색의 점선이 기울기가 1인 경우이며, 주황색의 직선이 증권주의 회귀분석결과를 나타냅니다. 기울기가 1보다 훨씬 가파름이 확인되며, 즉 베타가 1보다 크다는 사실을 알 수 있습니다. 9.2 저변동성 전략 금융 시장에서 변동성은 수익률이 움직이는 정도로서, 일반적으로 표준편차가 사용됩니다. 표준편차는 자료가 평균을 중심으로 얼마나 퍼져 있는지를 나타내는 수치로서, 수식은 다음과 같습니다. \\[\\sigma = \\sqrt{\\frac{\\sum_{i=1}^{n}{(x_i - \\bar{x})^2}}{n-1}}\\] 관측값의 개수가 적을 경우에는 수식에 대입해 계산하는 것이 가능하지만, 관측값이 수백 혹은 수천 개로 늘어날 경우 컴퓨터를 이용하지 않고 계산하기는 사실상 불가능합니다. R에서는 복잡한 계산 과정 없이 sd() 함수를 이용해 간단하게 표준편차를 계산할 수 있습니다. example = c(85, 76, 73, 80, 72) sd(example) ## [1] 5.357 개별 주식의 표준편차를 측정할 때는 주식의 가격이 아닌 수익률로 계산해야 합니다. 수익률의 표준편차가 크면 수익률이 위아래로 많이 움직여 위험한 종목으로 여겨집니다. 반면 표준편차가 작으면 수익률의 움직임이 적어 상대적으로 안전한 종목으로 여겨집니다. 전통적 금융 이론에서는 수익률의 변동성이 클수록 위험이 크고, 이런 위험에 대한 보상으로 기대수익률이 높아야 한다고 보았습니다. 따라서 고변동성 종목의 기대수익률이 크고, 저변동성 종목의 기대수익률이 낮은 고위험 고수익이 당연한 믿음이었습니다. 그러나 현실에서는 오히려 변동성이 낮은 종목들의 수익률이 변동성이 높은 종목들의 수익률보다 높은, 저변동성 효과가 발견되고 있습니다. 이러한 저변동성 효과가 발생하는 원인으로는 여러 가설이 있습니다. 투자자들은 대체로 자신의 능력을 과신하는 경향이 있으며, 복권과 같이 큰 수익을 가져다 주는 고변동성 주식을 선호하는 경향이 있습니다. 이러한 결과로 고변동성 주식은 과대 평가되어 수익률이 낮은 반면, 과소 평가된 저변동성 주식들은 높은 수익률을 보이게 됩니다. (Brunnermeier and Parker 2005) 대부분 기관투자가들이 레버리지 투자가 되지 않는 상황에서, 벤치마크 대비 높은 성과를 얻기 위해 고변동성 주식에 투자하는 경향이 있으며, 이 또한 고변동성 주식이 과대 평가되는 결과로 이어집니다. (Baker, Bradley, and Wurgler 2011) 시장의 상승과 하락이 반복됨에 따라 고변동성 주식이 변동성 손실(Volatility Drag)로 인해 수익률이 하락하게 되는 이유도 있습니다. (Sefton et al. 2011) 주식의 위험은 변동성뿐만 아니라 베타 등 여러 지표로도 측정할 수 있습니다. 저변동성 효과와 비슷하게 고유변동성이 낮은 주식의 수익률이 높은 저고유변동성 효과(Ang et al. 2009), 베타가 낮은 주식의 수익률이 오히려 높은 저베타 효과(Baker, Bradley, and Taliaferro 2014)도 발견되고 있으며, 이러한 효과들을 합쳐 저위험 효과라고 부르기도 합니다. 9.2.1 저변동성 포트폴리오 구하기: 일간 기준 먼저 최근 1년 일간 수익률 기준 변동성이 낮은 30종목을 선택하겠습니다. library(stringr) library(xts) library(PerformanceAnalytics) library(magrittr) library(ggplot2) library(dplyr) KOR_price = read.csv(&#39;data/KOR_price.csv&#39;, row.names = 1, stringsAsFactors = FALSE) %&gt;% as.xts() KOR_ticker = read.csv(&#39;data/KOR_ticker.csv&#39;, row.names = 1, stringsAsFactors = FALSE) KOR_ticker$&#39;종목코드&#39; = str_pad(KOR_ticker$&#39;종목코드&#39;, 6, &#39;left&#39;, 0) ret = Return.calculate(KOR_price) std_12m_daily = xts::last(ret, 252) %&gt;% apply(., 2, sd) %&gt;% multiply_by(sqrt(252)) 저장해둔 가격 정보와 티커 정보를 불러옵니다. 가격 정보는 as.xts() 함수를 통해 xts 형태로 변경합니다. Return.calculate() 함수를 통해 수익률을 구합니다. last() 함수는 마지막 n개 데이터를 선택해주는 함수이며, 1년 영업일 기준인 252개 데이터를 선택합니다. dplyr 패키지의 last() 함수와 이름이 같으므로, xts::last() 형식을 통해 xts 패키지의 함수임을 정의해줍니다. apply() 함수를 통해 sd 즉 변동성을 계산해주며, 연율화를 해주기 위해 multiply_by() 함수를 통해 \\(\\sqrt{252}\\)를 곱해줍니다. std_12m_daily %&gt;% data.frame() %&gt;% ggplot(aes(x = (`.`))) + geom_histogram(binwidth = 0.01) + annotate(&quot;rect&quot;, xmin = -0.02, xmax = 0.02, ymin = 0, ymax = sum(std_12m_daily == 0, na.rm = TRUE) * 1.1, alpha=0.3, fill=&quot;red&quot;) + xlab(NULL) std_12m_daily[std_12m_daily == 0] = NA 변동성을 히스토그램으로 나타내보면, 0에 위치하는 종목들이 다수 있습니다. 해당 종목들은 최근 1년간 거래정지로 인해 가격이 변하지 않았고, 이로 인해 변동성이 없는 종목들입니다. 해당 종목들은 NA로 처리해줍니다. std_12m_daily[rank(std_12m_daily) &lt;= 30] ## X033780 X012750 X007310 X016710 X034310 X001720 X005180 X267980 X029960 X002960 ## 0.1393 0.1731 0.1665 0.1858 0.1844 0.1832 0.1532 0.1709 0.1715 0.1736 ## X072710 X000480 X002810 X001270 X001070 X092130 X015360 X018120 X130580 X034590 ## 0.1522 0.1546 0.1810 0.1671 0.1850 0.1413 0.1715 0.1063 0.1882 0.1240 ## X040420 X078000 X036670 X016670 X004450 X088910 X000850 X014100 X084670 X010400 ## 0.1330 0.1832 0.1900 0.1425 0.1289 0.1861 0.1806 0.1564 0.1803 0.1919 std_12m_daily[rank(std_12m_daily) &lt;= 30] %&gt;% data.frame() %&gt;% ggplot(aes(x = rep(1:30), y = `.`)) + geom_col() + xlab(NULL) rank() 함수를 통해 순위를 구할 수 있으며, R은 기본적으로 오름차순 즉 가장 낮은값의 순위가 1이 됩니다. 따라서 변동성이 낮을수록 높은 순위가 되며, 30위 이하의 순위를 선택하면 변동성이 낮은 30종목이 선택됩니다. 또한 ggplot() 함수를 이용해 해당 종목들의 변동성을 확인해볼 수도 있습니다. 이번에는 해당 종목들의 티커 및 종목명을 확인하겠습니다. invest_lowvol = rank(std_12m_daily) &lt;= 30 KOR_ticker[invest_lowvol, ] %&gt;% select(`종목코드`, `종목명`) %&gt;% mutate(`변동성` = round(std_12m_daily[invest_lowvol], 4)) ## 종목코드 종목명 변동성 ## 35 033780 KT&amp;G 0.1393 ## 109 012750 에스원 0.1731 ## 176 007310 오뚜기 0.1665 ## 365 016710 대성홀딩스 0.1858 ## 393 034310 NICE 0.1844 ## 415 001720 신영증권 0.1832 ## 439 005180 빙그레 0.1532 ## 453 267980 매일유업 0.1709 ## 524 029960 코엔텍 0.1715 ## 638 002960 한국쉘석유 0.1736 ## 647 072710 농심홀딩스 0.1522 ## 659 000480 조선내화 0.1546 ## 763 002810 삼영무역 0.1810 ## 845 001270 부국증권 0.1671 ## 881 001070 대한방직 0.1850 ## 885 092130 이크레더블 0.1413 ## 933 015360 예스코홀딩스 0.1715 ## 991 018120 진로발효 0.1063 ## 1238 130580 나이스디앤비 0.1882 ## 1415 034590 인천도시가스 0.1240 ## 1467 040420 정상제이엘에스 0.1330 ## 1559 078000 텔코웨어 0.1832 ## 1639 036670 KCI 0.1900 ## 1645 016670 인피니티엔티 0.1425 ## 1685 004450 삼화왕관 0.1289 ## 1814 088910 동우팜투테이블 0.1861 ## 1820 000850 화천기공 0.1806 ## 1902 014100 메디앙스 0.1564 ## 2010 084670 동양고속 0.1803 ## 2034 010400 우진아이엔에스 0.1919 티커와 종목명, 연율화 변동성을 확인할 수 있습니다. 9.2.2 저변동성 포트폴리오 구하기: 주간 기준 이번에는 일간 변동성이 아닌 주간 변동성을 기준으로 저변동성 종목을 선택하겠습니다. std_12m_weekly = xts::last(ret, 252) %&gt;% apply.weekly(Return.cumulative) %&gt;% apply(., 2, sd) %&gt;% multiply_by(sqrt(52)) std_12m_weekly[std_12m_weekly == 0] = NA 먼저 최근 252일 수익률울 선택한 후, apply.weekly() 함수 내 Return.cumulative를 입력해 주간 수익률을 계산하며, 연율화를 위해 연간 주수에 해당하는 \\(\\sqrt{52}\\)를 곱해줍니다. 이 외에도 apply.monthly(), apply.yearly() 함수 등으로 일간 수익률을 월간, 연간 수익률 등으로 변환할 수 있습니다. 그 후 과정은 위와 동일합니다. std_12m_weekly[rank(std_12m_weekly) &lt;= 30] ## X377300 X033780 X012750 X007310 X348370 X381970 X383800 X034310 X001720 X005180 ## 0.10932 0.12547 0.13112 0.13999 0.10304 0.11925 0.13932 0.15361 0.16768 0.16211 ## X267980 X071320 X029960 X072710 X000480 X377450 X001070 X092130 X015360 X018120 ## 0.16839 0.16525 0.17149 0.14413 0.15789 0.06138 0.14791 0.14595 0.16962 0.09998 ## X130580 X034590 X376290 X040420 X159010 X078000 X016670 X004450 X114840 X376180 ## 0.16687 0.10322 0.10085 0.15292 0.11462 0.15074 0.14976 0.12987 0.14825 0.10024 invest_lowvol_weekly = rank(std_12m_weekly) &lt;= 30 KOR_ticker[invest_lowvol_weekly, ] %&gt;% select(`종목코드`, `종목명`) %&gt;% mutate(`변동성` = round(std_12m_weekly[invest_lowvol_weekly], 4)) ## 종목코드 종목명 변동성 ## 13 377300 카카오페이 0.1093 ## 35 033780 KT&amp;G 0.1255 ## 109 012750 에스원 0.1311 ## 176 007310 오뚜기 0.1400 ## 218 348370 엔켐 0.1030 ## 241 381970 케이카 0.1193 ## 373 383800 LX홀딩스 0.1393 ## 393 034310 NICE 0.1536 ## 415 001720 신영증권 0.1677 ## 439 005180 빙그레 0.1621 ## 453 267980 매일유업 0.1684 ## 509 071320 지역난방공사 0.1652 ## 524 029960 코엔텍 0.1715 ## 647 072710 농심홀딩스 0.1441 ## 659 000480 조선내화 0.1579 ## 847 377450 리파인 0.0614 ## 881 001070 대한방직 0.1479 ## 885 092130 이크레더블 0.1460 ## 933 015360 예스코홀딩스 0.1696 ## 991 018120 진로발효 0.1000 ## 1238 130580 나이스디앤비 0.1669 ## 1415 034590 인천도시가스 0.1032 ## 1419 376290 씨유테크 0.1008 ## 1467 040420 정상제이엘에스 0.1529 ## 1531 159010 아스플로 0.1146 ## 1559 078000 텔코웨어 0.1507 ## 1645 016670 인피니티엔티 0.1498 ## 1685 004450 삼화왕관 0.1299 ## 1745 114840 아이패밀리에스씨 0.1483 ## 2054 376180 피코그램 0.1002 주간 수익률의 변동성이 낮은 30종목을 선택해 종목코드, 종목명, 연율화 변동성을 확인합니다. intersect(KOR_ticker[invest_lowvol, &#39;종목명&#39;], KOR_ticker[invest_lowvol_weekly, &#39;종목명&#39;]) ## [1] &quot;KT&amp;G&quot; &quot;에스원&quot; &quot;오뚜기&quot; &quot;NICE&quot; ## [5] &quot;신영증권&quot; &quot;빙그레&quot; &quot;매일유업&quot; &quot;코엔텍&quot; ## [9] &quot;농심홀딩스&quot; &quot;조선내화&quot; &quot;대한방직&quot; &quot;이크레더블&quot; ## [13] &quot;예스코홀딩스&quot; &quot;진로발효&quot; &quot;나이스디앤비&quot; &quot;인천도시가스&quot; ## [17] &quot;정상제이엘에스&quot; &quot;텔코웨어&quot; &quot;인피니티엔티&quot; &quot;삼화왕관&quot; intersect() 함수를 통해 일간 변동성 기준과 주간 변동성 기준 모두에 포함되는 종목을 찾을 수 있습니다. 9.3 모멘텀 전략 투자에서 모멘텀이란 주가 혹은 이익의 추세로서, 상승 추세의 주식은 지속적으로 상승하며 하락 추세의 주식은 지속적으로 하락하는 현상을 말합니다. 모멘텀 현상이 발생하는 가장 큰 원인은 투자자들의 스스로에 대한 과잉 신뢰 때문입니다. 사람들은 자신의 판단을 지지하는 정보에 대해서는 과잉 반응하고, 자신의 판단을 부정하는 정보에 대해서는 과소 반응하는 경향이 있습니다. 이러한 투자자들의 비합리성으로 인해모멘텀 현상이 생겨나게 됩니다. 모멘텀의 종류는 크게 기업의 이익에 대한 추세를 나타내는 이익 모멘텀(Rendleman Jr, Jones, and Latane 1982)과, 주가의 모멘텀에 대한 가격 모멘텀이 있습니다. 또한 가격 모멘텀도 1주일(Lehmann 1990) 혹은 1개월 이하(Jegadeesh 1990)를 의미하는 단기 모멘텀, 3개월에서 12개월을 의미하는 중기 모멘텀(Jegadeesh and Titman 1993), 3년에서 5년을 의미하는 장기 모멘텀(De Bondt and Thaler 1985)이 있으며, 이 중에서도 3개월에서 12개월 가격 모멘텀을 흔히 모멘텀이라고 합니다. 9.3.1 모멘텀 포트폴리오 구하기: 12개월 모멘텀 먼저 최근 1년 동안의 수익률이 높은 30종목을 선택하겠습니다. library(stringr) library(xts) library(PerformanceAnalytics) library(magrittr) library(dplyr) KOR_price = read.csv(&#39;data/KOR_price.csv&#39;, row.names = 1, stringsAsFactors = FALSE) %&gt;% as.xts() KOR_ticker = read.csv(&#39;data/KOR_ticker.csv&#39;, row.names = 1, stringsAsFactors = FALSE) KOR_ticker$&#39;종목코드&#39; = str_pad(KOR_ticker$&#39;종목코드&#39;, 6, &#39;left&#39;, 0) ret = Return.calculate(KOR_price) %&gt;% xts::last(252) ret_12m = ret %&gt;% sapply(., function(x) { prod(1+x) - 1 }) 가격 정보와 티커 정보를 불러온 후 Return.calculate() 함수를 통해 수익률을 계산합니다. 그 후 최근 252일 수익률을 선택합니다. sapply() 함수 내부에 prod() 함수를 이용해 각 종목의 누적수익률을 계산해줍니다. ret_12m[rank(-ret_12m) &lt;= 30] ## X066970 X112040 X298050 X052690 X086520 X256840 X194480 X299900 X246710 X307750 ## 4.537 6.961 3.681 4.639 3.545 5.255 11.753 6.674 4.779 2.974 ## X206560 X138490 X130660 X063170 X101730 X291230 X048910 X042600 X004830 X205500 ## 3.808 3.086 3.605 5.861 8.322 3.082 4.272 5.673 4.658 4.275 ## X013360 X053290 X088390 X090150 X039240 X038620 X015020 X136510 X181340 X025890 ## 5.991 6.266 2.977 4.605 3.473 4.064 5.404 14.348 3.418 4.495 rank() 함수를 통해 순위를 구합니다. 모멘텀의 경우 높을수록 좋은 내림차순으로 순위를 계산해야 하므로 수익률 앞에 마이너스(-)를 붙여줍니다. 12개월 누적수익률이 높은 종목들이 선택됨이 확인됩니다. invest_mom = rank(-ret_12m) &lt;= 30 KOR_ticker[invest_mom, ] %&gt;% select(`종목코드`, `종목명`) %&gt;% mutate(`수익률` = round(ret_12m[invest_mom], 4)) ## 종목코드 종목명 수익률 ## 57 066970 엘앤에프 4.537 ## 61 112040 위메이드 6.961 ## 117 298050 효성첨단소재 3.681 ## 132 052690 한전기술 4.639 ## 156 086520 에코프로 3.545 ## 212 256840 한국비엔씨 5.255 ## 224 194480 데브시스터즈 11.753 ## 236 299900 위지윅스튜디오 6.674 ## 364 246710 티앤알바이오팹 4.779 ## 388 307750 국전약품 2.974 ## 414 206560 덱스터 3.808 ## 424 138490 코오롱플라스틱 3.086 ## 467 130660 한전산업 3.605 ## 468 063170 서울옥션 5.861 ## 504 101730 위메이드맥스 8.322 ## 517 291230 엔피 3.082 ## 531 048910 대원미디어 4.272 ## 572 042600 새로닉스 5.673 ## 610 004830 덕성 4.658 ## 642 205500 액션스퀘어 4.275 ## 667 013360 일성건설 5.991 ## 731 053290 NE능률 6.266 ## 840 088390 이녹스 2.977 ## 954 090150 광진윈텍 4.605 ## 981 039240 경남스틸 3.473 ## 1017 038620 위즈코프 4.064 ## 1167 015020 이스타코 5.404 ## 1233 136510 쎄미시스코 14.348 ## 1341 181340 이즈미디어 3.418 ## 1865 025890 한국주강 4.495 티커와 종목명, 누적수익률을 확인할 수 있습니다. 9.3.2 모멘텀 포트폴리오 구하기: 위험조정 수익률 단순히 과거 수익률로만 모멘텀 종목을 선택하면 각종 테마나 이벤트에 따른 급등으로 인해 변동성이 지나치게 높은 종목이 있을 수도 있습니다. 누적수익률을 변동성으로 나누어 위험을 고려해줄 경우, 이러한 종목은 제외되며 상대적으로 안정적인 모멘텀 종목을 선택할 수 있습니다. ret = Return.calculate(KOR_price) %&gt;% xts::last(252) ret_12m = ret %&gt;% sapply(., function(x) { prod(1+x) - 1 }) std_12m = ret %&gt;% apply(., 2, sd) %&gt;% multiply_by(sqrt(252)) sharpe_12m = ret_12m / std_12m 최근 1년에 해당하는 수익률을 선택합니다. sapply()와 prod() 함수를 이용해 분자에 해당하는 누적수익률을 계산합니다. apply()와 multiply_by() 이용해 분모에 해당하는 연율화 변동성을 계산합니다. 수익률을 변동성으로 나누어 위험조정 수익률을 계산해줍니다. 이를 통해 수익률이 높으면서 변동성이 낮은 종목을 선정할 수 있습니다. invest_mom_sharpe = rank(-sharpe_12m) &lt;= 30 KOR_ticker[invest_mom_sharpe, ] %&gt;% select(`종목코드`, `종목명`) %&gt;% mutate(`수익률` = round(ret_12m[invest_mom_sharpe], 2), `변동성` = round(std_12m[invest_mom_sharpe], 2), `위험조정 수익률` = round(sharpe_12m[invest_mom_sharpe], 2)) %&gt;% as_tibble() %&gt;% print(n = Inf) ## # A tibble: 30 x 5 ## 종목코드 종목명 수익률 변동성 `위험조정 수익률` ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 247540 에코프로비엠 2.9 0.46 6.27 ## 2 066970 엘앤에프 4.54 0.67 6.79 ## 3 112040 위메이드 6.96 0.91 7.66 ## 4 138040 메리츠금융지주 2.71 0.38 7.04 ## 5 298050 효성첨단소재 3.68 0.6 6.1 ## 6 052690 한전기술 4.64 0.71 6.58 ## 7 067160 아프리카TV 2.65 0.49 5.37 ## 8 298020 효성티앤씨 2.87 0.61 4.69 ## 9 086520 에코프로 3.54 0.62 5.74 ## 10 256840 한국비엔씨 5.25 1.13 4.64 ## 11 194480 데브시스터즈 11.8 1.14 10.3 ## 12 299900 위지윅스튜디오 6.67 0.6 11.2 ## 13 246710 티앤알바이오팹 4.78 0.94 5.06 ## 14 016710 대성홀딩스 0.96 0.19 5.15 ## 15 007340 디티알오토모티브 1.82 0.33 5.54 ## 16 206560 덱스터 3.81 0.68 5.57 ## 17 063170 서울옥션 5.86 0.75 7.82 ## 18 101730 위메이드맥스 8.32 0.96 8.63 ## 19 048910 대원미디어 4.27 0.88 4.84 ## 20 042600 새로닉스 5.67 0.96 5.93 ## 21 003100 선광 1.31 0.25 5.16 ## 22 205500 액션스퀘어 4.28 0.86 5 ## 23 013360 일성건설 5.99 0.94 6.39 ## 24 194370 제이에스코퍼레이션 2.82 0.58 4.85 ## 25 004890 동일산업 1.05 0.2 5.24 ## 26 053290 NE능률 6.27 1.05 5.95 ## 27 090150 광진윈텍 4.61 0.88 5.21 ## 28 015020 이스타코 5.4 1.08 5 ## 29 136510 쎄미시스코 14.4 1.16 12.4 ## 30 025890 한국주강 4.49 0.78 5.75 티커와 종목명, 누적수익률, 변동성, 위험조정 수익률을 확인할 수 있습니다. intersect(KOR_ticker[invest_mom, &#39;종목명&#39;], KOR_ticker[invest_mom_sharpe, &#39;종목명&#39;]) ## [1] &quot;엘앤에프&quot; &quot;위메이드&quot; &quot;효성첨단소재&quot; &quot;한전기술&quot; ## [5] &quot;에코프로&quot; &quot;한국비엔씨&quot; &quot;데브시스터즈&quot; &quot;위지윅스튜디오&quot; ## [9] &quot;티앤알바이오팹&quot; &quot;덱스터&quot; &quot;서울옥션&quot; &quot;위메이드맥스&quot; ## [13] &quot;대원미디어&quot; &quot;새로닉스&quot; &quot;액션스퀘어&quot; &quot;일성건설&quot; ## [17] &quot;NE능률&quot; &quot;광진윈텍&quot; &quot;이스타코&quot; &quot;쎄미시스코&quot; ## [21] &quot;한국주강&quot; intersect() 함수를 통해 단순 수익률 및 위험조정 수익률 기준 모두에 포함되는 종목을 찾을 수 있습니다. 다음은 위험조정 수익률 상위 30종목의 가격 그래프입니다. library(xts) library(tidyr) library(ggplot2) KOR_price[, invest_mom_sharpe] %&gt;% fortify.zoo() %&gt;% gather(ticker, price, -Index) %&gt;% ggplot(aes(x = Index, y = price)) + geom_line() + facet_wrap(. ~ ticker, scales = &#39;free&#39;) + xlab(NULL) + ylab(NULL) + theme(axis.text.x=element_blank(), axis.text.y=element_blank()) 9.4 밸류 전략 가치주 효과란 내재 가치 대비 낮은 가격의 주식(저PER, 저PBR 등)이, 내재 가치 대비 비싼 주식보다 수익률이 높은 현상(Basu 1977)을 뜻합니다. 가치 효과가 발생하는 원인에 대한 이론은 다음과 같습니다. 위험한 기업은 시장에서 상대적으로 낮은 가격에 거래되며, 이러한 위험을 감당하는 대가로 수익이 발생합니다. 투자자들의 성장주에 대한 과잉 반응으로 인해 가치주는 시장에서 소외되며, 제자리를 찾아가는 과정에서 수익이 발생합니다. 기업의 가치를 나타내는 지표는 굉장히 많지만, 일반적으로 PER, PBR, PCR, PSR이 많이 사용됩니다. 9.4.1 밸류 포트폴리오 구하기: 저PBR 먼저 기업의 가치 여부를 판단할 때 가장 많이 사용되는 지표인 PBR을 이용한 포트폴리오를 구성하겠습니다. library(stringr) library(ggplot2) library(dplyr) KOR_value = read.csv(&#39;data/KOR_value.csv&#39;, row.names = 1, stringsAsFactors = FALSE) KOR_ticker = read.csv(&#39;data/KOR_ticker.csv&#39;, row.names = 1, stringsAsFactors = FALSE) KOR_ticker$&#39;종목코드&#39; = str_pad(KOR_ticker$&#39;종목코드&#39;, 6, &#39;left&#39;, 0) invest_pbr = rank(KOR_value$PBR) &lt;= 30 KOR_ticker[invest_pbr, ] %&gt;% select(`종목코드`, `종목명`) %&gt;% mutate(`PBR` = round(KOR_value[invest_pbr, &#39;PBR&#39;], 4)) ## 종목코드 종목명 PBR ## 26 015760 한국전력 0.2103 ## 119 088350 한화생명 0.2164 ## 127 001040 CJ 0.1853 ## 145 000880 한화 0.1308 ## 320 003380 하림지주 0.2451 ## 385 009970 영원무역홀딩스 0.2483 ## 395 012630 HDC 0.1444 ## 469 032190 다우데이타 0.1599 ## 509 071320 지역난방공사 0.2629 ## 534 058650 세아홀딩스 0.1628 ## 589 003300 한일홀딩스 0.2173 ## 688 001940 KISCO홀딩스 0.2429 ## 743 036530 SNT홀딩스 0.1840 ## 789 092230 KPX홀딩스 0.2095 ## 797 002030 아세아 0.1757 ## 822 005720 넥센 0.1298 ## 855 008060 대덕 0.1893 ## 1329 005990 매일홀딩스 0.2317 ## 1338 054800 아이디스홀딩스 0.2201 ## 1524 009200 무림페이퍼 0.1758 ## 1530 004840 DRB동일 0.2373 ## 1537 005010 휴스틸 0.2609 ## 1767 012320 경동인베스트 0.1982 ## 1811 101330 모베이스 0.2350 ## 1820 000850 화천기공 0.2659 ## 1882 000590 CS홀딩스 0.2531 ## 2056 025530 SJM홀딩스 0.2241 ## 2083 024830 세원물산 0.2534 ## 2120 000760 이화산업 0.2680 ## 2227 141020 포티스 0.2642 가치지표들을 저장한 데이터와 티커 데이터를 불러오며, rank()를 통해 PBR이 낮은 30종목을 선택합니다. 그 후 종목코드와 종목명, PBR을 확인합니다. 홀딩스 등 지주사가 그 특성상 저PBR 포트폴리오에 많이 구성되어 있습니다. 9.4.2 각 지표 결합하기 저PBR 하나의 지표만으로도 우수한 성과를 거둘 수 있음은 오랜 기간 증명되고 있습니다. 그러나 저평가 주식이 계속해서 저평가에 머무르는 가치 함정에 빠지지 않으려면 여러 지표를 동시에 볼 필요도 있습니다. library(corrplot) rank_value = KOR_value %&gt;% mutate_all(list(~min_rank(.))) cor(rank_value, use = &#39;complete.obs&#39;) %&gt;% round(., 2) %&gt;% corrplot(method = &#39;color&#39;, type = &#39;lower&#39;, addCoef.col = &#39;black&#39;, number.cex = 1, tl.cex = 1, tl.srt = 0, tl.col = &#39;black&#39;, col = colorRampPalette( c(&#39;blue&#39;, &#39;white&#39;, &#39;red&#39;))(200), mar=c(0,0,0.5,0)) 먼저 mutate_all() 함수를 이용해 모든 열에 함수를 적용해주며, min_rank()를 통해 순위를 구합니다. 각 열에 해당하는 가치지표별 랭킹을 구한 후 상관관계를 확인하며, NA 종목은 삭제해주기 위해 use = 'complete.obs'를 입력합니다. corrplot 패키지의 corrplot() 함수를 이용해 상관관계를 그려보면, 같은 가치지표임에도 불구하고 서로 간의 상관관계가 꽤 낮은 지표도 있습니다. 따라서 지표를 통합적으로 고려하면 분산효과를 기대할 수도 있습니다. rank_sum = rank_value %&gt;% rowSums() invest_value = rank(rank_sum) &lt;= 30 KOR_ticker[invest_value, ] %&gt;% select(`종목코드`, `종목명`) %&gt;% cbind(round(KOR_value[invest_value, ], 2)) ## 종목코드 종목명 PER PBR PCR PSR ## 26 015760 한국전력 7.46 0.21 1.13 0.25 ## 145 000880 한화 11.32 0.13 0.70 0.05 ## 272 001120 LX인터내셔널 3.43 0.58 4.00 0.09 ## 304 006120 SK디스커버리 3.44 0.35 5.63 0.20 ## 320 003380 하림지주 15.48 0.25 1.26 0.11 ## 385 009970 영원무역홀딩스 6.19 0.25 1.45 0.23 ## 412 001390 KG케미칼 13.21 0.38 1.84 0.15 ## 553 002020 코오롱 2.84 0.49 1.27 0.09 ## 555 009410 태영건설 0.76 0.66 0.45 0.19 ## 589 003300 한일홀딩스 8.07 0.22 1.58 0.26 ## 618 004690 삼천리 11.82 0.27 3.77 0.12 ## 637 017940 E1 6.01 0.29 2.07 0.09 ## 649 084690 대상홀딩스 4.06 0.27 2.47 0.09 ## 671 000140 하이트진로홀딩스 5.27 0.32 0.93 0.15 ## 677 213500 한솔제지 5.70 0.53 2.70 0.22 ## 688 001940 KISCO홀딩스 9.40 0.24 2.27 0.30 ## 706 016450 한세예스24홀딩스 5.90 0.43 2.92 0.11 ## 719 013580 계룡건설 3.28 0.51 1.59 0.14 ## 743 036530 SNT홀딩스 7.96 0.18 1.14 0.21 ## 789 092230 KPX홀딩스 1.99 0.21 3.13 0.29 ## 797 002030 아세아 6.39 0.18 1.41 0.18 ## 894 011760 현대코퍼레이션 4.86 0.76 1.70 0.08 ## 950 004960 한신공영 2.02 0.34 1.01 0.14 ## 1182 000320 노루홀딩스 11.68 0.28 3.24 0.19 ## 1188 002460 화성산업 4.88 0.41 1.61 0.39 ## 1356 005740 크라운해태홀딩스 5.82 0.27 1.75 0.14 ## 1448 036710 심텍홀딩스 5.16 0.38 0.57 0.10 ## 1742 010100 한국프랜지 7.48 0.37 1.49 0.10 ## 1767 012320 경동인베스트 5.62 0.20 4.61 0.27 ## 1857 037400 우리조명 13.41 0.41 1.09 0.05 rowSums() 함수를 이용해 종목별 랭킹들의 합을 구해줍니다. 그 후 네 개 지표 랭킹의 합 기준 랭킹이 낮은 30종목을 선택합니다. 즉 하나의 지표보다 네 개 지표가 골고루 낮은 종목을 선택합니다. 해당 종목들의 티커, 종목명과 가치지표를 확인할 수 있습니다. intersect(KOR_ticker[invest_pbr, &#39;종목명&#39;], KOR_ticker[invest_value, &#39;종목명&#39;]) ## [1] &quot;한국전력&quot; &quot;한화&quot; &quot;하림지주&quot; &quot;영원무역홀딩스&quot; ## [5] &quot;한일홀딩스&quot; &quot;KISCO홀딩스&quot; &quot;SNT홀딩스&quot; &quot;KPX홀딩스&quot; ## [9] &quot;아세아&quot; &quot;경동인베스트&quot; 단순 저PBR 기준 선택된 종목과 비교해봤을 때 겹치는 종목이 상당히 줄어들었습니다. 9.5 퀄리티 전략 기업의 우량성, 즉 퀄리티는 투자자들이 매우 중요하게 생각하는 요소입니다. 그러나 어떠한 지표가 기업의 퀄리티를 나타내는지 한 마디로 정의하기에는 너무나 주관적이고 광범위해 쉽지 않습니다. 학계 혹은 업계에서 사용되는 우량성 관련 지표는 다음과 같이 요약할 수 있습니다. (Hsu, Kalesnik, and Kose 2019) Profitability (수익성) Earnings stability (수익의 안정성) Capital structure (기업 구조) Growth (수익의 성장성) Accounting quality (회계적 우량성) Payout/dilution (배당) Investment (투자) 퀄리티 전략에는 재무제표 데이터가 주로 사용됩니다. 9.5.1 F-Score F-Score 지표는 조셉 피오트로스키 교수가 발표(Piotroski and others 2000)한 지표입니다. 그는 논문에서, 저PBR을 이용한 밸류 전략은 높은 성과를 기록하지만 재무 상태가 불량한 기업이 많으며, 저PBR 종목 중 재무적으로 우량한 기업을 선정해 투자한다면 성과를 훨씬 개선할 수 있다고 보았습니다. F-Score에서는 재무적 우량 정도를 수익성(Profitability), 재무 성과(Financial Performance), 운영 효율성(Operating Efficiency)으로 구분해 총 9개의 지표를 선정합니다. 표 9.4는 이를 요약한 테이블입니다. 표 9.4: F-Score 요약 지표 항목 점수 Profitability \\(ROA\\) ROA가 양수면 1점 Profitability \\(CFO\\) CFO가 양수면 1점 Profitability \\(\\Delta ROA\\) ROA가 증가했으면 1점 Profitability \\(ACCRUAL\\) CFO &gt; ROA면 1점 Financial Performance \\(\\Delta LEVER\\) 레버리지가 감소했으면 1점 Financial Performance \\(\\Delta LIQUID\\) 유동성이 증가했으면 1점 Financial Performance \\(EQ\\_OFFER\\) 발행주식수가 감소했으면 1점 Operating Efficiency \\(\\Delta MARGIN\\) 매출총이익률이 증가했으면 1점 Operating Efficiency \\(\\Delta TURN\\) 회전율이 증가했으면 1점 각 지표가 우수할 경우 1점, 그렇지 않을 경우 0점을 매겨, 총 0점부터 9점까지의 포트폴리오를 구성합니다. library(stringr) library(ggplot2) library(dplyr) KOR_fs = readRDS(&#39;data/KOR_fs.Rds&#39;) KOR_ticker = read.csv(&#39;data/KOR_ticker.csv&#39;, row.names = 1, stringsAsFactors = FALSE) KOR_ticker$&#39;종목코드&#39; = str_pad(KOR_ticker$&#39;종목코드&#39;, 6, &#39;left&#39;, 0) 먼저 재무제표와 티커 파일을 불러옵니다. 재무제표 데이터는 Rds 형태로 저장되어 있으며, readRDS() 함수를 이용해 리스트 형태 그대로 불러올 수 있습니다. # 수익성 ROA = KOR_fs$&#39;지배주주순이익&#39; / KOR_fs$&#39;자산&#39; CFO = KOR_fs$&#39;영업활동으로인한현금흐름&#39; / KOR_fs$&#39;자산&#39; ACCURUAL = CFO - ROA # 재무성과 LEV = KOR_fs$&#39;장기차입금&#39; / KOR_fs$&#39;자산&#39; LIQ = KOR_fs$&#39;유동자산&#39; / KOR_fs$&#39;유동부채&#39; OFFER = KOR_fs$&#39;유상증자&#39; # 운영 효율성 MARGIN = KOR_fs$&#39;매출총이익&#39; / KOR_fs$&#39;매출액&#39; TURN = KOR_fs$&#39;매출액&#39; / KOR_fs$&#39;자산&#39; 지표에 해당하는 내용을 계산해줍니다. ROA는 지배주주순이익을 자산으로 나누어 계산합니다. CFO는 영업활동현금흐름을 자산으로 나누어 계산합니다. ACCURUAL은 CFO와 ROA의 차이를 이용해 계산합니다. LEV(Leverage)는 장기차입금을 자산으로 나누어 계산합니다. LIQ(Liquidity)는 유동자산을 유동부채로 나누어 계산합니다. 우리가 받은 데이터에서는 발행주식수 데이터를 구할 수 없으므로, OFFER에 대한 대용치로 유상증자 여부를 사용합니다. MARGIN은 매출총이익을 매출액으로 나누어 계산합니다. TURN(Turnover)은 매출액을 자산으로 나누어 계산합니다. 다음으로 각 지표들이 조건을 충족하는지 여부를 판단해, 지표별로 1점 혹은 0점을 부여합니다. if ( lubridate::month(Sys.Date()) %in% c(1,2,3,4) ) { num_col = str_which(colnames(KOR_fs[[1]]), as.character(lubridate::year(Sys.Date()) - 2)) } else { num_col = str_which(colnames(KOR_fs[[1]]), as.character(lubridate::year(Sys.Date()) - 1)) } F_1 = as.integer(ROA[, num_col] &gt; 0) F_2 = as.integer(CFO[, num_col] &gt; 0) F_3 = as.integer(ROA[, num_col] - ROA[, (num_col-1)] &gt; 0) F_4 = as.integer(ACCURUAL[, num_col] &gt; 0) F_5 = as.integer(LEV[, num_col] - LEV[, (num_col-1)] &lt;= 0) F_6 = as.integer(LIQ[, num_col] - LIQ[, (num_col-1)] &gt; 0) F_7 = as.integer(is.na(OFFER[,num_col]) | OFFER[,num_col] &lt;= 0) F_8 = as.integer(MARGIN[, num_col] - MARGIN[, (num_col-1)] &gt; 0) F_9 = as.integer(TURN[,num_col] - TURN[,(num_col-1)] &gt; 0) num_col 변수에 원하는 열의 위치를 구해줍니다. 1월~4월에 데이터를 받을 경우 전년도 재무제표가 일부만 들어오는 경향이 있으므로, 전전년도 데이터를 사용해야 합니다. 따라서 Sys.Date() 함수를 통해 현재 날짜를 추출한 후, lubridate 패키지의 month() 함수를 이용해 해당 월을 계산합니다. str_which() 함수를 이용해, 만일 현재 날짜가 1~4월인 경우 열 이름이 2년전 년도를 포함하는 부분을(예: 만일 오늘이 2021년 1월 이라면 열 이름중 2019가 포함된 곳), 그렇지 않을 경우(5~12월) 열 이름이 1년전 년도를 포함하는 부분을(예: 만일 오늘이 2021년 5월 이라면 열 이름중 2020가 포함된 곳) 선택합니다. as.integer() 함수는 TRUE일 경우 1을 반환하고 FALSE일 경우 0을 반환하는 함수로서, F-Score 지표의 점수를 매기는 데 매우 유용합니다. 점수 기준은 다음과 같습니다. ROA가 양수면 1점, 그렇지 않으면 0점 영업활동현금흐름이 양수면 1점, 그렇지 않으면 0점 최근 ROA가 전년 대비 증가했으면ROA[, num_col] &gt; 0 1점, 그렇지 않으면 0점 ACCURUAL(CFO - ROA)이 양수면 1점, 그렇지 않으면 0점 레버리지가 전년 대비 감소했으면 1점, 그렇지 않으면 0점 유동성이 전년 대비 증가했으면 1점, 그렇지 않으면 0점 유상증자 항목이 없거나 0보다 작으면 1점, 그렇지 않으면 0점 매출총이익률이 전년 대비 증가했으면 1점, 그렇지 않으면 0점 회전율이 전년 대비 증가했으면 1점, 그렇지 않으면 0점 F_Table = cbind(F_1, F_2, F_3, F_4, F_5, F_6, F_7, F_8, F_9) F_Score = F_Table %&gt;% apply(., 1, sum, na.rm = TRUE) %&gt;% setNames(KOR_ticker$`종목명`) cbind() 함수를 통해 열의 형태로 묶어줍니다. apply() 함수를 통해 종목별 지표의 합을 더해 F-Score를 계산해줍니다. setNanmes() 함수를 통해 종목명을 입력합니다. (F_dist = prop.table(table(F_Score)) %&gt;% round(3)) ## F_Score ## 0 1 2 3 4 5 6 7 8 9 ## 0.004 0.057 0.086 0.140 0.188 0.190 0.160 0.100 0.064 0.010 F_dist %&gt;% data.frame() %&gt;% ggplot(aes(x = F_Score, y = Freq, label = paste0(Freq * 100, &#39;%&#39;))) + geom_bar(stat = &#39;identity&#39;) + geom_text(color = &#39;black&#39;, size = 3, vjust = -0.4) + scale_y_continuous(expand = c(0, 0, 0, 0.05), labels = scales::percent) + ylab(NULL) + theme_classic() table() 함수를 통해 각 스코어별 개수를 구한 후 prop.table()을 통해 비중으로 변환합니다. 이를 통해 점수별 비중을 살펴보면 3~6점에 상당히 많은 종목이 분포하고 있음이 확인됩니다. invest_F_Score = F_Score %in% c(9) KOR_ticker[invest_F_Score, ] %&gt;% select(`종목코드`, `종목명`) %&gt;% mutate(`F-Score` = F_Score[invest_F_Score]) ## 종목코드 종목명 F-Score ## 2 000660 SK하이닉스 9 ## 53 009830 한화솔루션 9 ## 68 021240 코웨이 9 ## 73 011070 LG이노텍 9 ## 146 000080 하이트진로 9 ## 302 103140 풍산 9 ## 363 195870 해성디에스 9 ## 634 003100 선광 9 ## 671 000140 하이트진로홀딩스 9 ## 747 001790 대한제당 9 ## 751 017890 한국알콜 9 ## 881 001070 대한방직 9 ## 930 091580 상신이디피 9 ## 939 067900 와이엔텍 9 ## 1108 004140 동방 9 ## 1423 033320 제이씨현시스템 9 ## 1556 003720 삼영화학 9 ## 1585 253590 네오셈 9 ## 1641 311390 네오크레마 9 ## 1736 049800 우진플라임 9 ## 1770 019770 서연탑메탈 9 ## 1920 021650 한국큐빅 9 ## 2073 069140 누리플랜 9 F-Score가 9점인 종목의 티커와 종목명을 확인해봅니다. 재무적으로 우량하다고 판단되는 F-Score 9점인 종목은 총 23개가 있습니다. 9.5.2 각 지표를 결합하기 이번에는 퀄리티를 측정하는 요소 중 가장 널리 사용되는 수익성 지표를 결합한 포트폴리오를 만들어보겠습니다. 여기서 사용되는 지표는 자기자본이익률(ROE), 매출총이익(Gross Profit), 영업활동현금흐름(Cash Flow From Operating)입니다. library(stringr) library(ggplot2) library(dplyr) library(tidyr) KOR_fs = readRDS(&#39;data/KOR_fs.Rds&#39;) KOR_ticker = read.csv(&#39;data/KOR_ticker.csv&#39;, row.names = 1, stringsAsFactors = FALSE) KOR_ticker$&#39;종목코드&#39; = str_pad(KOR_ticker$&#39;종목코드&#39;, 6, &#39;left&#39;, 0) if ( lubridate::month(Sys.Date()) %in% c(1,2,3,4) ) { num_col = str_which(colnames(KOR_fs[[1]]), as.character(lubridate::year(Sys.Date()) - 2)) } else { num_col = str_which(colnames(KOR_fs[[1]]), as.character(lubridate::year(Sys.Date()) - 1)) } quality_roe = (KOR_fs$&#39;지배주주순이익&#39; / KOR_fs$&#39;자본&#39;)[num_col] quality_gpa = (KOR_fs$&#39;매출총이익&#39; / KOR_fs$&#39;자산&#39;)[num_col] quality_cfo = (KOR_fs$&#39;영업활동으로인한현금흐름&#39; / KOR_fs$&#39;자산&#39;)[num_col] quality_profit = cbind(quality_roe, quality_gpa, quality_cfo) %&gt;% setNames(., c(&#39;ROE&#39;, &#39;GPA&#39;, &#39;CFO&#39;)) 먼저 재무제표와 티커 파일을 불러온 후 세 가지 지표에 해당하는 값을 구한 뒤 최근년도 데이터만 선택합니다. 그런 다음 cbind() 함수를 이용해 지표들을 하나로 묶어줍니다. 역시나 1~4월의 경우 전년도가 아닌 전전년도 회계 데이터를 사용합니다. rank_quality = quality_profit %&gt;% mutate_all(list(~min_rank(desc(.)))) cor(rank_quality, use = &#39;complete.obs&#39;) %&gt;% round(., 2) %&gt;% corrplot(method = &#39;color&#39;, type = &#39;lower&#39;, addCoef.col = &#39;black&#39;, number.cex = 1, tl.cex = 1, tl.srt = 0, tl.col = &#39;black&#39;, col = colorRampPalette(c(&#39;blue&#39;, &#39;white&#39;, &#39;red&#39;))(200), mar=c(0,0,0.5,0)) mutate_all() 함수와 min_rank() 함수를 통해 지표별 랭킹을 구하며, 퀄리티 지표는 높을수록 좋은 내림차순으로 계산해야 하므로 desc()를 추가합니다. 수익성 지표 역시 서로 간의 상관관계가 낮아, 지표를 통합적으로 고려 시 분산효과를 기대할 수 있습니다. rank_sum = rank_quality %&gt;% rowSums() invest_quality = rank(rank_sum) &lt;= 30 KOR_ticker[invest_quality, ] %&gt;% select(`종목코드`, `종목명`) %&gt;% cbind(round(quality_profit[invest_quality, ], 4)) ## 종목코드 종목명 ROE GPA CFO ## 15 259960 크래프톤 0.4582 0.9717 0.3775 ## 68 021240 코웨이 0.2717 0.7242 0.1858 ## 71 137310 에스디바이오센서 0.8126 0.5871 0.3389 ## 124 096530 씨젠 0.7771 0.7836 0.3501 ## 142 067160 아프리카TV 0.2480 0.6733 0.2476 ## 209 214150 클래시스 0.3086 0.4436 0.2771 ## 227 064550 바이오니아 0.3912 0.8504 0.5005 ## 240 030190 NICE평가정보 0.1824 1.2093 0.2028 ## 292 069080 웹젠 0.1983 0.5419 0.2495 ## 416 205470 휴마시스 0.4292 0.4531 0.2097 ## 423 230360 에코마케팅 0.3550 0.9077 0.2621 ## 484 220630 맘스터치 0.3047 0.7406 0.2474 ## 485 287410 제이시스메디칼 0.3059 0.9031 0.4107 ## 496 263720 디앤씨미디어 0.2096 0.9058 0.1947 ## 500 348210 넥스틴 0.3203 0.5506 0.1842 ## 514 298540 더네이쳐홀딩스 0.2453 0.7660 0.1687 ## 571 206640 바디텍메드 0.3608 0.5976 0.2728 ## 603 099430 바이오플러스 0.3404 0.4380 0.2639 ## 689 285490 노바텍 0.2607 0.3959 0.2798 ## 711 084650 랩지노믹스 0.5245 0.6563 0.4241 ## 745 357230 에이치피오 0.2360 0.9534 0.2472 ## 815 051160 지어소프트 0.3377 0.6393 0.2383 ## 847 377450 리파인 0.4472 1.0972 0.2672 ## 885 092130 이크레더블 0.2263 0.6356 0.2533 ## 919 139670 키네마스터 0.1748 1.8061 0.2182 ## 940 207760 미스터블루 0.2285 1.1479 0.2603 ## 1035 352700 씨앤투스성진 0.4373 0.7008 0.6032 ## 1238 130580 나이스디앤비 0.1562 0.9416 0.2108 ## 1460 036120 SCI평가정보 0.2183 1.4139 0.2528 ## 1548 238490 힘스 0.2214 0.5028 0.3619 rowSums() 함수를 이용해 종목별 랭킹들의 합을 구합니다. 그 후 세 개 지표 랭킹의 합 기준 랭킹이 낮은 30종목을 선택합니다. 즉 세 가지 수익 지표가 골고루 높은 종목을 선택합니다. 해당 종목들의 티커, 종목명, ROE, GPA, CFO을 출력해 확인합니다. References "],["퀀트-전략을-이용한-종목선정-심화.html", "Chapter 10 퀀트 전략을 이용한 종목선정 (심화) 10.1 섹터 중립 포트폴리오 10.2 마법공식 10.3 이상치 데이터 제거 및 팩터의 결합 10.4 멀티팩터 포트폴리오", " Chapter 10 퀀트 전략을 이용한 종목선정 (심화) 지난 CHAPTER에서는 팩터를 이용한 투자 전략의 기본이 되는 저변동성, 모멘텀, 밸류, 퀄리티 전략에 대해 알아보았습니다. 물론 이러한 단일 팩터를 이용한 투자도 장기적으로 우수한 성과를 보이지만, 여러 팩터를 결합하거나 정밀하게 전략을 만든다면 더욱 우수한 성과를 거둘 수 있습니다. 이번 CHAPTER에서는 섹터별 효과를 없앤 후 포트폴리오를 구성하는 방법, 이상치 데이터 제거 및 팩터 결합 방법, 그리고 멀티팩터 구성 방법을 알아보겠습니다. 10.1 섹터 중립 포트폴리오 팩터 전략의 단점 중 하나는 선택된 종목들이 특정 섹터로 쏠리는 경우가 있다는 점입니다. 특히 과거 수익률을 토대로 종목을 선정하는 모멘텀 전략은 특정 섹터의 호황기에 동일한 섹터의 모든 종목이 함께 움직이는 경향이 있어 이러한 쏠림이 심할 수 있습니다. 먼저 지난 CHAPTER에서 배운 12개월 모멘텀을 이용한 포트폴리오 구성 방법을 다시 살펴보겠습니다. library(stringr) library(xts) library(PerformanceAnalytics) library(dplyr) library(ggplot2) KOR_price = read.csv(&#39;data/KOR_price.csv&#39;, row.names = 1, stringsAsFactors = FALSE) %&gt;% as.xts() KOR_ticker = read.csv(&#39;data/KOR_ticker.csv&#39;, row.names = 1, stringsAsFactors = FALSE) KOR_ticker$&#39;종목코드&#39; = str_pad(KOR_ticker$&#39;종목코드&#39;, 6, &#39;left&#39;, 0) ret = Return.calculate(KOR_price) %&gt;% xts::last(252) ret_12m = ret %&gt;% sapply(., function(x) { prod(1+x) - 1 }) invest_mom = rank(-ret_12m) &lt;= 30 기존의 코드와 동일하게, 주식 가격 및 티커 데이터를 불러온 후 최근 12개월 수익률을 구해 상위 30종목을 선택합니다. KOR_sector = read.csv(&#39;data/KOR_sector.csv&#39;, row.names = 1, stringsAsFactors = FALSE) KOR_sector$&#39;CMP_CD&#39; = str_pad(KOR_sector$&#39;CMP_CD&#39;, 6, &#39;left&#39;, 0) data_market = left_join(KOR_ticker, KOR_sector, by = c(&#39;종목코드&#39; = &#39;CMP_CD&#39;, &#39;종목명&#39; = &#39;CMP_KOR&#39;)) 해당 종목들의 섹터 정보를 추가로 살펴보기 위해, 섹터 데이터를 불러온 후 left_join() 함수를 이용해 티커와 결합해 data_market에 저장합니다. data_market[invest_mom, ] %&gt;% select(`SEC_NM_KOR`) %&gt;% group_by(`SEC_NM_KOR`) %&gt;% summarize(n = n()) %&gt;% ggplot(aes(x = reorder(`SEC_NM_KOR`, `n`), y = `n`, label = n)) + geom_col() + geom_text(color = &#39;black&#39;, size = 4, hjust = -0.3) + xlab(NULL) + ylab(NULL) + coord_flip() + scale_y_continuous(expand = c(0, 0, 0.1, 0)) + theme_classic() group_by() 함수를 이용해 12개월 기준 모멘텀 포트폴리오 종목들의 섹터별 종목수를 계산해준 후 ggplot() 함수를 이용해 이를 그림으로 나타냅니다. 그림에서 알 수 있듯이 특정 섹터에 대부분의 종목이 몰려 있습니다. 따라서 여러 종목으로 포트폴리오를 구성했지만, 이를 분해해보면 특정 섹터에 쏠림이 심하다는 것을 알 수 있습니다. 이러한 섹터 쏠림 현상을 제거한 섹터 중립 포트폴리오를 구성해보겠습니다. sector_neutral = data_market %&gt;% select(`종목코드`, `SEC_NM_KOR`) %&gt;% mutate(`ret` = ret_12m) %&gt;% group_by(`SEC_NM_KOR`) %&gt;% mutate(scale_per_sector = scale(`ret`), scale_per_sector = ifelse(is.na(`SEC_NM_KOR`), NA, scale_per_sector)) data_market에서 종목코드와 섹터 정보를 선택합니다. mutate() 함수를 통해 미리 계산한 12개월 수익률 정보를 새로운 열에 합쳐줍니다. group_by() 함수를 통해 섹터별 그룹을 만들어줍니다 scale() 함수를 이용해 그룹별 정규화를 해줍니다. 정규화는 \\(\\frac{x- \\mu}{\\sigma}\\)로 계산됩니다. 섹터 정보가 없을 경우 NA로 변경합니다. 위의 정규화 과정을 살펴보면, 전체 종목에서 12개월 수익률을 비교하는 것이 아닌 각 섹터별로 수익률의 강도를 비교하게 됩니다. 따라서 특정 종목의 과거 수익률이 전체 종목과 비교해서 높았더라도 해당 섹터 내에서의 순위가 낮다면, 정규화된 값은 낮아집니다. 따라서 섹터별 정규화 과정을 거친 값으로 비교 분석을 한다면, 섹터 효과가 제거된 포트폴리오를 구성할 수 있습니다. invest_mom_neutral = rank(-sector_neutral$scale_per_sector) &lt;= 30 data_market[invest_mom_neutral, ] %&gt;% select(`SEC_NM_KOR`) %&gt;% group_by(`SEC_NM_KOR`) %&gt;% summarize(n = n()) %&gt;% ggplot(aes(x = reorder(`SEC_NM_KOR`, `n`), y = `n`, label = n)) + geom_col() + geom_text(color = &#39;black&#39;, size = 4, hjust = -0.3) + xlab(NULL) + ylab(NULL) + coord_flip() + scale_y_continuous(expand = c(0, 0, 0.1, 0)) + theme_classic() 정규화된 값의 랭킹이 높은 상위 30종목을 선택하며, 내림차순을 위해 마이너스(-)를 붙여줍니다. 해당 포트폴리오의 섹터별 구성종목을 확인해보면, 단순하게 포트폴리오를 구성한 것에 대비하여 여러 섹터에 종목이 분산되어 있습니다. 이처럼 group_by() 함수를 통해 손쉽게 그룹별 중립화를 할 수 있으며, 글로벌 투자를 하는 경우에는 지역, 국가, 섹터별로도 중립화된 포트폴리오를 구성하기도 합니다. 10.2 마법공식 하나의 팩터만을 보고 투자하는 것보다, 둘 혹은 그 이상의 팩터를 결합해 투자해야 훨씬 좋은 포트폴리오를 구성할 수 있으며, 이러한 방법을 멀티팩터라고 합니다. 그중에서도 밸류와 퀄리티의 조합은 전통적으로 많이 사용된 방법이며, 대표적인 예가 조엘 그린블라트의 마법공식(Greenblatt 2010)입니다. 이에 앞서, 퀄리티와 밸류 간의 관계, 마법공식의 정의와 구성 방법을 알아보겠습니다. 10.2.1 퀄리티와 밸류 간의 관계 투자의 정석 중 하나는 좋은 기업을 싸게 사는 것입니다. 이를 팩터의 관점에서 이해하면 퀄리티 팩터와 밸류 팩터로 이해할 수도 있습니다. 여러 논문에 따르면 흔히 밸류 팩터와 퀄리티 팩터는 반대의 관계(Novy-Marx 2013)에 있습니다. 먼저 가치주들은 위험이 크기 때문에 시장에서 소외를 받아 저평가가 이루어지는 것이며, 이러한 위험에 대한 대가로 밸류 팩터의 수익률이 높게 됩니다. 반대로 사람들은 우량주에 기꺼이 프리미엄을 지불하려 하기 때문에 퀄리티 팩터의 수익률이 높기도 합니다. 이는 마치 동전의 양면과 같지만, 장기적으로 가치주와 우량주 모두 우수한 성과를 기록합니다. 먼저 퀄리티의 지표인 매출총이익과 밸류 지표인 PBR을 통해 둘 사이의 관계를 확인해 보겠습니다. library(stringr) library(dplyr) KOR_value = read.csv(&#39;data/KOR_value.csv&#39;, row.names = 1, stringsAsFactors = FALSE) KOR_fs = readRDS(&#39;data/KOR_fs.Rds&#39;) KOR_ticker = read.csv(&#39;data/KOR_ticker.csv&#39;, row.names = 1, stringsAsFactors = FALSE) data_pbr = KOR_value[&#39;PBR&#39;] if ( lubridate::month(Sys.Date()) %in% c(1,2,3,4) ) { num_col = str_which(colnames(KOR_fs[[1]]), as.character(lubridate::year(Sys.Date()) - 2)) } else { num_col = str_which(colnames(KOR_fs[[1]]), as.character(lubridate::year(Sys.Date()) - 1)) } data_gpa = (KOR_fs$&#39;매출총이익&#39; / KOR_fs$&#39;자산&#39;)[num_col] %&gt;% setNames(&#39;GPA&#39;) cbind(data_pbr, -data_gpa) %&gt;% cor(method = &#39;spearman&#39;, use = &#39;complete.obs&#39;) %&gt;% round(4) ## PBR GPA ## PBR 1.0000 -0.1844 ## GPA -0.1844 1.0000 데이터를 불러온 후 PBR과 GPA(매출총이익/자산)를 구합니다. 그 후 랭킹의 상관관계인 스피어만 상관관계를 구해보면, 서로 간에 반대 관계가 있음이 확인됩니다. PBR은 오름차순, GPA는 내림차순이므로 GPA 앞에 마이너스(-)를 붙여주었습니다. cbind(data_pbr, data_gpa) %&gt;% mutate(quantile_pbr = ntile(data_pbr, 5)) %&gt;% filter(!is.na(quantile_pbr)) %&gt;% group_by(quantile_pbr) %&gt;% summarise(mean_gpa = mean(GPA, na.rm = TRUE)) %&gt;% ggplot(aes(x = quantile_pbr, y = mean_gpa)) + geom_col() + xlab(&#39;PBR&#39;) + ylab(&#39;GPA&#39;) 이번에는 PBR의 분위수별 GPA 평균값을 구하겠습니다. ntile() 함수를 이용해 PBR을 5분위수로 나누어줍니다. PBR이 없는 종목은 제외합니다. group_by()함수를 통해 PBR의 분위수별 그룹을 묶어줍니다. 각 PBR 그룹별 GPA의 평균값을 구해줍니다. ggplot() 함수를 이용해 시각화를 해줍니다 그림에서 알 수 있듯이 PBR이 낮을수록 GPA도 낮으며, 즉 가치주일수록 우량성은 떨어집니다. 반면에 PBR이 높을수록 GPA도 높으며, 이는 주식의 가격이 비쌀수록 우량성도 높다는 뜻입니다. 이를 이용해 밸류 팩터와 퀄리티 팩터 간의 관계를 나타내면 다음과 같습니다. 그림 10.1: 밸류 팩터와 퀄리티 팩터간의 관계 주가가 쌀수록 기업의 우량성은 떨어지며(①번), 반대로 기업의 우량성이 좋으면 주식은 비싼 경향(③번)이 있습니다. 물론 우량성도 떨어지고 비싸기만한 주식(②번)을 사려는 사람들 아마 없을 겁니다. 결과적으로 우리가 원하는 최고의 주식은 우량성이 있으면서도 가격은 싼 주식(④번)입니다. 10.2.2 마법공식 이해하기 마법공식이란 고담 캐피탈의 설립자이자 전설적인 투자자 조엘 그린블라트에 의해 알려진 투자 방법입니다. 그는 본인의 책 《주식 시장을 이기는 작은 책》에서 투자를 하는데 있어 중요한 두 가지 지표가 있으며, 이를 혼합하면 뛰어난 성과를 기록할 수 있다고 했습니다. 첫 번째 지표는 이율(Earnings Yield)로서 기업의 수익을 기업의 가치로 나는 값입니다. 이는 PER의 역수와 비슷하며, 밸류 지표 중 하나입니다. 두 번째 지표는 투하자본 수익률(Return on Capital)로서 기업의 수익을 투자한 자본으로 나눈 값입니다. 이는 ROE와도 비슷하며, 퀄리티 지표 중 하나입니다. 마법공식은 이 두 가지 지표의 랭킹을 각각 구한 후 랭킹의 합 기준 상위 30개 종목을 1년간 보유한 후 매도하는 전략입니다. 해당 전략은 국내 투자자들에게도 많이 사랑받는 전략이지만 두 지표를 계산하기 위한 데이터를 수집하기 어려워 많은 투자자들이 이율 대신 PER를 사용하고, 투하자본 수익률 대신 ROE를 사용합니다. 그러나 우리가 수집한 데이터를 통해 충분히 원래의 마법공식을 구현할 수 있습니다. 표 10.1: 마법공식의 구성 요소 팩터 Value Quality 지표 이율 (Earnings Yield) 투하자본 수익률 (Return On Capital) 계산 \\(\\frac{이자\\,및\\,법인세\\,차감전이익}{기업\\,가치}\\) \\(\\frac{이자\\,및\\,법인세\\,차감전이익}{투하자본}\\) 10.2.3 마법공식 구성하기 재무제표 항목을 통해 이율과 투하자본 수익률을 계산하고, 이를 통해 마법공식 포트폴리오를 구성하겠습니다. 먼저 밸류 지표에 해당하는 이익수익률을 계산해보겠습니다. 이익수익률은 이자 및 법인세 차감전이익(EBIT)을 기업가치(시가총액 + 순차입금)로 나눈 값입니다. 이를 분해하면 다음과 같습니다. \\[\\begin{equation*} \\begin{split} 이익수익률 &amp; = \\frac{이자\\,및\\,법인세\\,차감전이익}{기업\\,가치} \\\\ &amp; = \\frac{이자\\,및\\,법인세\\,차감전이익}{시가총액 + 순차입금} \\\\ &amp; = \\frac{당기순이익 + 법인세 + 이자비용}{시가총액 + 총부채 - 여유자금} \\\\ &amp; = \\frac{당기순이익 + 법인세 + 이자비용}{시가총액 + 총부채 - (현금 - max(0, 유동부채 - 유동자산 + 현금))} \\end{split} \\end{equation*}\\] library(stringr) library(dplyr) KOR_value = read.csv(&#39;data/KOR_value.csv&#39;, row.names = 1, stringsAsFactors = FALSE) KOR_fs = readRDS(&#39;data/KOR_fs.Rds&#39;) KOR_ticker = read.csv(&#39;data/KOR_ticker.csv&#39;, row.names = 1, stringsAsFactors = FALSE) KOR_ticker$&#39;종목코드&#39; = str_pad(KOR_ticker$&#39;종목코드&#39;, 6, &#39;left&#39;, 0) if ( lubridate::month(Sys.Date()) %in% c(1,2,3,4) ) { num_col = str_which(colnames(KOR_fs[[1]]), as.character(lubridate::year(Sys.Date()) - 2)) } else { num_col = str_which(colnames(KOR_fs[[1]]), as.character(lubridate::year(Sys.Date()) - 1)) } # 분자 magic_ebit = (KOR_fs$&#39;지배주주순이익&#39; + KOR_fs$&#39;법인세비용&#39; + KOR_fs$&#39;이자비용&#39;)[num_col] # 분모 magic_cap = KOR_value$PER * KOR_fs$&#39;지배주주순이익&#39;[num_col] magic_debt = KOR_fs$&#39;부채&#39;[num_col] magic_excess_cash_1 = KOR_fs$&#39;유동부채&#39; - KOR_fs$&#39;유동자산&#39; + KOR_fs$&#39;현금및현금성자산&#39; magic_excess_cash_1[magic_excess_cash_1 &lt; 0] = 0 magic_excess_cash_2 = (KOR_fs$&#39;현금및현금성자산&#39; - magic_excess_cash_1)[num_col] magic_ev = magic_cap + magic_debt - magic_excess_cash_2 # 이익수익률 magic_ey = magic_ebit / magic_ev 가치지표, 재무제표, 티커 데이터를 불러온 후 재무제표 열 개수를 구합니다. 그후 분자와 분모 항목에 해당하는 부분을 하나씩 계산합니다. 먼저 분자 부분인 이자및 법인세 차감전이익은 지배주주 순이익에 법인세비용과 이자비용을 더해준 후 최근년도 데이터를 선택합니다. 분모 부분은 시가총액, 총 부채, 여유자금 총 세 가지로 구성되어 있습니다. 우리가 가지고 있는 밸류 데이터와 재무제표 데이터를 통해 시가총액을 역산할 수 있습니다. PER 값에 Earnings를 곱해주면 시가총액이 계산됩니다. 이를 통해 계산된 시가총액을 HTS나 금융 웹사이트의 값과 비교하면 거의 비슷함이 확인됩니다. \\[\\begin{equation*} \\begin{split} PER \\times Earnings &amp; = \\frac{Price}{Earnings/Shares} \\times Earnings \\\\ &amp; = \\frac{Price \\times Shares}{Earnings} \\times Earnings \\\\ &amp; = Price \\times Shares = Market\\,Cap \\end{split} \\end{equation*}\\] 총 부채는 부채 항목을 사용합니다. 여유자금은 두 단계에 걸쳐 계산합니다. 먼저 유동부채 - 유동자산 + 현금 값을 구해준 후 0보다 작은 값은 모두 0으로 바꿔줍니다. 이 값을 현금 및 현금성자산 항목에서 차감해 최종적인 여유자금을 구합니다. 분자와 분모 부분을 나누어주면 이익수익률을 계산할 수 있습니다. 다음으로 퀄리티 지표에 해당하는 투하자본 수익률을 계산하겠습니다. 해당 값은 이자 및 법인세 차감전이익(EBIT)를 투하자본(IC)으로 나누어 계산되며, 이를 분해하면 다음과 같습니다. \\[\\begin{equation*} \\begin{split} 투하자본\\,수익률 &amp; = \\frac{이자\\,및\\,법인세\\,차감전이익}{투하자본} \\\\ &amp; = \\frac{당기순이익 + 법인세 + 이자비용}{(유동자산 - 유동부채) + (비유동자산 - 감가상각비)} \\end{split} \\end{equation*}\\] magic_ic = ((KOR_fs$&#39;유동자산&#39; - KOR_fs$&#39;유동부채&#39;) + (KOR_fs$&#39;비유동자산&#39; - KOR_fs$&#39;감가상각비&#39;))[num_col] magic_roc = magic_ebit / magic_ic 투하자본 수익률은 비교적 쉽게 계산할 수 있습니다. 분모에 해당하는 투하자본의 경우 재무제표 항목을 그대로 사용하면 되며, 분자인 이자 및 법인세 차감전이익은 위에서 이미 구해둔 값을 사용하면 됩니다. 이제 두 지표를 활용해 마법공식 포트폴리오를 구성하겠습니다. invest_magic = rank(rank(-magic_ey) + rank(-magic_roc)) &lt;= 30 KOR_ticker[invest_magic, ] %&gt;% select(`종목코드`, `종목명`) %&gt;% mutate(`이익수익률` = round(magic_ey[invest_magic, ], 4), `투하자본수익률` = round(magic_roc[invest_magic, ], 4)) ## 종목코드 종목명 이익수익률 투하자본수익률 ## 71 137310 에스디바이오센서 0.1297 0.9308 ## 124 096530 씨젠 0.2274 0.9513 ## 342 036830 솔브레인홀딩스 1.3806 1.2819 ## 555 009410 태영건설 0.1980 0.3550 ## 557 035890 서희건설 0.1889 0.2756 ## 563 024720 한국콜마홀딩스 0.2567 0.2462 ## 571 206640 바디텍메드 0.1391 0.4606 ## 639 034810 해성산업 0.3917 0.3686 ## 674 068290 삼성출판사 0.1619 0.3570 ## 711 084650 랩지노믹스 0.1773 0.6346 ## 715 038290 마크로젠 0.2411 0.4182 ## 788 192440 슈피겐코리아 0.2910 0.2143 ## 902 031980 피에스케이홀딩스 0.2383 0.2629 ## 1028 187870 디바이스이엔지 0.2142 0.4002 ## 1035 352700 씨앤투스성진 0.1749 0.5877 ## 1219 000700 유수홀딩스 0.8342 0.2760 ## 1281 058110 멕아이씨에스 0.1711 0.5695 ## 1302 016250 SGC이테크건설 0.3098 1.6546 ## 1335 263690 디알젬 0.1571 0.4081 ## 1402 137940 넥스트아이 0.4361 0.4366 ## 1468 229000 젠큐릭스 0.2596 0.6033 ## 1521 000440 중앙에너비스 0.2098 0.3965 ## 1548 238490 힘스 0.2066 0.2494 ## 1619 090710 휴림로봇 0.3104 0.5826 ## 1646 046940 우원개발 0.1897 0.2650 ## 1727 002870 신풍제지 0.5192 0.4575 ## 1730 083550 케이엠 0.3483 0.3613 ## 1781 037350 성도이엔지 0.5560 0.4727 ## 1794 032940 원익 0.5231 0.4483 ## 1938 007120 미래아이앤지 1.4035 0.2713 이익수익률과 투하자본 수익률의 랭킹을 각각 구해주며, 내림차순으로 값을 구하기 위해 마이너스(-)를 붙여줍니다. 그 후 두 값의 합의 랭킹 기준 상위 30종목을 선택한 후 종목코드, 종목명과 각 지표를 확인합니다. 10.3 이상치 데이터 제거 및 팩터의 결합 모든 데이터 분석에서 중요한 문제 중 하나가 이상치(극단치, Outlier) 데이터를 어떻게 처리할 것인가입니다. 과거 12개월 수익률이 10배인 주식이 과연 모멘텀 관점에서 좋기만 한 주식인지, ROE가 100% 넘는 주식이 과연 퀄리티 관점에서 좋기만 한 주식인지 고민이 되기 마련입니다. 따라서 이러한 이상치를 제외하고 분석할지, 포함해서 분석할지를 판단해야 합니다. 만일 이상치를 포함한다면 그대로 사용할 것인지, 보정해 사용할 것인지도 판단해야 합니다. 우리가 가지고 있는 데이터에서 이상치 데이터를 탐색해보겠습니다. library(magrittr) library(ggplot2) KOR_value = read.csv(&#39;data/KOR_value.csv&#39;, row.names = 1, stringsAsFactors = FALSE) max(KOR_value$PBR, na.rm = TRUE) ## [1] 1825 KOR_value %&gt;% ggplot(aes(x = PBR)) + geom_histogram(binwidth = 0.1) 국내 종목들의 PBR 히스토그램을 그려보면 오른쪽으로 꼬리가 매우 긴 분포를 보이고 있습니다. 이는 PBR이 무려 1825.45인 이상치 데이터가 있기 때문입니다. 이처럼 모든 팩터 지표에는 극단치 데이터가 있기 마련이며, 이를 처리하는 방법을 알아보겠습니다. 10.3.1 트림(Trim): 이상치 데이터 삭제 트림은 이상치 데이터를 삭제하는 방법입니다. 위의 예제에서 이상치에 해당하는 상하위 1% 데이터를 삭제하겠습니다. library(dplyr) value_trim = KOR_value %&gt;% select(PBR) %&gt;% mutate(PBR = ifelse(percent_rank(PBR) &gt; 0.99, NA, PBR), PBR = ifelse(percent_rank(PBR) &lt; 0.01, NA, PBR)) value_trim %&gt;% ggplot(aes(x = PBR)) + geom_histogram(binwidth = 0.1) percent_rank() 함수를 통해 백분위를 구한 후 상하위 1%에 해당하는 데이터들은 NA로 변경했습니다. 결과적으로 지나치게 PBR이 낮은 종목과 높은 종목은 제거되어 x축의 스케일이 많이 줄어든 모습입니다. 평균이나 분산같이 통곗값을 구하는 과정에서는 이상치 데이터를 제거하는 것이 바람직할 수 있습니다. 그러나 팩터를 이용해 포트폴리오를 구하는 과정에서 해당 방법은 잘 사용되지 않습니다. 데이터의 손실이 발생하게 되며, 제거된 종목 중 정말로 좋은 종목이 있을 수도 있기 때문입니다. 10.3.2 윈저라이징(Winsorizing): 이상치 데이터 대체 포트폴리오 구성에서는 일반적으로 이상치 데이터를 다른 데이터로 대체하는 윈저라이징 방법이 사용됩니다. 예를 들어 상위 99%를 초과하는 데이터는 99% 값으로 대체하며, 하위 1% 미만의 데이터는 1% 데이터로 대체합니다. 즉, 좌우로 울타리를 쳐놓고 해당 범위를 넘어가는 값을 강제로 울타리에 맞춰줍니다. value_winsor = KOR_value %&gt;% select(PBR) %&gt;% mutate(PBR = ifelse(percent_rank(PBR) &gt; 0.99, quantile(., 0.99, na.rm = TRUE), PBR), PBR = ifelse(percent_rank(PBR) &lt; 0.01, quantile(., 0.01, na.rm = TRUE), PBR)) value_winsor %&gt;% ggplot(aes(x = PBR)) + geom_histogram(binwidth = 0.1) 역시나 percent_rank() 함수를 통해 백분위를 구한 후 해당 범위를 초과할 경우 각각 상하위 1% 데이터로 변형해줍니다. 그림을 살펴보면 x축 양 끝부분의 막대가 길어진 것을 확인할 수 있습니다. 10.3.3 팩터의 결합 방법 밸류 지표의 결합, 퀄리티 지표의 결합, 마법공식 포트폴리오를 구성할 때 단순히 랭킹을 더하는 방법을 사용했습니다. 물론 투자 종목수가 얼마 되지 않거나, 개인 투자자의 입장에서는 이러한 방법이 가장 단순하면서도 효과적일수 있습니다. 그러나 전문투자자의 입장이거나 팩터를 분석하는 업무를 할 경우 이처럼 단순히 랭킹을 더하는 방법은 여러 가지 문제를 안고 있습니다. library(tidyr) KOR_value %&gt;% mutate_all(list(~min_rank(.))) %&gt;% gather() %&gt;% ggplot(aes(x = value)) + geom_histogram() + facet_wrap(. ~ key) 앞의 그림은 각 밸류 지표의 랭킹을 구한 후 히스토그램으로 나타낸 것입니다. 랭킹을 구하는 것의 가장 큰 장점은 극단치로 인한 효과가 사라진다는 점과 균등한 분포를 가진다는 점입니다. 그러나 각 지표의 x축을 보면 최댓값이 서로 다릅니다. 이는 지표별 결측치로 인해 유효 데이터의 개수가 달라 나타나는 현상이며, 서로 다른 범위의 분포를 단순히 합치는 것은 좋은 방법이 아닙니다. 예를 들어 A, B, C, D 팩터에 각각 비중을 40%, 30%, 20%, 10% 부여해 포트폴리오를 구성한다고 가정해봅시다. 각 랭킹은 분포의 범위가 다르므로, 랭킹과 비중의 가중평균을 통해 포트폴리오를 구성하면 왜곡된 결과를 발생시킵니다. 이러한 문제를 해결하는 가장 좋은 방법은 랭킹을 구한 후 이를 Z-Score로 정규화하는 것입니다. KOR_value %&gt;% mutate_all(list(~min_rank(.))) %&gt;% mutate_all(list(~scale(.))) %&gt;% gather() %&gt;% ggplot(aes(x = value)) + geom_histogram() + facet_wrap(. ~ key) min_rank() 함수를 통해 랭킹을 구한 후, scale() 함수를 통해 정규화를 해주었습니다. 기본적으로 랭킹의 분포가 가진 극단치 효과가 사라지는 점과 균등 분포의 장점을 유지하고 있으며, 분포의 범위 역시 거의 동일하게 바뀌었습니다. 이처럼 여러 팩터를 결합해 포트폴리오를 구성하고자 하는 경우, 먼저 각 팩터(지표)별 랭킹을 정규화한 뒤 더해야 왜곡 효과가 제거되어 안정적입니다. \\[\\begin{equation*} Z - Score(Rank(Factor\\,A)) + Z - Score(Rank(Factor\\,B)) +\\,\\dots\\,+ Z - Score(Rank(Factor\\,N)) \\end{equation*}\\] 10.4 멀티팩터 포트폴리오 앞에서 배웠던 팩터 이론들과 결합 방법들을 응용해 멀티팩터 포트폴리오를 구성해보겠습니다. 각 팩터에 사용되는 지표는 다음과 같습니다. 퀄리티: 자기자본이익률, 매출총이익, 영업활동현금흐름 밸류: PER, PBR, PSR, PCR 모멘텀: 3개월 수익률, 6개월 수익률, 12개월 수익률 library(xts) library(stringr) KOR_fs = readRDS(&#39;data/KOR_fs.Rds&#39;) KOR_value = read.csv(&#39;data/KOR_value.csv&#39;, row.names = 1, stringsAsFactors = FALSE) KOR_price = read.csv(&#39;data/KOR_price.csv&#39;, row.names = 1, stringsAsFactors = FALSE) %&gt;% as.xts() KOR_ticker = read.csv(&#39;data/KOR_ticker.csv&#39;, row.names = 1, stringsAsFactors = FALSE) KOR_ticker$&#39;종목코드&#39; = str_pad(KOR_ticker$&#39;종목코드&#39;, 6, &#39;left&#39;, 0) 먼저 재무제표, 가치지표, 주가 데이터를 불러옵니다. if ( lubridate::month(Sys.Date()) %in% c(1,2,3,4) ) { num_col = str_which(colnames(KOR_fs[[1]]), as.character(lubridate::year(Sys.Date()) - 2)) } else { num_col = str_which(colnames(KOR_fs[[1]]), as.character(lubridate::year(Sys.Date()) - 1)) } quality_roe = (KOR_fs$&#39;지배주주순이익&#39; / KOR_fs$&#39;자본&#39;)[num_col] quality_gpa = (KOR_fs$&#39;매출총이익&#39; / KOR_fs$&#39;자산&#39;)[num_col] quality_cfo = (KOR_fs$&#39;영업활동으로인한현금흐름&#39; / KOR_fs$&#39;자산&#39;)[num_col] quality_profit = cbind(quality_roe, quality_gpa, quality_cfo) %&gt;% setNames(., c(&#39;ROE&#39;, &#39;GPA&#39;, &#39;CFO&#39;)) factor_quality = quality_profit %&gt;% mutate_all(list(~min_rank(desc(.)))) %&gt;% mutate_all(list(~scale(.))) %&gt;% rowSums() factor_quality %&gt;% data.frame() %&gt;% ggplot(aes(x = `.`)) + geom_histogram() 첫 번째로 퀄리티 지표를 계산해줍니다. 코드는 앞에서 살펴본 것과 거의 비슷하며, 자기자본이익률, 매출총이익, 영업활동현금흐름을 계산해줍니다. 그 후 mutate_all() 함수를 통해 랭킹을 구한 후 다시 표준화하며, 내림차순으로 정리하기 위해 랭킹 부분에 desc()를 붙여줍니다. rowSums() 함수를 통해 계산된 Z-Score를 종목별로 합쳐줍니다. Z-Score의 히스토그램을 살펴보면 이상치가 없이 중앙에 데이터가 많이 분포되어 있습니다. factor_value = KOR_value %&gt;% mutate_all(list(~min_rank(.))) %&gt;% mutate_all(list(~scale(.))) %&gt;% rowSums() factor_value %&gt;% data.frame() %&gt;% ggplot(aes(x = `.`)) + geom_histogram() 두 번째로 밸류 지표를 계산해줍니다. 밸류 지표는 이미 테이블 형태로 들어와 있으며, 랭킹과 표준화를 거쳐 합을 구해줍니다. 역시나 이상치가 없이 중앙에 데이터가 많이 분포되어 있습니다. library(PerformanceAnalytics) library(dplyr) ret_3m = Return.calculate(KOR_price) %&gt;% xts::last(60) %&gt;% sapply(., function(x) {prod(1+x) - 1}) ret_6m = Return.calculate(KOR_price) %&gt;% xts::last(120) %&gt;% sapply(., function(x) {prod(1+x) - 1}) ret_12m = Return.calculate(KOR_price) %&gt;% xts::last(252) %&gt;% sapply(., function(x) {prod(1+x) - 1}) ret_bind = cbind(ret_3m, ret_6m, ret_12m) %&gt;% data.frame() factor_mom = ret_bind %&gt;% mutate_all(list(~min_rank(desc(.)))) %&gt;% mutate_all(list(~scale(.))) %&gt;% rowSums() factor_mom %&gt;% data.frame() %&gt;% ggplot(aes(x = `.`)) + geom_histogram() 마지막으로 모멘텀 지표를 계산해줍니다. 최근 60일, 120일, 252일 주가를 통해 3개월, 6개월, 12개월 수익률을 구해준 후 cbind() 함수를 통해 열로 묶어줍니다. 그 후 내림차순 기준 랭킹과 표준화를 거쳐 합을 구합니다. library(corrplot) cbind(factor_quality, factor_value, factor_mom) %&gt;% data.frame() %&gt;% setNames(c(&#39;Quality&#39;, &#39;Value&#39;, &#39;Momentum&#39;)) %&gt;% cor(use = &#39;complete.obs&#39;) %&gt;% round(., 2) %&gt;% corrplot(method = &#39;color&#39;, type = &#39;lower&#39;, addCoef.col = &#39;black&#39;, number.cex = 1, tl.cex = 1, tl.srt = 0, tl.col = &#39;black&#39;, col = colorRampPalette(c(&#39;blue&#39;, &#39;white&#39;, &#39;red&#39;))(200), mar=c(0,0,0.5,0)) 퀄리티, 밸류, 모멘텀 팩터 간의 랭크의 서로 간 상관관계가 매우 낮으며, 여러 팩터를 동시에 고려함으로서 분산효과를 기대할 수 있습니다. factor_qvm = cbind(factor_quality, factor_value, factor_mom) %&gt;% data.frame() %&gt;% mutate_all(list(~scale(.))) %&gt;% mutate(factor_quality = factor_quality * 0.33, factor_value = factor_value * 0.33, factor_mom = factor_mom * 0.33) %&gt;% rowSums() invest_qvm = rank(factor_qvm) &lt;= 30 계산된 팩터들을 토대로 최종 포트폴리오를 구성해보겠습니다. 각 팩터의 분포가 역시나 다르기 때문에 다시 한번 scale() 함수를 통해 정규화해주며, 각 팩터에 동일한 비중인 0.33을 곱한 후 이를 더합니다. 물론 팩터별 비중을 [0.2, 0.4, 0.4]와 같이 다르게 줄 수도 있으며, 이는 어떠한 팩터를 더욱 중요하게 생각하는지 혹은 더욱 좋게 보는지에 따라 조정이 가능합니다. 최종적으로 해당 값의 랭킹 기준 상위 30종목을 선택합니다. library(tidyr) cbind(quality_profit, invest_qvm) %&gt;% gather(key, value, -invest_qvm) %&gt;% mutate(value = ifelse(percent_rank(value) &gt; 0.95, NA, value), value = ifelse(percent_rank(value) &lt; 0.05, NA, value)) %&gt;% ggplot(aes(x = value, fill = invest_qvm)) + geom_histogram(aes(y = ..density..), bins = 30) + facet_wrap(. ~ key, scale = &#39;free&#39;, ncol = 1) + theme(legend.position = &quot;bottom&quot;) + xlab(&#39;&#39;) + ylab(&#39;&#39;) 먼저 선택된 종목(TRUE)과 그렇지 않은 종목(FALSE)의 퀄리티 지표별 분포를 살펴보겠으며, 극단치로 인해 히스토그램이 제대로 표현되지 않는 문제를 방지하기 위해 위해서 상하위 1%를 넘는 데이터는 삭제(트림)해주도록 합니다. 선택된 종목은 대부분 수익성이 높음이 확인됩니다. cbind(KOR_value, invest_qvm) %&gt;% gather(key, value, -invest_qvm) %&gt;% mutate(value = ifelse(percent_rank(value) &gt; 0.95, NA, value), value = ifelse(percent_rank(value) &lt; 0.05, NA, value)) %&gt;% ggplot(aes(x = value, fill = invest_qvm)) + geom_histogram(aes(y = ..density..), bins = 30) + facet_wrap(. ~ key, scale = &#39;free&#39;, ncol = 1) + theme(legend.position = &quot;bottom&quot;) + xlab(&#39;&#39;) + ylab(&#39;&#39;) 이번에는 선택된 종목의 가치지표별 분포입니다. 선택된 종목은 대부분 값이 낮아 밸류 종목임이 확인됩니다. cbind(ret_bind, invest_qvm) %&gt;% gather(key, value, -invest_qvm) %&gt;% mutate(value = ifelse(percent_rank(value) &gt; 0.95, NA, value), value = ifelse(percent_rank(value) &lt; 0.05, NA, value)) %&gt;% ggplot(aes(x = value, fill = invest_qvm)) + geom_histogram(aes(y = ..density..), bins = 30) + facet_wrap(. ~ key, scale = &#39;free&#39;, ncol = 1) + theme(legend.position = &quot;bottom&quot;) + xlab(&#39;&#39;) + ylab(&#39;&#39;) 마지막으로 각 종목들의 기간별 수익률 분포입니다. 역시나 선택된 종목은 대부분 높은 수익률을 보입니다. KOR_ticker[invest_qvm, ] %&gt;% select(&#39;종목코드&#39;, &#39;종목명&#39;) %&gt;% cbind(round(quality_roe[invest_qvm, ], 2)) %&gt;% cbind(round(KOR_value$PBR[invest_qvm], 2)) %&gt;% cbind(round(ret_12m[invest_qvm], 2)) %&gt;% setNames(c(&#39;종목코드&#39;, &#39;종목명&#39;, &#39;ROE&#39;, &#39;PBR&#39;, &#39;12M&#39;)) ## 종목코드 종목명 ROE PBR 12M ## 49 030200 KT 0.04 0.52 0.35 ## 62 032640 LG유플러스 0.06 0.82 0.24 ## 151 120110 코오롱인더 0.09 1.01 1.26 ## 227 064550 바이오니아 0.39 8.62 1.07 ## 238 018670 SK가스 0.14 0.65 0.19 ## 266 014830 유니드 0.10 1.34 1.62 ## 291 222800 심텍 0.20 3.44 1.07 ## 385 009970 영원무역홀딩스 0.04 0.25 0.30 ## 400 003070 코오롱글로벌 0.17 1.31 0.39 ## 410 007340 디티알오토모티브 0.07 0.95 1.82 ## 412 001390 KG케미칼 0.03 0.38 1.07 ## 494 003030 세아제강지주 0.01 0.36 1.40 ## 497 110790 크리스에프앤씨 0.16 2.05 0.74 ## 511 053210 스카이라이프 0.08 0.64 0.02 ## 515 042420 네오위즈홀딩스 0.08 0.66 1.86 ## 553 002020 코오롱 0.17 0.49 0.64 ## 557 035890 서희건설 0.23 0.77 0.55 ## 719 013580 계룡건설 0.16 0.51 0.72 ## 850 003960 사조대림 0.07 0.56 0.98 ## 875 117580 대성에너지 0.04 0.78 0.68 ## 942 004250 NPC 0.06 0.75 0.96 ## 1051 066620 국보디자인 0.11 1.10 0.59 ## 1122 126600 코프라 0.11 1.63 2.09 ## 1163 039340 한국경제TV 0.14 1.20 0.43 ## 1183 100840 SNT에너지 0.04 0.74 0.53 ## 1250 079960 동양이엔피 0.10 0.62 0.15 ## 1302 016250 SGC이테크건설 1.27 1.02 0.50 ## 1310 009180 한솔로지스틱스 0.16 2.45 1.41 ## 1448 036710 심텍홀딩스 0.07 0.38 0.46 ## 1790 046110 한일네트웍스 0.10 1.04 0.53 포트폴리오 내 종목들을 대상으로 팩터별 대표적인 지표인 ROE, PBR, 12개월 수익률을 나타냈습니다. 전반적으로 ROE는 높고 PBR은 낮으며, 12개월 수익률이 높은 모습을 보입니다. 물론 특정 팩터의 강도가 약하더라도 나머지 팩터의 강도가 충분히 강하다면, 포트폴리오에 편입되는 모습을 보이기도 합니다. cbind(quality_profit, KOR_value, ret_bind)[invest_qvm, ] %&gt;% apply(., 2, mean) %&gt;% round(3) %&gt;% t() ## ROE GPA CFO PER PBR PCR PSR ret_3m ret_6m ret_12m ## [1,] 0.15 0.284 0.159 10.97 1.235 3.962 0.753 0.101 0.28 0.82 마지막으로 포트폴리오 내 종목들의 지표별 평균을 계산한 값입니다. References "],["포트폴리오-구성.html", "Chapter 11 포트폴리오 구성 11.1 최소분산 포트폴리오 11.2 최대분산효과 포트폴리오 11.3 위험균형 포트폴리오 11.4 인덱스 포트폴리오 구성하기", " Chapter 11 포트폴리오 구성 종목별로 비중을 어떻게 배분하느냐에 따라 성과가 달라지므로, 종목의 선택 못지 않게 중요한 것이 포트폴리오를 구성하는 방법입니다. 최적 포트폴리오의 구성은 수식을 기반으로 최적화된 해를 찾습니다. 물론 엑셀의 해 찾기와 같은 기능을 사용해 간단한 형태의 최적화 구현이 가능하지만, 방대한 데이터를 다룰 경우에는 속도가 지나치게 느려지거나 계산할 수 없게 되기도 합니다. 동일한 최적화 방법을 지속적으로 사용한다면 프로그래밍을 통해 함수를 만들고, 입력 변수만 변경하는 것이 훨씬 효율적인 방법입니다. 또한 포트폴리오 최적화에 관한 좋은 패키지들이 이미 많이 나와 있으므로, 대략적인 내용만 이해하고 실제 구현은 패키지를 이용하는 것도 좋은 방법입니다. 이 CHAPTER에서는 일반적으로 많이 사용되는 최소분산 포트폴리오, 최대분산효과 포트폴리오, 위험균형 포트폴리오를 구현해보도록 합니다. 또한 실무에서 많이 사용되는 인덱스 포트폴리오를 구성하는 방법에 대해서도 살펴보겠습니다. 먼저 포트폴리오 구성을 위해 글로벌 자산을 대표하는 ETF 데이터를 다운로드하겠습니다 library(quantmod) library(PerformanceAnalytics) library(magrittr) symbols = c(&#39;SPY&#39;, # 미국 주식 &#39;IEV&#39;, # 유럽 주식 &#39;EWJ&#39;, # 일본 주식 &#39;EEM&#39;, # 이머징 주식 &#39;TLT&#39;, # 미국 장기채 &#39;IEF&#39;, # 미국 중기채 &#39;IYR&#39;, # 미국 리츠 &#39;RWX&#39;, # 글로벌 리츠 &#39;GLD&#39;, # 금 &#39;DBC&#39; # 상품 ) getSymbols(symbols, src = &#39;yahoo&#39;) ## [1] &quot;SPY&quot; &quot;IEV&quot; &quot;EWJ&quot; &quot;EEM&quot; &quot;TLT&quot; &quot;IEF&quot; &quot;IYR&quot; &quot;RWX&quot; &quot;GLD&quot; &quot;DBC&quot; prices = do.call(cbind, lapply(symbols, function(x) Ad(get(x)))) %&gt;% setNames(symbols) rets = Return.calculate(prices) %&gt;% na.omit() getSymbols() 함수를 통해 일반적으로 자산배분에서 많이 사용되는 주식과 채권, 대체자산에 해당하는 ETF 가격 데이터를 받은 후 lapply()와 Ad(), get() 함수의 조합을 통해 수정주가만을 선택하고 열의 형태로 묶어줍니다. 그 후 Return.calculate() 함수를 통해 수익률을 계산합니다. library(tidyr) library(dplyr) library(corrplot) cor(rets) %&gt;% corrplot(method = &#39;color&#39;, type = &#39;lower&#39;, addCoef.col = &#39;black&#39;, number.cex = 0.7, tl.cex = 1, tl.srt = 0, tl.col = &#39;black&#39;, col = colorRampPalette(c(&#39;blue&#39;, &#39;white&#39;, &#39;red&#39;))(200), mar = c(0,0,0.5,0)) 각 ETF의 수익률 간 상관관계를 살펴보면 같은 자산군 내에서는 강한 상관관계를 보이며, 주식과 채권 간에는 매우 낮은 상관관계를 보입니다. 또한 주식과 리츠 간에도 꽤 높은 상관관계를 보입니다. 포트폴리오 최적화에는 분산-공분산 행렬이 대부분 사용되며, 이는 cov() 함수를 통해 손쉽게 계산할 수 있습니다. covmat = cov(rets) 11.1 최소분산 포트폴리오 최소분산 포트폴리오(Minimum Variance Portfolio)는 변동성이 최소인 포트폴리오입니다. 포트폴리오의 변동성은 일반적으로 \\(\\sum_{i=1}^{n}\\sum_{j=1}^{n}w_iw_j\\sigma_{ij}\\)의 형태로 표현되지만, 최적화 작업을 위해서는 행렬의 형태인 \\(w&#39;\\Omega w\\)로 표현하는 것이 더욱 편리합니다. 이 중 \\(w\\)는 각 자산들의 비중을 행렬의 형태로 나타낸 것이며, \\(\\Omega\\)는 분산-공분산 행렬을 나타낸 것입니다. 분산-공분산 행렬은 사전에 고정되어 있는 값이므로, 각 자산들의 비중인 \\(w\\)를 변화시킴으로써 포트폴리오의 변동성이 최소인 지점을 찾을 수 있습니다. 최소분산 포트폴리오의 목적함수는 아래의 수식으로 표현할 수 있습니다. 이 중 \\(^1/_2\\)은 단지 미분했을 때 계산을 용이하게 하기 위한 장치일 뿐 결과에는 영향을 미치지 않습니다. \\[ 최소분산\\,포트폴리오의\\,목적함수: min\\,^1/_2\\,w&#39;\\Omega w \\] 다만 단순히 위의 목적함수를 찾는 해를 구하면 결괏값이 음수가 나오기도 하는데 이것은 공매도를 의미합니다. 일반적으로 공매도가 불가능하다는 점과, 투자비중의 합이 100%가 되어야 한다는 점을 고려하면 아래와 같은 제약조건을 추가해야 합니다. \\[ 최소분산\\,포트폴리오의\\,제약조건: \\sum_{i=1}^{n}w_i = 1, w_i \\ge 0 \\] 물론 이 외에도 각 섹터의 투자비중 합에 대한 제약조건이나 회전율에 대한 제약조건 등도 추가할 수 있습니다. 11.1.1 slsqp() 함수를 이용한 최적화 R에서 가장 손쉽게 최적화 작업을 수행하는 방법은 nloptr 패키지의 slsqp() 함수를 이용하는 것입니다. slsqp() 함수는 순차적 이차 계획(Sequential Quadratic Programming)을 이용해 해를 찾으며, 목적함수와 제약조건은 다음과 같습니다. 표 11.1: slsqp() 함수 목적함수와 제약조건 목적함수 제약조건 \\(min\\,f(x)\\) \\(b(x)\\ge0, c(x)=0\\) 목적함수에서 \\(f(x)\\) 는 최소화하고자 하는 값, 즉 포트폴리오의 변동성입니다. 제약조건은 크게 개별 자산의 투자 비중이 0 이상인 것과, 투자 비중의 합이 1이 되도록 하는 것입니다. 첫 번째 제약조건은 자연스럽게 개별 자산의 투자비중이 0 이상인 것을 의미합니다. 두 번째 제약조건은 약간의 변형을 통해 투자비중의 합이 1이 되는 제약조건을 만들 수 있습니다. \\(c(x)\\)를 투자비중의 합 – 1 로 변형할 경우 -1을 우변으로 넘기면 결국 투자비중의 합 = 1의 형태로 나타낼 수 있습니다. slsqp() 함수의 구성은 다음과 같습니다. slsqp(x0, fn, gr = NULL, lower = NULL, upper = NULL, hin = NULL, hinjac = NULL, heq = NULL, heqjac = NULL, nl.info = FALSE, control = list(), ...) 이 중 우리가 구체적으로 입력해야 할 값은 x0, fn, hin, heq 항목 입니다. x0은 초기값이며, 일반적으로 모든 x에 대해 동일한 값을 입력합니다. fn은 최소화하고자 하는 목적함수로, 포트폴리오 변동성에 해당합니다. hin은 부등위 제약조건(inequality constraints)을 의미하며, 프로그래밍 내에서는 hin &gt;= 0로 인식하며, 각 자산의 비중이 0보다 크다는 제약조건과 연결됩니다. heq는 등위 제약조건(equality constraints)을 의미하며, 프로그래밍 내에서는 heq == 0을 의미합니다. 투자비중의 합 - 1의 형태를 입력한다면 투자비중의 합이 1 이라는 제약조건과 연결됩니다. 표 11.2는 최소분산 포트폴리오를 구할 때 필요한 주요 변수에 대한 내용입니다. 표 11.2: slsqp() 함수의 인자와 포트폴리오 내 변수 변수명 내용 포트폴리오 내 변수 x0 초기값 없음 fn 목적함수 포트폴리오 변동성 hin 부등위 제약조건 각 자산의 비중이 0 보다 큰 제약조건 heq 등위 제약조건 투자 비중의 합이 1인 제약조건 slsqp() 함수를 이용해 최소분산 포트폴리오를 만족하는 자산의 투자비중을 구하는 과정은 다음과 같습니다. 먼저 fn, hin, heq에 해당하는 함수들을 각각 만든 후 이를 slsqp() 함수와 결합해 최적화된 결괏값을 얻을 수 있습니다. 구체적인 과정은 아래와 같습니다. objective = function(w) { obj = t(w) %*% covmat %*% w return(obj) } 먼저 목적함수에 해당하는 부분입니다. covmat은 사전에 계산된 분산-공분산 행렬이며, \\(w\\)는 각 자산의 투자비중입니다. obj는 포트폴리오의 변동성인 \\(w&#39;\\Omega w\\)를 계산한 것입니다. 즉, 해당 함수는 계산된 \\(w\\)를 바탕으로 포트폴리오의 변동성을 반환하고, 우리의 목적은 해당 값이 최소가 되도록 하는 것입니다. hin.objective = function(w) { return(w) } \\(w_i \\ge 0\\) 제약조건에 해당하는 부등위 제약조건입니다. 패키지 내에서는 hin &gt;= 0 의 형태로 인식하므로, 계산된 비중인 \\(w\\)를 단순히 입력하기만 하면 됩니다. heq.objective = function(w) { sum_w = sum(w) return( sum_w - 1 ) } \\(\\sum_{i=1}^{n}w_i = 1\\) 제약조건에 해당하는 등위 제약조건입니다. 먼저 계산된 비중인 \\(w\\)들의 합계를 구한 후 해당 값에서 1을 빼주는 값을 반환하도록 합니다. 프로그래밍 내에서는 heq == 0 의 형태로 인식을 하므로 결국 (sum_w – 1) == 0, 즉 sum_w == 1의 제약조건과 동일합니다. library(nloptr) result = slsqp( x0 = rep(0.1, 10), fn = objective, hin = hin.objective, heq = heq.objective) print(result$par) ## [1] 1.399e-01 2.286e-17 1.927e-03 -2.680e-18 -7.572e-18 7.927e-01 ## [7] -9.728e-18 5.278e-18 -3.423e-18 6.546e-02 print(result$value) ## [1] 0.000009739 위에서 만들어진 함수들을 바탕으로 최적화 작업을 실행합니다. 초기값인 x0에는 먼저 동일한 비중들을 입력합니다. 예제에서는 종목이 10개 이므로, x0값에는 rep(0.1, 10) 인 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1을 입력합니다. 최소화하고자 하는 목적함수 fn에는 위에서 구성한 objective 함수를 입력합니다. 부등위 제약조건과 등위 제약조건에도 각각 위에서 구성한 hin.objective와 heq.objective 함수를 입력합니다. 즉, 해당 함수는 초기값을 시작점으로 해 주어진 제약조건을 만족하는 해를 찾기 위해 \\(w\\)값들을 조정하는 작업을 반복한 후 목적함수가 최소가 되는 지점의 \\(w\\)를 반환합니다. result 값 중 $par는 최적화된 지점의 해를 의미하며, 최소분산 포트폴리오를 구성하는 자산들의 투자 비중을 의미합니다. $value는 $par에서 산출된 값을 목적함수 fn에 입력하였을 때 나오는 결괏값으로써, 포트폴리오의 분산을 의미합니다. w_1 = result$par %&gt;% round(., 4) %&gt;% setNames(colnames(rets)) print(w_1) ## SPY IEV EWJ EEM TLT IEF IYR RWX GLD DBC ## 0.1399 0.0000 0.0019 0.0000 0.0000 0.7927 0.0000 0.0000 0.0000 0.0655 자산들의 투자비중은 result$par를 통해 추출한 후, round() 함수를 이용해 반올림합니다. 마지막으로 이름에 종목명을 입력합니다. 계산된 비중으로 포트폴리오를 구성하면 포트폴리오의 비중이 최소가 됩니다. 11.1.2 solve.QP() 함수를 이용한 최적화 다음으로는 quadprog 패키지 내의 solve.QP() 함수를 이용해 포트폴리오 최적화를 하는 방법이 있습니다. 해당 함수는 쌍대기법(Dual Method)을 이용해 제약조건 내에서 목적함수가 최소화되는 해를 구합니다. 해당 함수의 목적함수와 제약조건은 표 11.3과 같습니다. 표 11.3: solve.QP 함수 목적함수와 제약조건 목적함수 제약조건 \\(min(-d^Tb+^1/_2b^TDb)\\) \\(A^Tb \\ge b_0\\) 최소분산 포트폴리오의 목적함수가 \\(min\\,^1/_2\\,w&#39;\\Omega w\\)로 표시된다는 점을 생각하면, 해당 함수는 매우 이해하기 쉽게 구성되어 있습니다. \\(b\\)를 각 개별 자산의 투자 비중인 \\(w\\), \\(D\\)를 분산-공분산 행렬인 \\(\\Omega\\)라 생각하면, 목적함수 중 \\(min\\,^1/_2\\,wDw\\)는 최소분산 포트폴리오의 목적함수와 정확히 동일합니다. \\(d\\)를 0으로 생각하면 \\(-d^Tb\\) 또한 0이 되어 목적함수에 아무런 영향도 미치지 않습니다. 제약조건 역시 \\(A^T\\) 항목을 적절하게 수정한다면, 개별 자산의 투자비중이 0 이상인 것과, 투자비중의 합이 1이 되도록 만들 수 있습니다. 이에 대해서는 뒤에서 구체적으로 다루도록 합니다. solve.QP() 함수의 사용법은 아래와 같습니다. solve.QP(Dmat, dvec, Amat, bvec, meq = 0, factorized = FALSE) Dmat은 목적함수 중 \\(D\\)에 해당하는 행렬 부분으로서 분산-공분산 행렬과 일치합니다. dvec은 목적함수 중 \\(d\\)에 해당하는 벡터 부분이며, 포트폴리오 최적화에서는 역할이 없습니다. Amat은 제약조건 중 \\(A^T\\)에 해당하는 부분으로써, 제약조건 중 좌변에 위치하는 항목입니다. 제약조건에서 보듯이 제약조건 행렬을 구한 후 이것의 전치(Transpose) 행렬을 입력해야 하는 데 주의합니다. bvec은 제약조건 중 \\(b_0\\)에 해당하는 부분으로써, 제약조건 중 우변에 위치하는 항목입니다. meq는 bvec의 몇 번째까지를 등위 제약조건으로 설정할지에 대한 부분입니다. 표 11.4는 위의 내용을 요약한 것이며, 각 변수를 입력한 후 함수를 실행하면 위의 목적함수와 제약조건을 만족하는 \\(b\\) 값을 찾습니다. 표 11.4: solve.QP 함수의 인자와 포트폴리오 내 변수 변수명 내용 포트폴리오 내 변수 Dmat 목적함수 중 D 분산-공분산 행렬 dvec 목적함수 중 d 해당사항 없음 Amat 제약조건 (좌변) \\(\\sum_{i=1}^{n}w_i, w_i\\) bvec 제약조건 (우변) 비중의 합이 1, 각 비중이 0보다 큼 meq 등위 제약조건 개수 1개 (비중의 합이 1) solve.QP() 함수를 이용해 최소분산 포트폴리오 비중을 구할 때는 Amat 항목을 제대로 입력하는 것이 가장 중요하며, 나머지 항목은 매우 손쉽게 입력이 가능합니다. 설명된 내용에 해당하는 행렬을 손으로 직접 써가며 계산해본다면 훨씬 이해하기가 쉬울 것입니다. 구체적인 과정은 아래와 같습니다. Dmat = covmat dvec = rep(0, 10) Amat = t(rbind(rep(1, 10), diag(10), -diag(10))) bvec = c(1, rep(0, 10), -rep(1, 10)) meq = 1 Dmat에는 분산-공분산 행렬을 입력하며,dvec은 최소분산 포트폴리오를 구하는데는 필요한 값이 아니므로 0벡터를 입력합니다. 등위 제약조건과 부등위 제약조건(\\(A^Tb \\ge b_0\\))을 행렬의 형태로 표현하면 다음과 같습니다. \\[ \\begin{bmatrix} 1 &amp; \\dots &amp; 1 \\\\ 1 &amp; \\dots &amp; 0 \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; \\dots &amp; 1 \\\\ -1 &amp; \\dots &amp; 0 \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; \\dots &amp; -1 \\\\ \\end{bmatrix} \\begin{bmatrix} w_1 \\\\ w_2 \\\\ \\vdots \\\\ w_{10} \\end{bmatrix} = \\begin{bmatrix} w_1 + w_2 + \\dots + w_{10} \\\\ w_1 \\\\ \\vdots \\\\ w_{10} \\\\ -w_1 \\\\ \\vdots \\\\ -w_{10} \\end{bmatrix} \\ge \\begin{bmatrix} 1 \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ -1 \\\\ \\vdots \\\\ -1 \\end{bmatrix} \\] 이 중 맨 왼쪽 행렬의 전치행렬이 제약조건의 좌변인 Amat에 해당합니다. \\[ Amat = \\begin{bmatrix} 1 &amp; \\dots &amp; 1 \\\\ 1 &amp; \\dots &amp; 0 \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; \\dots &amp; 1 \\\\ -1 &amp; \\dots &amp; 0 \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; \\dots &amp; -1 \\end{bmatrix} ^T \\] 맨 오른쪽 행렬이 제약조건의 우변인 bvec에 해당합니다. \\[ bvec = \\begin{bmatrix} 1 \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ -1 \\\\ \\vdots \\\\ -1 \\end{bmatrix} \\] 위의 제약조건은 크게 투자비중의 합이 1인 제약조건, 최소 투자비중이 0 이상인 제약조건, 최대 투자비중이 1 이하인 제약조건, 총 세 개 부분으로 나눌 수 있습니다. \\[ (1)\\; \\sum_{i = 1}^nw_i = 1 \\Rightarrow \\begin{bmatrix} w_1 + w_2 + \\dots \\ w_{10} \\end{bmatrix} = \\begin{bmatrix} 1 \\end{bmatrix} \\] \\[(2)\\; w_i \\ge 0 \\Rightarrow \\begin{bmatrix} w_1 \\\\ w_2 \\\\ \\vdots \\\\ w_{10} \\end{bmatrix} \\ge \\begin{bmatrix} 0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\end{bmatrix} \\\\\\] \\[(3)\\;-w_i \\ge -1 \\Rightarrow \\begin{bmatrix} -w_1 \\\\ -w_2 \\\\ \\vdots \\\\ -w_{10} \\end{bmatrix} \\ge \\begin{bmatrix} -1 \\\\ -1 \\\\ \\vdots \\\\ -1 \\end{bmatrix} \\] solve.QP() 함수의 제약조건은 항상 좌변이 큰 형태이므로, 최대 투자비중에 대한 제약조건은 다음 행렬의 양변에 마이너스(-)를 곱해 부등호를 맞춰주었습니다. \\[\\begin{bmatrix} w_1 \\\\ w_2 \\\\ \\vdots \\\\ w_{10} \\end{bmatrix} \\le \\begin{bmatrix} 1 \\\\ 1 \\\\ \\vdots \\\\ 1 \\end{bmatrix}\\] 첫 번째 제약조건은 부등호가 아닌 등호, 즉 투자비중의 합이 1인 조건을 의미하므로 meq = 1을 통해 첫 번째 제약조건은 등식 제약조건임을 선언할 수 있습니다. 제약조건의 좌변에 해당하는 Amat을 만드는 과정은 다음과 같습니다. 먼저 rep(1, 10)을 통해 최상단에 위치한 1로 이루어진 행렬을 만들어줍니다. \\[\\begin{bmatrix} 1 &amp; 1 &amp; \\dots &amp; 1 \\end{bmatrix}\\] 하단의 1과 -1로 이루어진 대각행렬은 diag() 함수를 통해 쉽게 만들 수 있습니다. \\[ diag(10) = \\begin{bmatrix} 1 &amp; \\dots &amp; 0 \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; \\dots &amp;\\ 1\\end{bmatrix}\\] \\[ -diag(10) = \\begin{bmatrix} -1 &amp; \\dots &amp; 0 \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; \\dots &amp;\\ -1\\end{bmatrix}\\] rbind() 함수를 통해 세 개의 행렬을 행으로 묶어주면 제약조건의 맨 왼쪽 행렬과 동일한 형태가 됩니다. 이를 t() 함수를 통해 전치행렬을 만들어 준 뒤 Amat에 입력합니다. 제약조건에 해당하는 bvec은 1, 0, -1로 이루어진 벡터를 통해 손쉽게 만들 수 있습니다. library(quadprog) result = solve.QP(Dmat, dvec, Amat, bvec, meq) print(result$solution) ## [1] 1.399e-01 -2.302e-18 1.927e-03 4.940e-18 8.449e-18 7.927e-01 ## [7] 2.133e-18 -1.184e-18 0.000e+00 6.546e-02 print(result$value) ## [1] 0.000004869 위에 입력된 내역들을 solve.QP() 함수에 넣어 최적화 값을 찾아줍니다. 결과 중 $solution은 최적화된 지점의 해, 즉 최소분산 포트폴리오를 구성하는 자산들의 투자비중을 의미합니다. $value는 $solution에서 산출된 값을 목적함수에 입력했을때 나오는 결괏값으로서, 포트폴리오의 분산을 의미합니다. w_2 = result$solution %&gt;% round(., 4) %&gt;% setNames(colnames(rets)) print(w_2) ## SPY IEV EWJ EEM TLT IEF IYR RWX GLD DBC ## 0.1399 0.0000 0.0019 0.0000 0.0000 0.7927 0.0000 0.0000 0.0000 0.0655 자산들의 투자비중은 result$solution을 통해 추출한 후 round() 함수를 이용해 반올림합니다. 마지막으로 이름에 종목명을 입력합니다. 계산된 비중으로 포트폴리오를 구성하면 포트폴리오의 비중이 최소화됩니다. 11.1.3 optimalPortfolio() 함수를 이용한 최적화 RiskPortfolios 패키지의 optimalPortfolio() 함수를 이용해 매우 간단하게 최적화 포트폴리오를 구현할 수도 있습니다. 해당 함수의 사용법은 다음과 같습니다. optimalPortfolio(Sigma, mu = NULL, semiDev = NULL, control = list()) Sigma는 분산-공분산 행렬입니다. mu와 semiDev는 각각 기대수익률과 세미 편차(Semi Deviation)로서, 입력하지 않아도 됩니다. control은 포트폴리오 종류 및 제약조건에 해당하는 부분이며, 자세한 내용은 표 11.5와 같습니다. 표 11.5: optimalPortfolio() 포트폴리오 내 control 인자 종류 입력값 내용 type minvol 최소분산 포트폴리오 type invvol 역변동성 포트폴리오 type erc 위험 균형 포트폴리오 type maxdiv 최대 분산효과 포트폴리오 type riskeff 위험-효율적 포트폴리오 constraint lo 최소 투자 비중이 0 보다 클것 constraint user 최소(LB) 및 최대 투자 비중(UB) 설정 control 항목에서 원하는 포트폴리오 타입과 제약조건을 입력해주면, 매우 손쉽게 최적화 포트폴리오를 구현할 수 있습니다. library(RiskPortfolios) w_3 = optimalPortfolio(covmat, control = list(type = &#39;minvol&#39;, constraint = &#39;lo&#39;)) %&gt;% round(., 4) %&gt;% setNames(colnames(rets)) print(w_3) ## SPY IEV EWJ EEM TLT IEF IYR RWX GLD DBC ## 0.1399 0.0000 0.0019 0.0000 0.0000 0.7927 0.0000 0.0000 0.0000 0.0655 optimalPortfolio() 함수 내부에 분산-공분산 행렬을 입력합니다. type 부분에 최소분산 포트폴리오에 해당하는 minvol을 입력하며, constraint에는 각 자산의 비중이 0보다 큰 제약조건인 lo(Long Only)를 입력합니다. 비중의 합이 1인 제약조건은 자동적으로 적용이 됩니다. 이처럼 패키지를 이용하면 훨씬 간단하게 원하는 값을 얻을 수 있습니다. GitHub를 통해 해당 함수의 코드를 살펴보면 solve.QP() 함수를 이용해 작성한 방법과 거의 동일합니다. 따라서 위의 과정들을 대략적으로 이해한 후 패키지를 사용해 포트폴리오 최적화를 구현하는 것이 현명한 방법이 될 수도 있습니다. 11.1.4 결괏값들의 비교 아래 표는 slsqp(), solve.QP(), optimalPortfolio()를 이용하여 구한 값들의 비교입니다. 표 11.6: 최적화 결과 비교 SPY IEV EWJ EEM TLT IEF IYR RWX GLD DBC slsqp 0.1399 0 0.0019 0 0 0.7927 0 0 0 0.0655 solve.QP 0.1399 0 0.0019 0 0 0.7927 0 0 0 0.0655 optimalPortfolio 0.1399 0 0.0019 0 0 0.7927 0 0 0 0.0655 세 가지 방법 모두 결과가 동일합니다. 그러나 여기서 나온 결과를 이용해 그대로 투자하기에는 문제가 있습니다. 일부 자산은 투자비중이 0%, 즉 전혀 투자하지 않는 반면, 특정 자산에 대부분의 비중인 79.27%를 투자하는 편중된 결과가 나옵니다. library(ggplot2) data.frame(w_1) %&gt;% ggplot(aes(x = factor(rownames(.), levels = rownames(.)), y = w_1)) + geom_col() + xlab(NULL) + ylab(NULL) 이처럼 변동성이 가장 낮은 종목에 대부분의 비중이 투자되는 구석해(Corner Solution) 문제를 해결하기 위해 각 자산의 최소 및 최대 투자비중 제약조건을 추가해 줄 필요가 있습니다. 11.1.5 최소 및 최대 투자비중 제약조건 구석해 문제를 방지하고, 모든 자산에 골고루 투자하기 위해 개별 투자비중을 최소 5%, 최대 20%로 하는 제약조건을 추가하겠습니다. 먼저 slsqp() 함수에서 제약조건을 추가하는 방법은 다음과 같습니다. result = slsqp( x0 = rep(0.1, 10), fn = objective, hin = hin.objective, heq = heq.objective, lower = rep(0.05, 10), upper = rep(0.20, 10)) w_4 = result$par %&gt;% round(., 4) %&gt;% setNames(colnames(rets)) print(w_4) ## SPY IEV EWJ EEM TLT IEF IYR RWX GLD DBC ## 0.0500 0.0500 0.0500 0.0500 0.2000 0.2000 0.0500 0.0500 0.1995 0.1005 함수의 마지막에 lower와 upper 제약조건을 추가로 입력하면 해당 값 사이에서 최적화를 만족하는 해를 찾게 되며, 해당 예에서는 5%와 20% 사이에서 해를 찾게 됩니다. 추가로 입력한 제약조건에 맞게, 최소 투자비중은 5%이며, 최대 투자비중은 20%임을 확인할 수 있습니다. 다음은 solve.QP() 함수 내에서 제약조건을 추가하는 방법입니다. 해당 함수 역시 다른 입력값은 모두 동일하며, 제약조건의 우변에 해당하는 bvec 항목만 수정하면 됩니다. 최소, 최대 투자비중 제약조건을 기존 [0, 1]에서 [0.05, 0.20] 로 변경하면, bvec에 해당하는 행렬은 다음과 같이 변경됩니다. \\[ 기존: \\begin{bmatrix} w_1 + w_2 + \\dots + w_{10} \\\\ w_1 \\\\ \\vdots \\\\ w_{10} \\\\ -w_1 \\\\ \\vdots \\\\ -w_{10} \\end{bmatrix} \\ge \\begin{bmatrix} 1 \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ -1 \\\\ \\vdots \\\\ -1 \\end{bmatrix} \\\\ \\] \\[변경: \\begin{bmatrix} w_1 + w_2 + \\dots + w_{10} \\\\ w_1 \\\\ \\vdots \\\\ w_{10} \\\\ -w_1 \\\\ \\vdots \\\\ -w_{10} \\end{bmatrix} \\ge \\begin{bmatrix} 1 \\\\ 0.05 \\\\ \\vdots \\\\ 0.05 \\\\ -0.20 \\\\ \\vdots \\\\ -0.20 \\end{bmatrix} \\] Dmat = covmat dvec = rep(0, 10) Amat = t(rbind(rep(1, 10), diag(10), -diag(10))) bvec = c(1, rep(0.05, 10), -rep(0.20, 10)) meq = 1 result = solve.QP(Dmat, dvec, Amat, bvec, meq) w_5 = result$solution %&gt;% round(., 4) %&gt;% setNames(colnames(rets)) print(w_5) ## SPY IEV EWJ EEM TLT IEF IYR RWX GLD DBC ## 0.0500 0.0500 0.0500 0.0500 0.2000 0.2000 0.0500 0.0500 0.1995 0.1005 bvec 항목을 제외한 모든 코드는 기존과 동일하며, 조건함수의 우변인 bvec만 각각 최소 투자비중과 최대 투자비중이 [0, 1]에서 [0.05, 0.20]으로 변경되었습니다. 해당 방법 역시 추가적인 투자비중 제약이 잘 적용되었음이 확인됩니다. 마지막으로 optimalPortfolio() 함수 내에서 최소 및 최대 투자비중을 추가하는 방법입니다. 입력변수의 control 항목 중 constraint 부분을 간단하게 수정해 원하는 조건을 입력할 수 있습니다. w_6 = optimalPortfolio(covmat, control = list(type = &#39;minvol&#39;, constraint = &#39;user&#39;, LB = rep(0.05, 10), UB = rep(0.20, 10))) %&gt;% round(., 4) %&gt;% setNames(colnames(rets)) print(w_6) ## SPY IEV EWJ EEM TLT IEF IYR RWX GLD DBC ## 0.0500 0.0500 0.0500 0.0500 0.2000 0.2000 0.0500 0.0500 0.1995 0.1005 constraint 부분에 롱온리 제약조건에 해당하는 lo 대신 직접 제약값들을 입력할 수 있는 user를 입력하며, LB에는 최소 투자비중 벡터를, UB에는 최대 투자비중 벡터를 입력합니다. 따라서 원하는 제약조건 내에서 결괏값이 계산됩니다. 표 11.7: 최소 및 최대 비중제약 조건 후 결과 비교 SPY IEV EWJ EEM TLT IEF IYR RWX GLD DBC slsqp 0.05 0.05 0.05 0.05 0.2 0.2 0.05 0.05 0.1995 0.1005 solve.QP 0.05 0.05 0.05 0.05 0.2 0.2 0.05 0.05 0.1995 0.1005 optimalPortfolio 0.05 0.05 0.05 0.05 0.2 0.2 0.05 0.05 0.1995 0.1005 최소 및 최대 제약조건을 추가한 경우도 세 가지 방법 모두 동일한 결과가 나오게 되며, 비중도 각각 5%와 20%로 제한되어 구석해 문제 또한 해결되었음이 확인됩니다. data.frame(w_4) %&gt;% ggplot(aes(x = factor(rownames(.), levels = rownames(.)), y = w_4)) + geom_col() + geom_hline(aes(yintercept = 0.05), color = &#39;red&#39;) + geom_hline(aes(yintercept = 0.20), color = &#39;red&#39;) + xlab(NULL) + ylab(NULL) 11.1.6 각 자산별 제약조건의 추가 투자 규모가 크지 않다면 위에서 추가한 제약조건만으로도 충분히 훌륭한 포트폴리오가 구성됩니다. 그러나 투자 규모가 커지면 추가적인 제약조건들을 고려해야 할 경우가 생깁니다. 벤치마크 비중과의 괴리로 인한 추적오차(Tracking Error)를 고려해야 할 수도 있고, 투자 대상별 거래량을 고려한 제약조건을 추가해야 할 때도 있습니다. 기존 제약조건에는 자산별로 동일한 최소 및 최대 투자비중 제약조건을 다루었지만, 자산별로 상이한 제약조건이 필요할 경우도 있습니다. slsqp()와 optimalPortfolio() 함수에서는 복잡한 제약조건을 다루기가 힘들지만, solve.QP() 함수는 bvec 부분을 간단하게 수정해 어렵지 않게 구현이 가능합니다. 먼저 표 11.8은 새롭게 설정하고자 하는 각 자산별 최소 및 최대 제약조건입니다. 표 11.8: 각 자산 별 최소 및 최대 제약조건 제약 1 2 3 4 5 6 7 8 9 10 최소 0.10 0.10 0.05 0.05 0.10 0.10 0.05 0.05 0.03 0.03 최대 0.25 0.25 0.20 0.20 0.20 0.20 0.10 0.10 0.08 0.08 이를 행렬의 형태로 나타내면 다음과 같습니다. \\[ \\begin{bmatrix} 1 &amp; \\dots &amp; 1 \\\\ 1 &amp; \\dots &amp; 0 \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; \\dots &amp; 1 \\\\ -1 &amp; \\dots &amp; 0 \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; \\dots &amp; -1 \\\\ \\end{bmatrix} \\begin{bmatrix} w_1 \\\\ w_2 \\\\ \\vdots \\\\ w_{10} \\end{bmatrix} = \\begin{bmatrix} w_1 + w_2 + \\dots + w_{10} \\\\ w_1 \\\\ w_2 \\\\ w_3 \\\\ w_4 \\\\ w_5 \\\\ w_6 \\\\ w_7\\\\ w_8\\\\ w_9\\\\ w_{10} \\\\ -w_1 \\\\ -w_2 \\\\ -w_3 \\\\ -w_4 \\\\ -w_5 \\\\ -w_6 \\\\ -w_7 \\\\ -w_8 \\\\ -w_9 \\\\ -w_{10} \\end{bmatrix} \\ge \\begin{bmatrix} 1 \\\\ 0.10 \\\\ 0.10 \\\\ 0.05 \\\\ 0.05 \\\\ 0.10 \\\\ 0.10 \\\\ 0.05 \\\\ 0.05 \\\\ 0.03 \\\\ 0.03 \\\\ -0.25 \\\\ -0.25 \\\\ -0.20 \\\\ -0.20 \\\\ -0.20 \\\\ -0.20 \\\\ -0.10 \\\\ -0.10 \\\\ -0.08 \\\\ -0.08 \\end{bmatrix} \\] 위의 행렬 중 오른쪽 부분을 bvec에 그대로 입력합니다. Dmat = covmat dvec = rep(0, 10) Amat = t(rbind(rep(1, 10), diag(10), -diag(10))) bvec = c(1, c(0.10, 0.10, 0.05, 0.05, 0.10, 0.10, 0.05, 0.05, 0.03, 0.03), -c(0.25, 0.25, 0.20, 0.20, 0.20, 0.20, 0.10, 0.10, 0.08, 0.08)) meq = 1 result = solve.QP(Dmat, dvec, Amat, bvec, meq) result$solution %&gt;% round(., 4) %&gt;% setNames(colnames(rets)) ## SPY IEV EWJ EEM TLT IEF IYR RWX GLD DBC ## 0.1039 0.1000 0.0861 0.0500 0.2000 0.2000 0.0500 0.0500 0.0800 0.0800 결괏값을 확인해보면 각 자산별 제약조건 내에 위치함을 확인할 수 있습니다. 11.2 최대분산효과 포트폴리오 앞서 설명했듯이 포트폴리오의 변동성은 \\(\\sum_{i=1}^{n}\\sum_{j=1}^{n}w_iw_j\\sigma_{ij}\\) 형태로 나타나며, 이는 다음과 같이 표현할 수도 있습니다. \\[\\sigma_p^2 = \\sum_{i=1}^{n}\\sum_{j=1}^{n}w_iw_j\\sigma_{ij} = \\sum_{i=1}^nw_i^2\\sigma_i^2 + \\sum_{i=1}^{n}\\sum_{i \\ne j}^{n}w_iw_j\\rho_{ij}\\sigma_i\\sigma_j \\] 이 중 \\(\\sum_{i=1}^{n}\\sum_{i \\ne j}^{n}w_iw_j\\rho_{ij}\\sigma_i\\sigma_j\\) 부분에는 자산 간 상관관계\\((\\rho_{ij})\\)가 포함되어 있습니다. 상관관계는 -1과 1 사이에 위치하며 상관관계가 1, 즉 두 자산이 완벽하게 동일한 경우에는 포트폴리오의 변동성은 개별 자산 변동성의 가중합과 같습니다. 그러나 상관관계가 낮아질수록 포트폴리오의 변동성 또한 점차 낮아집니다. 이러한 효과를 투자에서는 분산효과라고 합니다. 이러한 분산효과의 정도를 측정하는 지표가 분산 비율(DR: Diversification Ratio)입니다. 분산 비율의 분자는 개별 변동성의 가중합이며, 분모는 포트폴리오의 변동성입니다. 이를 수식으로 나타내면 다음과 같습니다. \\[ 분산\\,비율 = \\frac{\\sum w_i \\sigma_i}{\\sigma_p} = \\frac{w&#39;\\sigma}{\\sqrt{w&#39;\\Omega w}}\\] 모든 자산 간의 상관관계가 1일 경우, 위의 예시에서 살펴본 것과 같이 포트폴리오의 변동성은 개별 자산 변동성의 가중합과 같아지게 됩니다. 즉, \\(\\sum w_i \\sigma_i = \\sigma_p\\)가 되어, 분산 비율은 1이 됩니다. 그러나 대부분의 경우에서 자산 간의 상관관계는 1보다 낮으며, 이로 인해 포트폴리오의 분산은 단순 가중합보다 작아지게 되고(\\(\\sigma_p &lt; \\sum w_i\\sigma_i\\)), 분산 비율은 1보다 커지게 됩니다. 자산 간 상관관계가 낮은 종목을 위주로 포트폴리오를 구성할수록 분산효과로 인해 포트폴리오의 변동성은 낮아지고, 분산 비율은 점점 커집니다. 최대분산효과 포트폴리오(Most Diversified Portfolio)는 분산효과가 최대가 되는, 즉 분산 비율이 최대가 되는 포트폴리오를 구성하는 방법입니다. 이에 대한 목적함수와 제약조건은 다음과 같습니다. \\[목적함수: max\\,DR = max \\frac{\\sum w_i \\sigma_i}{\\sigma_p}\\] \\[제약조건: \\sum_{i=1}^n w_i = 1, w_i \\ge 0\\] 최대분산효과 포트폴리오의 목적함수는 분산비율을 최대화하는 데 있는 반면, 대부분의 최적화 프로그래밍은 목적함수를 최소화하는 형태로 이루어집니다. 따라서 목적함수인 \\(maxDR\\)을 최소화하는 형태로 바꿀 필요가 있는데 크게 세 가지 방법이 있습니다. Choueifaty Synthetic Asset Back-Transformation을 이용하는 방법(Choueifaty and Coignard 2008) Duality를 이용하는 방법(Choueifaty, Froidure, and Reynier 2013) Min (-)DR 방법 먼저 Choueifaty Synthetic Asset Back-Transformation 방법은 목적함수 \\(min\\,w_s&#39;cw_s\\)와 제약조건 \\(\\sum_{i=1}^n w_i = 1, w_i \\ge 0\\)을 만족하는 자산별 비중을 구합니다. 그 후, 구해진 비중을 각각의 표준편차로 나누어주며, 비중의 합이 1이 되도록 표준화해줍니다. 여기서 주의할 점은 목적함수의 \\(c\\)가 우리가 지금까지 사용하던 분산-공분산 행렬이 아닌, 상관관계 행렬이라는 점입니다. Duality 방법의 목적함수는 최소분산 포트폴리오와 동일한 \\(min^1/_2w&#39;\\sigma w\\)이며, 제약조건만 \\(\\sum_{i=1}^n w_i \\sigma_i = 1, w_i \\ge 0\\), 즉 개별 자산의 비중이 0보다 크고 개별 표준편차의 가중합이 1인 조건으로 바뀝니다. 그 후, 비중의 합이 1이 되도록 표준화를 해줍니다. 기존 두 방법이 수학적 증명에 의해 \\(maxDR\\)을 최소화하는 형태로 풀어준 반면, 간단하게 목적함수를 \\(min(-DR)\\)의 형태로 바꾸어 풀 수도 있습니다. 표 11.3는 세 가지 방법을 요약한 내용입니다. 표 11.9: MDP 방법 비교 방법 목적함수 제약조건 표준화 Transformation \\(min\\,w_s&#39;cw_s\\) \\(\\sum_{i=1}^n w_i = 1\\) \\(w_i \\ge 0\\) 비중을 각각의 표준편차로 나눈 후 비중의 합으로 표준화 Duality \\(min\\,^1/_2w&#39;\\sigma w\\) \\(\\sum_{i=1}^n w_i \\sigma_i = 1\\) \\(w_i \\ge 0\\) 비중의 합으로 표준화 -DR min(-DR) \\(\\sum_{i=1}^n w_i = 1\\) \\(w_i \\ge0\\) 불필요 11.2.1 solve.QP() 함수를 이용한 최적화 먼저 solve.QP() 함수를 이용해 Duality 방법을 통해 최대분산효과 포트폴리오를 만족하는 해를 찾도록 하겠습니다. Duality 방법에서 목적함수는 \\(min\\,^1/_2w&#39;\\sigma w\\)로 최소분산 포트폴리오와 동일하며, 제약조건은 \\(\\sum_{i=1}^n w_i \\sigma_i = 1, w_i \\ge 0\\)입니다. 제약조건 부분인 Amat과 bvec 부분을 입력할 때 이 부분을 고려해야 합니다. Dmat = covmat dvec = rep(0, 10) Amat = t(rbind(sqrt(diag(covmat)), diag(10))) bvec = c(1, rep(0, 10)) meq = 1 제약조건에 해당하는 Amat 부분과 bvec 부분은 최소분산 포트폴리오와 다소 다릅니다. 표 11.10에는 둘 간에 코드가 어떻게 다른지 나타나 있습니다. 표 11.10: Amat과 bvec 차이 비교 인자 최소분산 포트폴리오 최대분산효과 포트폴리오 Amat t(rbind(rep(1, 10), diag(10), -diag(10))) t(rbind(sqrt(diag(covmat)), diag(10))) bvec c(1, rep(0, 10), -rep(1, 10)) c(1, rep(0, 10)) 이해를 위해 Duality 방법의 제약조건을 행렬의 형태로 표현하면 다음과 같습니다. \\[ \\begin{bmatrix} \\sigma_1 &amp; \\dots &amp; \\sigma_{10} \\\\ 1 &amp; \\dots &amp; 0 \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; \\dots &amp; 1 \\end{bmatrix} \\begin{bmatrix} w_1 \\\\ w_2 \\\\ \\vdots \\\\ w_{10} \\end{bmatrix} = \\begin{bmatrix} \\sigma_1w_1 + \\sigma_2w_2 + \\dots + \\sigma_{10}w_{10} \\\\ w_1 \\\\ \\vdots \\\\ w_{10} \\\\ \\end{bmatrix} \\ge \\begin{bmatrix} 1 \\\\ 0 \\\\ \\vdots \\\\ 0 \\end{bmatrix} \\] 1행의 \\(\\sigma_1w_1 + \\sigma_2w_2 + \\dots + \\sigma_{10}w_{10}\\)은 \\(\\sum_{i=1}^n w_i \\sigma_i = 1\\)과 같으며, 해당 식은 등위제약조건으로서 \\(\\sum_{i=1}^n w_i \\sigma_i = \\sigma_1w_1 + \\sigma_2w_2 + \\dots + \\sigma_{10}w_{10} = 1\\)을 의미합니다. 2행부터 마지막 행까지는 모두 \\(w_i \\ge 0\\) 조건으로써, 개별 자산의 투자비중이 0보다 큰 조건을 의미합니다. 행렬의 맨 왼쪽에 해당하는 Amat은 각 자산의 표준편차로 이루어진 벡터 행렬과, 1로 이루어진 대각행렬로 구성되어 있습니다. 먼저 diag(covmat)을 통해 분산-공분산 부분에서 대각 부분, 즉 분산 부분만을 추출할 수 있습니다. 개별 자산의 분산인 \\(\\sigma_{i,i}\\)는 \\(\\sigma_i\\sigma_i\\rho_{1,1}\\) 형태로 쓸 수 있으며, \\(\\rho_{1,1} = 1\\)을 적용하면 \\(\\sigma_i^2\\)와 같습니다. 따라서 대각부분 값에 제곱근을 계산하는 sqrt() 함수를 적용하면 각각의 표준편차만 남게 됩니다. 이를 diag(10)을 통해 만든 대각행렬과 행으로 묶어준 후 전치행렬을 입력해 줍니다. bvec는 행렬의 맨 오른쪽과 같이 등위 제약조건에 해당하는 1과 부등위 제약조건에 해당하는 0들로 구성되어 있습니다. 차후에 표준화 과정을 거쳐야 하므로 Duality 방법에서는 개별 자산의 투자비중이 1보다 작은 조건을 입력하지 않아도 됩니다. result = solve.QP(Dmat, dvec, Amat, bvec, meq) w = result$solution %&gt;% round(., 4) %&gt;% setNames(colnames(rets)) print(w) ## SPY IEV EWJ EEM TLT IEF IYR RWX GLD DBC ## 15.600 1.615 5.280 0.000 26.375 37.690 3.277 0.000 7.775 12.512 입력된 목적함수와 제약조건들을 바탕으로 solve.QP() 함수를 통해 최적화를 수행한 후 최대분산효과를 만족하는 해를 구해보면, 비중의 합이 1을 초과하게 됩니다. \\(w_i = \\frac{w_i}{\\sum_{i=1}^nw_i}\\)를 통해 비중의 합이 1이 되도록 표준화를 해줍니다. w = (w / sum(w)) %&gt;% round(., 4) print(w) ## SPY IEV EWJ EEM TLT IEF IYR RWX GLD DBC ## 0.1417 0.0147 0.0479 0.0000 0.2395 0.3423 0.0298 0.0000 0.0706 0.1136 표준화 과정을 통해 비중의 합이 1이 되었습니다. data.frame(w) %&gt;% ggplot(aes(x = factor(rownames(.), levels = rownames(.)), y = w)) + geom_col() + geom_col() + xlab(NULL) + ylab(NULL) 11.2.2 optimalPortfolio() 함수를 이용한 최적화 최소분산 포트폴리오와 동일하게 optimalPortfolio() 함수를 이용해 매우 간단하게 최대분산효과 포트폴리오를 구현할 수 있습니다. w = optimalPortfolio(covmat, control = list(type = &#39;maxdiv&#39;, constraint = &#39;lo&#39;)) %&gt;% round(., 4) print(w) ## [1] 0.1417 0.0147 0.0479 0.0000 0.2395 0.3423 0.0298 0.0000 0.0706 0.1136 control 항목의 type에 maximum diversification을 의미하는 ’maxdiv’를 입력해주며, 제약조건에는 투자비중이 0보다 큰 lo(Long Only) 조건을 입력합니다. 패키지를 활용해 매우 간단하게 최대분산효과 포트폴리오를 구현할 수 있으며, 그 결과 또한 앞에서 계산한 것과 동일합니다. 해당 함수의 코드를 확인해보면, 최대분산효과 포트폴리오 계산 시 Min -DR 방법을 사용합니다. 11.2.3 최소 및 최대 투자비중 제약조건 최대분산효과 포트폴리오 역시 구석해 문제가 발생하며, 모든 자산에 골고루 투자하기 위해 개별 투자비중을 최소 5%, 최대 20%로 하는 제약조건을 추가하겠습니다. Duality 방법에서는 목적함수인 \\(min\\,^1/_2w&#39;\\sigma w\\)과 제약조건인 \\(\\sum_{i=1}^n w_i \\sigma_i = 1, w_i \\ge 0\\)에 맞게 해를 구한 후 비중의 합이 1이 되도록 표준화하는 과정을 거쳤습니다. 따라서 비중의 최소 및 최대 제약조건은 단순히 \\(lb \\le w_i \\le ub\\)가 아닌 표준화 과정인 \\(w_i = \\frac{w_i}{\\sum_{i=1}^nw_i}\\)까지 고려해 적용해야 합니다. 표 11.11는 이를 수식으로 나타낸 것입니다. 표 11.11: 최소 및 최대비중 제약조건 최소비중 제약조건 최대비중 제약조건 \\(\\frac{w_i}{\\sum_{i=1}^nw_i} \\ge lb\\) \\(\\frac{w_i}{\\sum_{i=1}^nw_i} \\le ub\\) \\(\\Rightarrow -lb + \\frac{w_i}{\\sum_{i=1}^nw_i} \\ge 0\\) \\(\\Rightarrow ub - \\frac{w_i}{\\sum_{i=1}^nw_i} \\ge 0\\) \\(\\Rightarrow -lb + \\frac{w_i}{e^Tw} \\ge 0\\) \\(\\Rightarrow ub - \\frac{w_i}{e^Tw} \\ge 0\\) \\(\\Rightarrow -lb \\times e^Tw + w \\ge 0\\) \\(\\Rightarrow ub \\times e^Tw - w \\ge 0\\) \\(\\Rightarrow (-lb \\times e^T + I)w \\ge 0\\) \\(\\Rightarrow (ub \\times e^T - I)w \\ge 0\\) 최소 비중 제약조건인 \\(-lb \\times e^T + I\\)의 예를 행렬로 풀어보도록 하겠습니다. \\(-lb \\times e^T\\)의 경우 행렬로 표현하면 다음과 같으며, \\(-lb\\)로 이루어진 \\(n \\times n\\) 행렬입니다. \\[ \\begin{bmatrix} -lb \\\\ \\vdots \\\\ -lb \\end{bmatrix} \\begin{bmatrix} 1 \\\\ \\vdots \\\\ 1 \\end{bmatrix}^T = \\begin{bmatrix} -lb \\\\ \\vdots \\\\ -lb \\end{bmatrix} \\begin{bmatrix} 1 &amp; \\dots &amp; 1 \\end{bmatrix} = \\begin{bmatrix} -lb &amp; \\dots &amp; -lb \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ -lb &amp; \\dots &amp; -lb \\end{bmatrix}\\] \\(I\\)는 대각선 부분이 1, 나머지가 0인 항등행렬을 의미합니다. 따라서 \\((-lb \\times e^T + I)\\)를 계산하면 다음과 같습니다. \\[\\begin{bmatrix} -lb + 1 &amp; \\dots &amp; -lb \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ -lb &amp; \\dots &amp; -lb + 1 \\end{bmatrix}\\] 최소분산 포트폴리오와는 다르게 Duality 방법으로 최대분산효과 포트폴리오를 구현하면 최소 및 최대 제약조건이 우변이 아닌 좌변에 들어가게 되며, 해당 제약조건을 고려해 행렬로 표현하면 다음과 같습니다. \\[ \\begin{bmatrix} \\sigma_1 &amp; \\dots &amp; \\sigma_{10} \\\\ -lb + 1 &amp; \\dots &amp; -lb \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ -lb &amp; \\dots &amp; -lb + 1 \\\\ ub-1 &amp; \\dots &amp; ub \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ ub &amp; \\dots &amp; ub-1 \\end{bmatrix} \\begin{bmatrix} w_1 \\\\ w_2 \\\\ \\vdots \\\\ w_{10} \\end{bmatrix} = \\begin{bmatrix} \\sigma_1w_1 + \\sigma_2w_2 + \\dots + \\sigma_{10}w_{10} \\\\ -lb(w_1 + w_2 + \\dots + w_{10}) + w_1 \\\\ \\vdots \\\\ -lb(w_1 + w_2 + \\dots + w_{10}) + w_{10} \\\\ wb(w_1 + w_2 + \\dots + w_{10}) - w_1 \\\\ \\vdots \\\\ ub(w_1 + w_2 + \\dots + w_{10}) - w_{10} \\end{bmatrix} \\ge \\begin{bmatrix} 1 \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\end{bmatrix} \\] 첫 번째 행 \\(\\sigma_1w_1 + \\sigma_2w_2 + \\dots + \\sigma_{10}w_{10}\\)은 등위 제약조건인 \\(\\sum_{i=1}^n w_i \\sigma_i = 1\\)에 해당하며, 두 번째 행부터는 부등위 제약조건에 해당합니다. 두 번째 행을 정리하면 \\(\\frac{w_1}{w_1+w_2+\\dots+w_{10}} \\ge lb\\), 즉 비중의 표준화가 고려된 최소비중 제약조건입니다. 마지막 행 역시 정리하면 \\(\\frac{w_1}{w_1+w_2+\\dots+w_{10}} \\le ub\\)가 되어 비중의 표준화가 고려된 최대비중 제약조건을 의미합니다. 위 행렬을 고려해 Amat과 bvec을 수정한 코드는 다음과 같습니다. Dmat = covmat dvec = rep(0, 10) Alb = -rep(0.05, 10) %*% matrix(1, 1, 10) + diag(10) Aub = rep(0.20, 10) %*% matrix(1, 1, 10) - diag(10) Amat = t(rbind(sqrt(diag(covmat)), Alb, Aub)) bvec = c(1, rep(0, 10), rep(0, 10)) meq = 1 result = solve.QP(Dmat, dvec, Amat, bvec, meq) w = result$solution w = (w / sum(w)) %&gt;% round(., 4) %&gt;% setNames(colnames(rets)) print(w) ## SPY IEV EWJ EEM TLT IEF IYR RWX GLD DBC ## 0.0500 0.0500 0.0500 0.0500 0.2000 0.2000 0.0500 0.0500 0.1855 0.1145 Alb의 -rep(0.05, 10)는 \\(-lb\\) 부분, matrix(1, 1, 10)은 \\(e^T\\) 부분, diag(10)부분은 \\(I\\) 부분을 의미하며, 이는 최소비중 제약조건의 좌변(\\(-lb \\times e^T + I\\))과 같습니다. 동일하게 Aub는 최대비중 제약조건의 좌변(\\(ub \\times e^T - I\\))과 같으며, 결과를 확인하면 최소 및 최대비중 제약조건인 [5%, 20%]가 제대로 반영되었습니다. data.frame(w) %&gt;% ggplot(aes(x = factor(rownames(.), levels = rownames(.)), y = w)) + geom_col() + geom_hline(aes(yintercept = 0.05), color = &#39;red&#39;) + geom_hline(aes(yintercept = 0.20), color = &#39;red&#39;) + xlab(NULL) + ylab(NULL) 11.2.4 각 자산 별 제약조건의 추가 최소분산 포트폴리오와 동일하게 자산별로 다른 제약조건을 추가해 포트폴리오를 구성하겠습니다. 표 11.12는 각 자산별 최소 및 최대 투자비중 값이며, 변경된 제약조건을 행렬의 형태로 나타내었습니다. 주의해야 할 점은 최소비중과 최대비중의 제약조건 추가 시 \\(\\frac{w_1}{w_1+w_2+\\dots+w_{10}} \\ge lb\\) 형태로 고려해야 한다는 점입니다. 표 11.12: 각 자산 별 최소 및 최대 제약조건 제약 1 2 3 4 5 6 7 8 9 10 최소 0.10 0.10 0.05 0.05 0.10 0.10 0.05 0.05 0.03 0.03 최대 0.25 0.25 0.20 0.20 0.20 0.20 0.10 0.10 0.08 0.08 \\[ \\scriptsize \\begin{bmatrix} \\sigma_1 &amp; \\sigma_2 &amp; \\dots &amp; \\sigma_{10} \\\\ -lb_1 + 1 &amp; -lb_1 &amp; \\dots &amp; -lb_1 \\\\ -lb_2 &amp; -lb_2 + 1 &amp; \\dots &amp; -lb_2 \\\\ \\vdots &amp; \\ddots &amp; \\dots &amp; \\vdots \\\\ -lb_{10} &amp; -lb_{10} &amp; \\dots &amp; -lb_{10} + 1 \\\\ ub_1 - 1 &amp; ub_1 &amp; \\dots &amp; ub_1 \\\\ ub_2 &amp; ub_2 - 1 &amp; \\dots &amp; ub_2 \\\\ \\vdots &amp; \\ddots &amp; \\dots &amp; \\vdots \\\\ ub_{10} &amp; ub_{10} &amp; \\dots &amp; ub_{10} - 1 \\end{bmatrix} \\begin{bmatrix} w_1 \\\\ w_2 \\\\ \\vdots \\\\ w_{10} \\end{bmatrix} = \\begin{bmatrix} \\sigma_1w_1 + \\sigma_2w_2 + \\dots + \\sigma_{10}w_{10} \\\\ -lb_1(w_1 + w_2 + \\dots + w_{10}) + w_1 \\\\ -lb_2(w_1 + w_2 + \\dots + w_{10}) + w_2\\\\ \\vdots \\\\ -lb_{10}(w_1 + w_2 + \\dots + w_{10}) + w_{10} \\\\ wb_1(w_1 + w_2 + \\dots + w_{10}) - w_1 \\\\ wb_2(w_1 + w_2 + \\dots + w_{10}) - w_2 \\\\ \\vdots \\\\ ub_{10}(w_1 + w_2 + \\dots + w_{10}) - w_{10} \\end{bmatrix} \\ge \\begin{bmatrix} 1 \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\end{bmatrix} \\] 기존에 공통적으로 적용되던 최소 및 최대 투자비중이 자산별로 다르게 구성되었습니다. 따라서 \\(-lb \\times e^T + I\\)와 \\(ub \\times e^T - I\\)만 \\(-lb_i \\times e^T + I\\) \\(ub_i \\times e^T - I\\)로 수정하면 해당 제약조건 역시 손쉽게 구현이 가능합니다. Dmat = covmat dvec = rep(0, 10) Alb = -c(0.10, 0.10, 0.05, 0.05, 0.10, 0.10, 0.05, 0.05, 0.03, 0.03) %*% matrix(1, 1, 10) + diag(10) Aub = c(0.25, 0.25, 0.20, 0.20, 0.20, 0.20, 0.10, 0.10, 0.08, 0.08) %*% matrix(1, 1, 10) - diag(10) Amat = t(rbind(sqrt(diag(covmat)), Alb, Aub)) bvec = c(1, rep(0, 10), rep(0, 10)) meq = 1 result = solve.QP(Dmat, dvec, Amat, bvec, meq) w = result$solution w = (w / sum(w)) %&gt;% round(., 4) %&gt;% setNames(colnames(rets)) print(w) ## SPY IEV EWJ EEM TLT IEF IYR RWX GLD DBC ## 0.10 0.10 0.09 0.05 0.20 0.20 0.05 0.05 0.08 0.08 최소 및 최대투자비중 제약조건을 나타내는 Alb와 Aub 부분이 자산별 각각의 제약비중으로 변경되었으며, 나머지 부분은 모두 동일합니다. 결괏값들이 모두 제약조건 내에 위치함을 확인할 수 있습니다. 11.3 위험균형 포트폴리오 포트폴리오를 구성하는 자산들과 전체 위험의 관계를 이해하기 위해서는, 먼저 한계 위험기여도(MRC: Marginal Risk Contribution)와 위험기여도(RC: Risk Contribution)에 대해 알아야 합니다. 한계 위험기여도는 특정 자산의 비중을 한 단위 증가시켰을 때 전체 포트폴리오의 위험의 증가를 나타내는 단위로서, 수학의 편미분과 같은 개념입니다. \\(i\\)번째 자산의 한계 위험기여도는 아래와 같이 나타낼 수 있습니다. \\[MRC_i = \\frac{\\partial\\sigma_p}{\\partial w_i} \\] \\(\\sqrt {f&#39;(x)} = \\frac{f&#39;(x)}{2\\sqrt{f(x)}}\\)인 사실을 이용하면, 한계 위험기여도는 다음과 같이 풀 수 있습 니다. 결과적으로 분자는 분산-공분산 행렬과 각 자산의 비중의 곱, 분모는 포트폴리오의 표준편차 형태로 나타납니다. \\[\\begin{equation*} \\begin{split} \\frac{\\partial\\sigma_p}{\\partial w} &amp; = \\frac{\\partial(\\sqrt{w&#39;\\Omega w})}{\\partial w} \\\\ &amp; =\\frac{\\partial(w&#39;\\Omega w)}{\\partial w} \\times \\frac{1}{2\\sqrt{w&#39;\\Omega w}} \\\\ &amp; =\\frac{2\\Omega w}{2\\sqrt{w&#39;\\Omega w}} \\\\ &amp; =\\frac{\\Omega w}{\\sqrt{w&#39;\\Omega w}} \\end{split} \\end{equation*}\\] 위험기여도는 특정 자산이 포트폴리오 내에서 차지하는 위험의 비중입니다. 한계 위험기여도가 큰 자산도 포트폴리오 내에서 비중이 작다면, 포트폴리오 내에서 차지하는 위험의 비중은 작을 것입니다. 반면에, 한계 위험기여도가 작은 자산일지라도 비중이 압도적으로 많다면, 포트폴리오 내에서 차지하는 위험의 비중은 클 것입니다. 결과적으로 \\(i\\)번째 자산의 위험기여도는, \\(i\\)번째 자산의 한계 위험기여도와 포트폴리오 내 비중의 곱으로 이루어집니다. \\[RC_i = \\frac{\\partial\\sigma_p}{\\partial w_i} \\times w_i\\] 위험기여도를 코드로 나타내면 다음과 같습니다. 먼저 포트폴리오 비중인 \\(w\\)와 분산-공분산 행렬인 covmat을 이용해 한계 위험기여도를 계산합니다. 그 후 비중 \\(w\\)를 곱해 위험기여도를 계산해 준 후 합계가 1이 되도록 표준화를 해줍니다. get_RC = function(w, covmat) { port_vol = t(w) %*% covmat %*% w port_std = sqrt(port_vol) MRC = (covmat %*% w) / as.numeric(port_std) RC = MRC * w RC = c(RC / sum(RC)) return(RC) } 11.3.1 주식 60%와 채권 40% 포트폴리오의 위험기여도 자산배분에서 가장 많이 사용되는 투자방법은 주식에 60%, 채권에 40% 가량의 비율로 투자하는 것입니다. 주식과 채권이 서로 상관관계가 낮아 분산효과가 있다는 점, 장기적으로 주식이 채권에 비해 장기적으로 수익률이 높다는 점을 감안하면 이는 꽤나 합리적인 방법으로 보입니다. 그러나 눈에 보이는 비중이 60대 40이라도, 포트폴리오 내에서 각 자산이 가지고 있는 위험기여도 60대 40의 비중이 아닌 전혀 다른 비중을 가지고 있습니다. ret_stock_bond = rets[, c(1, 5)] cov_stock_bond = cov(ret_stock_bond) RC_stock_bond = get_RC(c(0.6, 0.4), cov_stock_bond) RC_stock_bond = round(RC_stock_bond, 4) print(RC_stock_bond) ## [1] 0.9649 0.0351 rets 데이터에서 첫 번째 행은 미국 주식 수익률을, 다섯 번째 행은 미국 장기채를 의미하므로, 해당 부분을 ret_stock_bond 변수에 지정합니다. 그 후 cov() 함수를 이용해 두 자산의 분산-공분산 행렬을 만들어주며, 위에서 만든 get_RC 함수를 통해 자산별 위험기여도를 계산합니다. 주식과 채권이 가지는 위험기여도는 각각 96.49%, 3.51%로서 투자 비중인 60%, 40%와는 전혀 다른 위험 비중을 보입니다. 즉, 주식이 포트폴리오 위험의 대부분을 차지하고 있습니다. 11.3.2 rp() 함수를 이용한 최적화 앞의 예제와 같이 특정 자산이 포트폴리오의 위험을 대부분 차지하는 문제를 막고, 모든 자산이 동일한 위험기여도를 가지는 포트폴리오가 위험균형 포트폴리오(Risk Parity Portfolio)(Qian 2011) 혹은 동일 위험기여도 포트폴리오(Equal Risk Contribution Portfolio)입니다. 이를 수식으로 쓰면 다음과 같습니다. \\[RC_1 = RC_2 = \\dots = RC_n\\] \\[\\frac{\\partial\\sigma_p}{\\partial w_1} \\times w_1 = \\frac{\\partial\\sigma_p}{\\partial w_2} \\times w_2 = \\dots = \\frac{\\partial\\sigma_p}{\\partial w_n} \\times w_n = \\frac{1}{n}\\] 위험균형 포트폴리오 역시 slsqp()나 optimalPortfolio() 함수를 이용해 구현할 수 있으나, 간혹 최적화된 값을 찾지 못할 때도 있습니다. 반면 cccp 패키지의 rp() 함수를 사용하면 매우 정확하게 위험균형 포트폴리오를 구성하는 비중을 계산할 수 있습니다. library(cccp) opt = rp(x0 = rep(0.1, 10), P = covmat, mrc = rep(0.1, 10)) w = getx(opt) %&gt;% drop() w = (w / sum(w)) %&gt;% round(., 4) %&gt;% setNames(colnames(rets)) print(w) ## SPY IEV EWJ EEM TLT IEF IYR RWX GLD DBC ## 0.0602 0.0470 0.0570 0.0375 0.1732 0.3704 0.0401 0.0511 0.0868 0.0767 x0은 최적화를 위한 초기 입력값이며 동일 비중인 10%씩을 입력합니다. P는 분산-공분산 행렬을 입력해줍니다. mrc는 목표로 하는 각 자산별 위험기여도 값17이며, 위험균형 포트폴리오의 경우 모든 자산의 위험기여도가 동일해야 하므로 10%씩을 입력합니다. rp() 함수는 위 입력 변수를 바탕으로 최적해를 찾아줍니다. getx() 함수를 통해 해를 추출할 수 있으며, drop()을 통해 벡터 형태로 변환합니다. 마지막으로 비중의 합이 1이 되기 위해 비중들의 합으로 나눠줍니다. 최종적으로 계산된 비중이 위험균형 포트폴리오를 만족하는 해가 됩니다. get_RC(w, covmat) ## [1] 0.09992 0.10002 0.09992 0.10005 0.10004 0.10003 0.10001 0.10001 0.09996 ## [10] 0.10005 get_RC() 함수를 통해 위험기여도를 확인해보면, 모든 자산이 거의 동일한 위험기여도를 가지는 것을 알 수 있습니다. 11.3.3 위험예산 포트폴리오 모든 자산의 위험기여도가 동일한 값이 아닌, 자산별로 다른 위험기여도를 가지는 포트폴리오를 구성해야 할 경우도 있습니다. 이러한 포트폴리오를 위험예산 포트폴리오(Risk Budget Portfolio)라고 합니다. 위험균형 포트폴리오 역시 각 자산의 위험예산이 \\(\\frac{1}{n}\\)로 동일한 특수 형태이며, rp() 함수를 이용하면 위험예산 포트폴리오 역시 손쉽게 구현할 수 있습니다. 먼저 각 자산 별 위험예산을 표 11.13과 같이 정합니다. 1~4번 자산은 각각 15%씩, 5~6번 자산은 각각 10%씩, 7~10번 자산은 각각 5%씩 위험예산을 부여하고자 합니다. 표 11.13: 위험예산 포트폴리오 예시 자산 1 2 3 4 5 6 7 8 9 10 예산 0.15 0.15 0.15 0.15 0.1 0.1 0.05 0.05 0.05 0.05 library(cccp) opt = rp(x0 = rep(0.1, 10), P = covmat, mrc = c(0.15, 0.15, 0.15, 0.15, 0.10, 0.10, 0.05, 0.05, 0.05, 0.05)) w = getx(opt) %&gt;% drop() w = (w / sum(w)) %&gt;% round(., 4) %&gt;% setNames(colnames(rets)) print(w) ## SPY IEV EWJ EEM TLT IEF IYR RWX GLD DBC ## 0.0847 0.0671 0.0788 0.0535 0.1805 0.3918 0.0200 0.0253 0.0541 0.0441 mrc에 목표로 하는 각 자산별 위험기여도를 입력하며, 나머지는 기존 위험균형 포트폴리오와 동일하게 입력합니다. get_RC(w, covmat) ## [1] 0.15002 0.14998 0.14995 0.15009 0.09999 0.10001 0.04995 0.04991 0.05003 ## [10] 0.05007 get_RC() 함수를 통해 위험기여도를 확인해보면 우리가 원하던 자산별 위험예산과 거의 동일한 것을 알 수 있습니다. 11.4 인덱스 포트폴리오 구성하기 이번에는 실제로 운용사에서 많이 사용되는 인덱스 포트폴리오 및 인핸스드 인덱스 포트폴리오 구성법에 대해 살펴보겠습니다. 투자는 크게 액티브 전략과 패시브 전략으로 나뉩니다. 액티브 전략이 벤치마크 대비 초과수익을 거두기 위해 적극적으로 투자를 하는 반면, 패시브 전략은 벤치마크를 그대로 추종하는 것을 목표로 합니다. 예를 들어 벤치마크가 2% 상승하였을 경우 액티브 전략은 이를 넘어서는 수익률을 얻고자 하지만, 패시브 전략은 정확히 2%의 수익률을 얻고자 합니다. 이러한 패시브 전략을 사용하는 펀드가 패시브 펀드 혹은 인덱스 펀드입니다. 흔히 벤치마크가 되는 지수(Index) 중 가장 많이 사용되는 것은 각 국가의 주가지수이며, 우리나라의 경우 KOSPI200 지수가 그 예입니다. 이 외에도 여러 국가를 대표하는 주가지수는 표 11.14 와 같습니다. 표 11.14: 각 국가의 대표 주가지수 국가 지수명 미국 S&amp;P 500 영국 FTSE 100 일본 Nikkei 225 중국 CSI 300 한국 KOSPI 200 11.4.1 시가총액비중 계산하기 주가지수는 대부분 각 주식의 시가총액비중을 이용해 구성되며, 간단한 예제는 표 11.15와 같습니다. 표 11.15: 시가총액비중 계산 예시 종목 주가 상장 주식수 유동비 시가총액 지수 내 비중 A 40,000 4,000,000 70% 112,000,000,000 44.80% B 50,000 3,000,000 60% 90,000,000,000 36.00% C 30,000 2,000,000 80% 48,000,000,000 19.20% 합계 250,000,000,000 100.00% 일반적으로 시가총액은 [주가 X 상장 주식수]로 계산됩니다. 그러나 자사주 등의 이유로 기업의 상장된 모든 주식이 거래가 되는 것은 아니며, 상장된 주식 중 유동적으로 거래되는 비율을 유동비라고 합니다. 따라서 지수를 구성할 때는 시가총액을 [주가 X 상장 주식수 X 유동비]로 계산합니다. 이렇게 계산된 각 기업의 시가총액을 전체 시가총액의 합으로 나누어 지수 내 비중을 계산합니다. 11.4.2 인덱스 포트폴리오 복제하기 이번에는 앞서 구한 데이터를 바탕으로 KOSPI 200 지수를 복제하는 예제를 살펴보겠습니다. 해당 지수의 산출 방법은 다음과 같습니다. 한국거래소 유가증권시장(Stock Market)의 보통주 전 종목 가운데 시장 대표성, 유동성(거래량), 업종 대표성(업종은 9개 업종으로 구분)을 기준으로 한다. 즉 시가총액이 상위군에 속하고 거래량이 많은 종목 서열에 따른 200 종목이 편입된다. 즉 일정 규칙에 따라 200 종목이 선정되고, 각 종목들의 시가총액비중 만큼을 지수 내 비중으로 가지고 갑니다. 물론 선정된 200 종목이 단순하게 시가총액의 순서대로 선택되는 것은 아니며, 유동비의 경우 지수제공업체인 한국거래소에서 유료로 제공하므로 이를 구매하지 않는 이상 정확하게 알 수 없습니다. 그러나 지수 내 종목 및 대략의 시가총액비중은 해당 지수를 추종하는 ETF(예: KODEX 200)의 PDF를 통해 확인할 수 있으며, 본 책에서는 편의를 위해 시가총액상위 200 종목을 선택하고 유동비는 모두 100%로 가정하겠습니다. 앞서 구한 데이터를 이용해 상위 200 종목의 시가총액비중을 계산해보도록 하겠습니다. library(stringr) library(dplyr) KOR_ticker = read.csv(&#39;data/KOR_ticker.csv&#39;, row.names = 1, stringsAsFactors = FALSE) KOSPI200 = KOR_ticker %&gt;% filter(시장구분 == &#39;KOSPI&#39;) %&gt;% slice(1:200) %&gt;% mutate(시가총액비중 = 시가총액 / sum(시가총액)) 저장해둔 티커 정보를 불러옵니다. filter() 함수를 통해 코스피 시장에 해당하는 종목만을 선택합니다. slice() 함수를 통해 1번부터 200번 행 까지 데이터를 선택합니다. 각 주식의 시가총액을 전체 시가총액으로 나눈 후, 시가총액비중에 저장합니다. 계산된 시가총액비중을 시각화하도록 하겠습니다. library(ggplot2) KOSPI200 %&gt;% ggplot(aes(x = reorder(종목명, -시가총액비중), y = 시가총액비중)) + geom_point() + xlab(&#39;종목명&#39;) + ylab(&#39;시가총액비중(%)&#39;) + scale_y_continuous(labels = scales::percent) ggplot() 함수를 이용해 시각화를 해주도록 하며, reorder()를 통해 시가총액비중으로 \\(x\\)축을 정리합니다. geom_point() 함수를 통해 산점도를 나타냅니다. \\(x\\)축과 \\(y\\)축의 이름을 변경합니다. scale_y_continuous() 함수 내 scales::percent 인자를 입력하여 \\(y\\) 축을 퍼센트 형식으로 변경합니다. 위 과정을 통해 코스피 시가총액 상위 200 종목의 시가총액비중을 계산 및 시각화 하였습니다. 그러나 \\(x\\)축에 해당하는 종목이 200개나 되어 종목명이 잘 보이지 않으며, 국내의 경우 삼성전자의 시가총액비중이 지나치게 커 다른 종목들의 비중이 잘 보이지 않습니다. 이를 고려하여 그림을 다시 수정해주도록 합니다. KOSPI200 %&gt;% ggplot(aes(x = reorder(종목명, -시가총액비중), y = 시가총액비중)) + geom_point() + xlab(&#39;종목명&#39;) + ylab(&#39;시가총액비중(로그 스케일링)&#39;) + scale_y_log10() + scale_x_discrete(breaks = KOSPI200[seq(1, 200, by = 5), &#39;종목명&#39;]) + theme(axis.text.x = element_text(angle = 60, hjust = 1)) scale_y_log10() 함수를 통해 \\(y\\)축을 로그값으로 스케일링 하였습니다. scale_x_discrete() 함수를 통해 \\(x\\)축에 일부 종목만을 표현하였습니다. theme() 내부에 element_text() 인자를 통해 \\(x\\)축 글자를 회전시키고 위치를 조정하였습니다. 다음으로 만일 여러분에게 1억이 있을 경우 KOSPI 200을 복제하는 방법을 알아보겠습니다. KOSPI200 = KOSPI200 %&gt;% mutate(매수금액 = 100000000 * 시가총액비중, 매수주수 = 매수금액 / 종가) KOSPI200 %&gt;% select(매수금액, 매수주수) %&gt;% head() ## 매수금액 매수주수 ## 1 21923608 311.415 ## 2 4006509 37.976 ## 3 3448955 8.569 ## 4 3016620 3.452 ## 5 2892429 23.232 ## 6 2887051 3.682 여러분이 가지고 있는 금액에 시가총액비중을 곱해 각 주식당 매수해야 하는 금액을 구합니다. 그 후 각 금액을 현재가로 나누어 매수해야 하는 주식의 수를 계산합니다. 이론적으로는 계산된 주식수만큼 매수하여야 인덱스를 정확히 복제합니다. 그러나 주식은 1주 단위로 거래할 수 있으므로 소수점 단위로는 거래할 수는 없습니다. 만일 매수주수를 올림처리할 경우 총 매수금액이 보유금액보다 많이질 수 있으므로, 내림처리를 통해 매수주수를 수정해줍니다. KOSPI200 = KOSPI200 %&gt;% mutate(매수주수 = floor(매수주수)) KOSPI200 %&gt;% select(매수금액, 매수주수) %&gt;% head() ## 매수금액 매수주수 ## 1 21923608 311 ## 2 4006509 37 ## 3 3448955 8 ## 4 3016620 3 ## 5 2892429 23 ## 6 2887051 3 floor() 함수를 통해 내림처리를 하였으며, 각 주수만큼 매수할 경우 KOSPI 200 지수를 매우 유사하게 복제할 수 있습니다. inv_money = KOSPI200 %&gt;% mutate(실제매수금액 = 종가 * 매수주수) %&gt;% summarize(sum(실제매수금액)) print(inv_money) ## sum(실제매수금액) ## 1 87433625 주수를 내림 처리하였으므로 실제 매수에 사용되는 금액은 1억원 보다 약간 모자르게 되며, 1억과 해당금액의 차이는 현금으로 보유하거나 해당 지수를 추종하는 ETF 및 펀드 투자에 사용해도 됩니다. 11.4.3 팩터를 이용한 인핸스드 포트폴리오 구성하기 위 방법을 통해 포트폴리오를 구성할 경우 이론적으로는 벤치마크와 수익률이 거의 동일합니다. 그러나 약간의 위험을 감수하여 벤치마크 대비 미세한 초과수익을 원하는 수요가 존재하며, 이러한 펀드가 인핸스드 인덱스 펀드입니다. 이를 위해 층화추출법, 비중조절법, 차익거래 등의 전략이 활용되며, 본 책에서는 가장 널리 사용되는 비중조절법에 대해 알아보겠습니다. 그 예제로써 PBR을 이용해 시가총액비중을 조절해보도록 하겠습니다. KOSPI200 = KOSPI200 %&gt;% select(종목명, PBR, 시가총액비중) %&gt;% mutate(PBR = as.numeric(PBR)) 먼저 필요한 종목코드, 종목명, PBR, 시가총액비중 열만 선택합니다. 그 후 문자열 형태의 PBR을 숫자 형태로 변경해주며, PBR 데이터가 없어 [-]로 표시되었던 종목의 PBR은 NA로 변경됩니다. 11.4.3.1 단순 가감법 먼저 가장 손쉬운 방법은 PBR의 랭킹을 구한 후, PBR이 낮은 상위 n개 종목에는 일정 비중씩을 더하며, 나머지 종목들에서 해당 비중만큼을 빼는 방법입니다. 몇개의 종목에서 얼마씩의 비중을 조절할지는 투자자의 재량에 달렸으며, 본 예제에서는 상위 100 종목에 각각 5bp를 더해주며, 나머지 100 종목에서 각각 5bp를 빼주도록 하겠습니다. KOSPI200 = KOSPI200 %&gt;% mutate(랭킹 = rank(PBR), 조절비중 = ifelse(랭킹 &lt;= 100, 시가총액비중 + 0.0005, 시가총액비중 - 0.0005), 조절비중 = ifelse(조절비중 &lt; 0, 0, 조절비중), 조절비중 = 조절비중 / sum(조절비중), 차이 = 조절비중 - 시가총액비중) library(tidyr) head(KOSPI200) ## 종목명 PBR 시가총액비중 랭킹 조절비중 차이 ## 1 삼성전자 1.79 0.21924 113.5 0.21874 -0.0005 ## 2 SK하이닉스 1.48 0.04007 99.5 0.04057 0.0005 ## 3 NAVER 8.97 0.03449 186.0 0.03399 -0.0005 ## 4 삼성바이오로직스 12.57 0.03017 192.0 0.02967 -0.0005 ## 5 카카오 8.71 0.02892 184.0 0.02842 -0.0005 ## 6 LG화학 3.40 0.02887 144.0 0.02837 -0.0005 tail(KOSPI200) ## 종목명 PBR 시가총액비중 랭킹 조절비중 차이 ## 195 태광산업 0.34 0.0005866 6.5 0.00108662 0.0005 ## 196 세방전지 1.01 0.0005850 68.5 0.00108498 0.0005 ## 197 한올바이오파마 6.11 0.0005777 168.0 0.00007773 -0.0005 ## 198 미원에스씨 4.24 0.0005773 154.0 0.00007731 -0.0005 ## 199 하나투어 8.16 0.0005752 179.5 0.00007517 -0.0005 ## 200 제이콘텐트리 5.28 0.0005751 162.0 0.00007515 -0.0005 rank() 함수를 통해 PBR의 랭킹을 구합니다. 랭킹이 100 이하일 시, 즉 저PBR 100개 종목에는 시가총액비중에서 5bp씩을 더해주며, 반대로 고PBR 100개 종목에는 5bp 씩을 빼줍니다. 시가총액비중이 5bp 미만인 종목에서 5bp를 차감할 경우 비중이 0 미만이 되므로, 이러한 경우는 투자비중을 0으로 만들어 줍니다. 3번 결과에 따라 비중의 합이 1과 다르게 되므로, 각각의 비중을 합으로 나누어 값을 다시 계산해 줍니다. 시가총액비중과 조절비중의 차이를 계산합니다. PBR 랭킹이 100 미만인 종목, 즉 저PBR 종목은 시가총액비중 대비 투자비중이 많으며, 이와 반대로 고PBR 종목은 시가총액비중 대비 투자비중이 작습니다. 즉 장기적으로 저PBR 종목이 고PBR 종목 대비 우수한 성과를 보일 경우, 저PBR 종목에 더 높은 비중을 준 해당 포트폴리오 역시 벤치마크 대비 우수한 성과를 기록할 수 있을 것입니다. KOSPI200 %&gt;% ggplot(aes(x = reorder(종목명, -시가총액비중), y = 시가총액비중)) + geom_point() + geom_point(data = KOSPI200, aes(x = reorder(종목명, -시가총액비중), y = 조절비중), color = &#39;red&#39;, shape = 4) + xlab(&#39;종목명&#39;) + ylab(&#39;비중(%)&#39;) + coord_cartesian(ylim = c(0, 0.03)) + scale_x_discrete(breaks = KOSPI200[seq(1, 200, by = 5), &#39;종목명&#39;]) + scale_y_continuous(labels = scales::percent) + theme(axis.text.x = element_text(angle = 60, hjust = 1)) 검은색 점은 인덱스 내 시가총액비중이며, 붉은색 엑스표시는 5bp씩 더하거나 뺀 투자비중입니다. 약간씩의 베팅만 했으므로 기초지수와 크게 차이가 없습니다. KOSPI200_mod = KOSPI200 %&gt;% arrange(PBR) KOSPI200_mod %&gt;% ggplot(aes(x = reorder(종목명, PBR), y = 차이)) + geom_point() + geom_col(aes(x = reorder(종목명, PBR), y = PBR /10000), fill = &#39;blue&#39;, alpha = 0.2) + xlab(&#39;종목명&#39;) + ylab(&#39;차이(%)&#39;) + scale_y_continuous(labels = scales::percent, sec.axis = sec_axis(~. * 10000, name = &quot;PBR&quot;)) + scale_x_discrete(breaks = KOSPI200_mod[seq(1, 200, by = 10), &#39;종목명&#39;]) + theme(axis.text.x = element_text(angle = 60, hjust = 1)) PBR 기준 오름차순을 한 후 그림을 그려보면, PBR이 낮은 종목에는 비중이 추가되며 PBR이 높은 종목에는 비중이 감소되는 것이 쉽게 확인됩니다. 11.4.3.2 팩터에 대한 전체 종목의 틸트 위 방법의 경우 상위 종목과 하위 종목에 동일한 비중을 더하거나 빼주었습니다. 그러나 팩터가 강한 종목의 경우 더욱 많은 비중을 더하고, 팩터가 약한 종목의 경우 더욱 많은 비중을 빼는 등 훨씬 적극적으로 포트폴리오를 구성할 수도 있습니다. 이를 위해서는 먼저 확률밀도함수와 누적분포함수를 이해해야 합니다. 파란색 선은 확률밀도함수로써, 각 \\(x\\)축에 대한 확률값을 나타냅니다. 빨간색 선은 누적분포함수로써, 각 \\(x\\)축이 오른쪽으로 이동함에 따른 분포의 누적확률을 계산합니다. 확률의 합은 1이므로 가장 오른쪽은 1의 값을 가지게 됩니다. 이를 팩터의 결합 방법에서 계산한 Z-Score에 응용할 수도 있으며, 이 과정은 표 11.16에 나와있습니다. 표 11.16: 누적분포함수를 이용한 비중 조절 종목 PBR 랭킹 Z-Score X (-1) 누적확률 시가총액비중 시총 X 누적확률 비중 재계산 차이 A 0.50 1 1.26 0.90 20.69% 18.56% 33.10% 12.38% B 0.70 2 0.63 0.74 31.03% 22.86% 40.72% 9.68% C 1.00 3 0.00 0.50 18.97% 9.48% 16.89% -2.07% D 1.20 4 -0.63 0.26 13.79% 3.64% 6.48% -7.32% E 1.50 5 -1.26 0.10 15.52% 1.60% 2.85% -12.67% 각각의 PBR에 대해 랭킹을 구합니다. 랭킹을 바탕으로 Z-Score를 구하며, 결과에 (-1)을 곱해줍니다. 이는 랭킹이 높은 종목의 경우 Z-Score가 음수로 나오므로, 해당 종목의 누적확률 값을 높게하기 위해 양수로 전환해주는 것입니다. 구해진 Z-Score를 바탕으로 누적확률을 구합니다. 랭킹이 높은 종목, 즉 저PBR일 수록 해당 값이 크게 나옵니다. 지수 내 시가총액비중에 누적확률값을 곱해줍니다. 저PBR 종목일수록 원래의 시가총액비중과 비슷하게 유지되며, 고PBR 종목의 경우 시가총액비중 대비 훨씬 낮을 값을 보입니다. 투자비중의 합이 1이 되도록 재표준화를 해줍니다. 각 종목의 차이를 보면, PBR이 낮을수록 증가되는 비중이 크며, PBR아 높을수록 감소되는 비중 역시 큽니다. 이처럼 Z-Score와 누적확률을 이용할 경우 훨씬 팩터에 대한 노출을 크게 할 수 있습니다. 이번에는 KOSPI 200 전 종목을 대상으로 PBR 대상 팩터 틸트 포트폴리오를 구성하도록 하겠습니다. KOSPI200_tilt = KOSPI200 %&gt;% select(종목명, PBR, 시가총액비중, 랭킹) %&gt;% mutate(zscore = -scale(랭킹), cdf = pnorm(zscore), 투자비중 = 시가총액비중 * cdf, 투자비중 = 투자비중 / sum(투자비중), 차이 = 투자비중 - 시가총액비중) head(KOSPI200_tilt) ## 종목명 PBR 시가총액비중 랭킹 zscore cdf 투자비중 차이 ## 1 삼성전자 1.79 0.21924 113.5 -0.22461 0.41114 0.207515 -0.01172 ## 2 SK하이닉스 1.48 0.04007 99.5 0.01728 0.50689 0.046755 0.00669 ## 3 NAVER 8.97 0.03449 186.0 -1.47724 0.06981 0.005543 -0.02895 ## 4 삼성바이오로직스 12.57 0.03017 192.0 -1.58091 0.05695 0.003955 -0.02621 ## 5 카카오 8.71 0.02892 184.0 -1.44269 0.07455 0.004965 -0.02396 ## 6 LG화학 3.40 0.02887 144.0 -0.75158 0.22615 0.015031 -0.01384 tail(KOSPI200_tilt) ## 종목명 PBR 시가총액비중 랭킹 zscore cdf 투자비중 차이 ## 195 태광산업 0.34 0.0005866 6.5 1.6241 0.94782 0.0012800 0.0006934 ## 196 세방전지 1.01 0.0005850 68.5 0.5529 0.70983 0.0009560 0.0003710 ## 197 한올바이오파마 6.11 0.0005777 168.0 -1.1662 0.12176 0.0001619 -0.0004158 ## 198 미원에스씨 4.24 0.0005773 154.0 -0.9244 0.17765 0.0002361 -0.0003412 ## 199 하나투어 8.16 0.0005752 179.5 -1.3649 0.08614 0.0001141 -0.0004611 ## 200 제이콘텐트리 5.28 0.0005751 162.0 -1.0626 0.14399 0.0001907 -0.0003845 먼저 필요한 열만 선택합니다. scale() 함수를 통해 Z-Score를 구하며, (-1)을 곱해줍니다. pnorm() 함수를 통해 누적확률 값을 구해집니다. 시가총액비중에 누적확률을 곱해 새로운 투자비중을 구한 후, 이를 재표준화 해줍니다. 틸트된 비중과 기존 비중간의 차이를 구합니다. 위 방법은 시가총액비중이 클수록, 그리고 Z-Score의 절대값이 클수록 비중의 차이가 많이 발생하게 됩니다. 각 종목의 투자비중을 그림으로 나타내겠습니다. KOSPI200 %&gt;% ggplot(aes(x = reorder(종목명, -시가총액비중), y = 시가총액비중)) + geom_point() + geom_point(data = KOSPI200_tilt, aes(x = reorder(종목명, -시가총액비중), y = 투자비중), color = &#39;red&#39;, shape = 4) + xlab(&#39;종목명&#39;) + ylab(&#39;비중(%)&#39;) + coord_cartesian(ylim = c(0, 0.03)) + scale_x_discrete(breaks = KOSPI200[seq(1, 200, by = 5), &#39;종목명&#39;]) + scale_y_continuous(labels = scales::percent) + theme(axis.text.x = element_text(angle = 60, hjust = 1)) 검은색 점은 인덱스 내 시가총액비중이며, 붉은색 엑스표시는 새롭게 구한 투자비중입니다. 단순이 동일한 비중을 더하거나 빼는것 보다 비중 차이의 폭이 훨씬 크며, 이는 전체 포트폴리오가 팩터에 노출된 정도가 크다는 것을 의미합니다. 그러나 실무에서는 이러한 차이가 지나치게 벌어지는 것을 방지하기 위한 제약이 있습니다. 그 예로써 종목당 시가총액비중과 투자비중의 차이가 50bp 이상이 되지 않는 제약이 있는 경우를 생각해봅시다. (제약을 더 크게 설정할 수록, 지수 대비 베팅의 크기가 커집니다.) KOSPI200_tilt %&gt;% ggplot(aes(x = reorder(종목명, -시가총액비중), y = 차이)) + geom_point() + geom_hline(aes(yintercept = 0.005), color = &#39;red&#39;) + geom_hline(aes(yintercept = -0.005), color = &#39;red&#39;) + xlab(&#39;종목명&#39;) + ylab(&#39;비중 차이(%)&#39;) + scale_x_discrete(breaks = KOSPI200[seq(1, 200, by = 5), &#39;종목명&#39;]) + scale_y_continuous(labels = scales::percent) + theme(axis.text.x = element_text(angle = 60, hjust = 1)) 시가총액이 큰 종목의 경우 허용치인 50bp를 넘어가는 경우가 다수 존재합니다. 이를 방지하기 위해 비중에 제약조건을 두어야 합니다. 예를 들어 삼성전자의 경우 둘 간의 비중의 차이가 -0.0117 로 지나치게 크므로 [시가총액비중 - 50bp] 가 투자되도록 변경해 줍니다. 타 종목 역시 이와 동일하게 제약조건을 추가해 줍니다. KOSPI200_tilt = KOSPI200_tilt %&gt;% mutate_at(vars(투자비중), list(~ifelse(차이 &lt; -0.005, 시가총액비중 - 0.005, 투자비중))) %&gt;% mutate_at(vars(투자비중), list(~ifelse(차이 &gt; 0.005, 시가총액비중 + 0.005, 투자비중))) %&gt;% mutate(투자비중 = 투자비중 / sum(투자비중), 차이 = 투자비중 - 시가총액비중) head(KOSPI200_tilt) ## 종목명 PBR 시가총액비중 랭킹 zscore cdf 투자비중 차이 ## 1 삼성전자 1.79 0.21924 113.5 -0.22461 0.41114 0.20381 -0.015430 ## 2 SK하이닉스 1.48 0.04007 99.5 0.01728 0.50689 0.04287 0.002806 ## 3 NAVER 8.97 0.03449 186.0 -1.47724 0.06981 0.02805 -0.006436 ## 4 삼성바이오로직스 12.57 0.03017 192.0 -1.58091 0.05695 0.02394 -0.006225 ## 5 카카오 8.71 0.02892 184.0 -1.44269 0.07455 0.02276 -0.006165 ## 6 LG화학 3.40 0.02887 144.0 -0.75158 0.22615 0.02271 -0.006162 mutate_at() 함수를 이용해 시가총액비중과 투자비중의 차이가 50bp 미만일 경우 투자비중을 [시가총액 - 50bp]로 변경해주며, 50bp 초과일 경우 [시가총액 + 50bp]로 변경해줍니다. 재표준화 작업을 거쳐준 후 차이를 다시 계산합니다. 위 방법을 통해 차이가 50bp가 되도록 강제로 설정하였으나, 재표준화를 거치는 과정에서 차이가 50bp를 넘는 종목이 다시 발생하게 됩니다. 모든 종목의 차이가 50bp 이내가 되도록 해당 작업을 반복해줍니다. while (max(abs(KOSPI200_tilt$차이)) &gt; (0.005 + 0.00001)) { KOSPI200_tilt = KOSPI200_tilt %&gt;% mutate_at(vars(투자비중), list(~ifelse(차이 &lt; -0.005, 시가총액비중 - 0.005, 투자비중))) %&gt;% mutate_at(vars(투자비중), list(~ifelse(차이 &gt; 0.005, 시가총액비중 + 0.005, 투자비중))) %&gt;% mutate(투자비중 = 투자비중 / sum(투자비중), 차이 = 투자비중 - 시가총액비중) } head(KOSPI200_tilt) ## 종목명 PBR 시가총액비중 랭킹 zscore cdf 투자비중 차이 ## 1 삼성전자 1.79 0.21924 113.5 -0.22461 0.41114 0.21423 -0.005005 ## 2 SK하이닉스 1.48 0.04007 99.5 0.01728 0.50689 0.04160 0.001536 ## 3 NAVER 8.97 0.03449 186.0 -1.47724 0.06981 0.02949 -0.005001 ## 4 삼성바이오로직스 12.57 0.03017 192.0 -1.58091 0.05695 0.02517 -0.005001 ## 5 카카오 8.71 0.02892 184.0 -1.44269 0.07455 0.02392 -0.005001 ## 6 LG화학 3.40 0.02887 144.0 -0.75158 0.22615 0.02387 -0.005001 위와 동일한 코드에 while() 구문을 활용하여 둘 간의 차이가 50bp 보다 클 경우 해당 작업을 계속해서 반복하며, 결과적으로 차이가 거의 50bp에 수렴합니다. KOSPI200_tilt %&gt;% ggplot(aes(x = reorder(종목명, -시가총액비중), y = 차이)) + geom_point() + geom_hline(aes(yintercept = 0.005), color = &#39;red&#39;) + geom_hline(aes(yintercept = -0.005), color = &#39;red&#39;) + xlab(&#39;종목명&#39;) + ylab(&#39;비중 차이(%)&#39;) + scale_x_discrete(breaks = KOSPI200[seq(1, 200, by = 5), &#39;종목명&#39;]) + scale_y_continuous(labels = scales::percent) + theme(axis.text.x = element_text(angle = 60, hjust = 1)) 모든 종목이 제약조건 내에 들어오게 되었습니다. KOSPI200 %&gt;% ggplot(aes(x = reorder(종목명, -시가총액비중), y = 시가총액비중)) + geom_point() + geom_point(data = KOSPI200_tilt, aes(x = reorder(종목명, -시가총액비중), y = 투자비중), color = &#39;red&#39;, shape = 4) + xlab(&#39;종목명&#39;) + ylab(&#39;비중(%)&#39;) + coord_cartesian(ylim = c(0, 0.03)) + scale_x_discrete(breaks = KOSPI200[seq(1, 200, by = 5), &#39;종목명&#39;]) + scale_y_continuous(labels = scales::percent) + theme(axis.text.x = element_text(angle = 60, hjust = 1)) 제약조건으로 인해 기초지수와의 차이가 줄어들었지만, 기존 단순가감법 보다는 적극적으로 베팅이 되었습니다. KOSPI200_tilt_mod = KOSPI200_tilt %&gt;% arrange(PBR) KOSPI200_tilt_mod %&gt;% ggplot(aes(x = reorder(종목명, PBR), y = 차이)) + geom_point() + geom_col(aes(x = reorder(종목명, PBR), y = PBR /2000), fill = &#39;blue&#39;, alpha = 0.2) + xlab(&#39;종목명&#39;) + ylab(&#39;차이(%)&#39;) + scale_y_continuous(labels = scales::percent, sec.axis = sec_axis(~. * 2000, name = &quot;PBR&quot;)) + scale_x_discrete(breaks = KOSPI200_mod[seq(1, 200, by = 10), &#39;종목명&#39;]) + theme(axis.text.x = element_text(angle = 60, hjust = 1)) PBR에 따른 비중의 차이 역시 단순 가감법보다 훨씬 증가했습니다. 실무에서는 단순히 PBR처럼 하나의 지표만 살펴보기 보다는 앞서 살펴본 멀티팩터를 이용해 비중을 틸트하기도 하며, 좀 더 다양한 제약조건을 추가하기도 합니다. References "],["포트폴리오-백테스트.html", "Chapter 12 포트폴리오 백테스트 12.1 Return.Portfolio() 함수 12.2 전통적인 60대 40 포트폴리오 백테스트 12.3 시점 선택 전략 백테스트 12.4 동적 자산배분 백테스트", " Chapter 12 포트폴리오 백테스트 백테스트란 현재 생각하는 전략을 과거부터 실행했을 때 어떠한 성과가 발생하는지 테스트해보는 과정입니다. 과거의 데이터를 기반으로 전략을 실행하는 퀀트 투자에 있어서 이는 핵심 단계이기도 합니다. 백테스트 결과를 통해 해당 전략의 손익뿐만 아니라 각종 위험을 대략적으로 판단할 수 있으며, 어떤 구간에서 전략이 좋았는지 혹은 나빴는지에 대한 이해도 키울 수 있습니다. 이러한 이해를 바탕으로 퀀트 투자를 지속한다면 단기적으로 수익이 나쁜 구간에서도 그 이유에 대한 객관적인 안목을 키울 수 있으며, 확신을 가지고 전략을 지속할 수 있습니다. 그러나 백테스트를 아무리 보수적으로 혹은 엄밀하게 진행하더라도 이미 일어난 결과를 대상으로 한다는 사실은 변하지 않습니다. 백테스트 수익률만을 보고 투자에 대해 판단하거나, 혹은 동일한 수익률이 미래에도 반복될 것이라고 믿는다면 이는 백미러만 보고 운전하는 것처럼 매우 위험한 결과를 초래할 수도 있습니다. R에서 백테스트는 PerformanceAnalytics 패키지의 Return.portfolio() 함수를 사용해 매우 간단하게 수행할 수 있습니다. 이 CHAPTER에서는 해당 함수를 알아보고 구체적인 사용 방법에 대한 예시로서 전통적인 주식 60% &amp; 채권 40% 포트폴리오, 시점 선택 전략, 동적 자산배분에 대한 백테스트를 실시합니다. 12.1 Return.Portfolio() 함수 프로그래밍을 이용해 백테스트할 때 전략이 단순하다면 단 몇 줄만으로도 테스트가 가능합니다. 그러나 전략이 복잡해지거나 적용해야 할 요소가 많아질 경우, 패키지를 이용하는 것이 효율적인 방법입니다. PerformanceAnalytics 패키지의 Return.portfolio() 함수는 백테스트를 수행하는데 가장 대중적으로 사용되는 함수입니다. 해당 함수의 가장 큰 장점은 각 자산의 수익률과 리밸런싱 비중만 있으면 백테스트 수익률, 회전율 등을 쉽게 계산할 수 있으며, 리밸런싱 시점과 수익률의 시점이 일치하지 않아도 된다는 점입니다. 즉, 수익률 데이터는 일간, 리밸런싱 시점은 분기 혹은 연간으로 된 경우에도 매우 쉽게 백테스트를 수행할 수 있습니다. 12.1.1 인자 목록 살펴보기 먼저 Return.portfolio() 함수는 다음과 같은 형태로 구성되어 있으며, 표 12.1는 인자의 내용을 정리한 것입니다. Return.portfolio(R, weights = NULL, wealth.index = FALSE, contribution = FALSE, geometric = TRUE, rebalance_on = c(NA, &quot;years&quot;, &quot;quarters&quot;, &quot;months&quot;, &quot;weeks&quot;, &quot;days&quot;), value = 1, verbose = FALSE, ...) 표 12.1: Return.portfolio() 함수 내 인자 설명 인자 내용 R 각 자산 수익률 데이터 weights 리밸런싱 시기의 자산별 목표 비중. 미 입력시 동일비중 포트폴리오를 가정해 백테스트가 이루어짐 wealth.index 포트폴리오 시작점이 1인 wealth index에 대한 생성 여부이며, 디폴트는 FALSE로 설정 contribution 포트폴리오 내에서 자산별 성과기여를 나타내는지에 대한 여부이며, 디폴트는 FALSE로 설정 geometric 포트폴리오 수익률 계산시 복리(기하)수익률 적용 여부이며, 디폴트는 TRUE로서 복리수익률을 계산 rebalance_on weight 값이 미입력 혹은 매번 같은 비중일 경우, 리밸런싱 주기를 선택할 수 있음 value 초기 포트폴리오 가치를 의미하며, 디폴트는 1 verbose 부가적인 결과를 표시할지에 대한 여부. 디폴트인 FALSE를 입력하면 포트폴리오 수익률만이 시계열 형태로 계산되며, TRUE를 입력하면 수익률 외에 자산 별 성과기여, 비중, 성과 등이 리스트 형태로 계산됨 이 중 가장 중요한 인자는 개별 자산의 수익률인 R과 리밸런싱 시기의 자산별 목표 비중인 weights입니다. 매 리밸런싱 시점마다 적용되는 자산별 비중이 동일할 경우(예: 매월 말 60%대 40% 비중으로 리밸런싱) 상수 형태로 입력해도 되지만, 시점마다 자산별 목표비중이 다를 경우 weights는 시계열 형태로 입력되어야 합니다. 목표 비중을 시계열 형태로 입력할 때 주의해야 할 점은 다음과 같습니다. 시계열 형태로 인식할 수 있도록 행 이름 혹은 인덱스가 날짜 형태로 입력되어야 합니다. 수익률 데이터와 비중 데이터의 열 개수는 동일해야 하며, 각 열에 해당하는 자산은 동일해야 합니다. 즉, 수익률 데이터의 첫 번째 열에 A주식 데이터가 있다면, 비중 데이터의 첫 번째 열도 A주식의 목표 비중을 입력해야 합니다. 각 시점의 비중의 합은 1이 되어야 합니다. 그렇지 않을 경우 제대로 된 수익률이 계산되지 않습니다. weights에 값을 입력하지 않을 경우 동일비중 포트폴리오를 구성하며, 포트폴리오 리밸런싱은 하지 않습니다. 12.1.2 출력값 살펴보기 해당 함수는 verbose를 TRUE로 설정하면 다양한 결괏값을 리스트 형태로 반환합니다 표 12.2: Return.portfolio() 함수 반환값 결과 내용 returns 포트폴리오 수익률 contribution 일자별 개별 자산의 포트폴리오 수익률 기여도 BOP.Weight 일자별 개별 자산의 포트폴리오 내 비중(시작시점). 리밸런싱이 없을 시 직전 기간 EOP.Weight와 동일 EOP.Weight 일자별 개별 자산의 포트폴리오 내 비중(종료시점) BOP.Value 일자별 개별 자산의 가치(시작시점). 리밸런싱이 없을 시 직전 기간 EOP.Value와 동일 EOP.Value 일자별 개별 자산의 가치(종료시점) 12.2 전통적인 60대 40 포트폴리오 백테스트 Return.portfolio() 함수의 가장 간단한 예제로서 전통적인 60대 40 포트폴리오를 백테스트합니다. 해당 포트폴리오는 주식과 채권에 각각 60%와 40%를 투자하며, 특정 시점마다 해당 비중을 맞춰주기 위해 리밸런싱을 수행합니다. 매해 말 리밸런싱을 가정하는 예제를 살펴보겠습니다. library(quantmod) library(PerformanceAnalytics) library(magrittr) ticker = c(&#39;SPY&#39;, &#39;TLT&#39;) getSymbols(ticker) ## [1] &quot;SPY&quot; &quot;TLT&quot; prices = do.call(cbind, lapply(ticker, function(x) Ad(get(x)))) rets = Return.calculate(prices) %&gt;% na.omit() 글로벌 자산의 ETF 데이터 중 주식(S&amp;P 500)과 채권(미국 장기채)에 해당하는 데이터를 다운로드한 후 수익률을 계산합니다. cor(rets) ## SPY.Adjusted TLT.Adjusted ## SPY.Adjusted 1.0000 -0.4272 ## TLT.Adjusted -0.4272 1.0000 cor() 함수를 통해 두 자산간의 상관관계를 확인해보면 -0.43로써 매우 낮은 상관관계를 보이며, 강한 분산효과를 기대해볼 수 있습니다. portfolio = Return.portfolio(R = rets, weights = c(0.6, 0.4), rebalance_on = &#39;years&#39;, verbose = TRUE) Return.portfolio() 함수를 이용하여 백테스트를 실행합니다. 자산의 수익률인 R에는 수익률 테이블인 rets를 입력합니다. 리밸런싱 비중인 weights에는 60%와 40%를 의미하는 c(0.6, 0.4)를 입력합니다. 리밸런싱 시기인 rebalance_on에는 연간 리밸런싱에 해당하는 years를 입력합니다. 리밸런싱 주기는 이 외에도 quarters, months, weeks, days도 입력이 가능합니다. 결과물들을 리스트로 확인하기 위해 verbose를 TRUE로 설정합니다. 위 과정을 통해 주식과 채권 투자비중을 매해 60%와 40%로 리밸런싱하는 포트폴리오의 백테스트가 실행됩니다. 표 12.3은 함수 내에서 포트폴리오의 수익률이 어떻게 계산되는지를 요약한 과정입니다. 표 12.3: Return.portfolio() 계산 과정 시작금액 시작합계 시작비중 수익률 종료금액 종료합계 종료비중 최종수익률 1.주식 2.채권 3.1+2 4.주식 5.채권 6.주식 7.채권 8.주식 9.채권 10.8+9 11.주식 12.채권 13.최종 2017-12-26 1.603 0.940 2.543 0.630 0.370 -0.001 0.003 1.601 0.943 2.544 0.629 0.371 0.000 2017-12-27 1.601 0.943 2.544 0.629 0.371 0.000 0.013 1.602 0.956 2.557 0.626 0.374 0.005 2017-12-28 1.602 0.956 2.557 0.626 0.374 0.002 -0.001 1.605 0.955 2.560 0.627 0.373 0.001 2017-12-29 1.605 0.955 2.560 0.627 0.373 -0.004 0.002 1.599 0.956 2.555 0.626 0.374 -0.002 2018-01-02 1.533 1.022 2.555 0.600 0.400 0.007 -0.011 1.544 1.011 2.555 0.604 0.396 0.000 2018-01-03 1.544 1.011 2.555 0.604 0.396 0.006 0.005 1.554 1.016 2.570 0.605 0.395 0.006 2018-01-04 1.554 1.016 2.570 0.605 0.395 0.004 0.000 1.560 1.016 2.576 0.606 0.394 0.002 먼저 2017-12-27에 해당하는 데이터를 보면 시작시점에 주식과 채권에는 각각 1.601과 0.943이 투자되어 있으며, 이를 합하면 2.544이 됩니다. 이를 포트폴리오 내 비중으로 환산하면 비중은 각각 0.629와 0.371가 됩니다. 해당일의 주식과 채권의 수익률은 각각 0, 0.013이 되며, 이를 시작금액에 곱하면 종료시점의 금액은 1.602와 0.956이 됩니다. 각각의 금액을 종료금액의 합인 2.557로 나누게 되면, 포트폴리오 내 비중은 0.626, 0.374로 변하게 됩니다. 포트폴리오 수익률은 2017-12-27 포트폴리오 금액인 2.557을 전일의 포트폴리오 금액인 2.544로 나누어 계산된 값인 0.005가 됩니다. 리밸런싱이 없다면 2017-12-27일의 종료금액과 종료비중은 다음 날인 2017-12-28의 시작금액과 시작비중에 그대로 적용되며, 위와 동일한 단계를 통해 포트폴리오 수익률이 계산됩니다. 그러나 매해 리밸런싱을 가정했으므로, 첫 영업일인 2018-01-02에는 포트폴리오 리밸런싱이 이루어집니다. 따라서 전일 2017-12-29의 종료금액의 합인 2.555를 사전에 정의한 0.6과 0.4에 맞게 각 자산을 시작시점에 매수 혹은 매도하게 됩니다. 이후에는 기존과 동일하게 해당일의 수익률을 곱해 종료시점의 금액과 비중을 구한 후 포트폴리오 수익률을 계산하게 됩니다. 리밸런싱 전일 종료시점의 비중과 리밸런싱 당일 시작시점의 비중 차이의 절대값을 합하면, 포트폴리오의 회전율을 계산할 수도 있습니다. 해당 예제에서는 2017-12-29 종료시점의 비중인 0.626, 0.374와 2018-01-02 시작시점의 비중인 0.6, 0.4의 차이인 0.026, -0.026의 절대값의 합계인 0.052가 회전율이 됩니다. 이처럼 리밸런싱을 원하는 시점과 비중을 정의하면, Return.portfolio() 함수 내에서는 이러한 단계를 거쳐 포트폴리오의 수익률, 시작과 종료시점의 금액 및 비중이 계산되며, 이를 응용하여 회전율을 계산할 수도 있습니다. portfolios = cbind(rets, portfolio$returns) %&gt;% setNames(c(&#39;주식&#39;, &#39;채권&#39;, &#39;60대 40&#39;)) charts.PerformanceSummary(portfolios, main = &#39;60대 40 포트폴리오&#39;) PerformanceAnalytics 패키지의 charts.PerformanceSummary() 함수는 기간별 수익률을 입력 시 누적수익률, 일별 수익률, 드로우다운(낙폭) 그래프를 자동으로 그려줍니다. 그래프는 색으로 구분되어 각각 주식 수익률(SPY), 채권 수익률(TLT), 60대 40 포트폴리오 수익률을 나타냅니다. 주식과 채권은 상반되는 움직임을 보이며 상승하며, 분산 투자 포트폴리오는 각 개별 자산에 비해 훨씬 안정적인 수익률을 보입니다. turnover = xts( rowSums(abs(portfolio$BOP.Weight - timeSeries::lag(portfolio$EOP.Weight)), na.rm = TRUE), order.by = index(portfolio$BOP.Weight)) chart.TimeSeries(turnover) 전일 종료시점의 비중인 EOP.Weight를 lag() 함수를 이용해 한 단계씩 내린 후 시작시점의 비중인 BOP.Weight와의 차이의 절댓값을 더해주면 해당 시점에서의 회전율이 계산됩니다. lag() 함수의 경우 dplyr 패키지에도 동일한 이름의 함수가 있으므로, 충돌을 방지하기 위해 timeSeries 패키지의 함수임을 선언해줍니다. 이를 xts() 함수를 이용해 시계열 형태로 만든 후 chart.TimeSeries() 함수를 이용해 그래프로 나타내줍니다. 리밸런싱 시점에 해당하는 매해 첫 영업일에 회전율이 발생하며, 그렇지 않은 날은 매수 혹은 매도가 없으므로 회전율 역시 0을 기록합니다. 2008년에는 주식과 채권의 등락폭이 심했으므로 이듬해엔 2009년 리밸런싱으로 인한 회전율이 심하지만, 이를 제외한 해는 회전율이 그리 심하지 않습니다. 12.3 시점 선택 전략 백테스트 이전 테스트가 리밸런싱 시점별 비중이 60%와 40%로 고정되어 있었다면, 이번에는 시점별 비중이 다른 형태의 예제를 살펴보겠습니다. 메브 파버(Meb Faber)는 본인의 논문(Faber 2007)을 통해, 시점 선택(Market Timing) 전략을 사용할 경우 단순 매수 후 보유 대비 극심한 하락장에서 낙폭을 줄일 수 있으며, 이로 인해 위험 대비 수익률을 올릴 수 있다고 설명합니다. 논문에서 말하는 시점 선택의 투자 규칙은 다음과 같습니다. \\[주가 &gt; 10개월\\,이동평균 \\to 매수\\] \\[주가 &lt; 10개월\\,이동평균 \\to 매도\\,및\\,현금\\,보유\\] 해당 규칙을 미국 S&amp;P 500에 적용하는 예제를 살펴보겠습니다. 현재 주식 가격이 과거 10개월 주식 가격의 단순 평균 대비 이상이면 매수, 그렇지 않으면 전량 매도 후 현금을 보유하는 전략이며, 리밸런싱은 매월 실행합니다. library(quantmod) library(PerformanceAnalytics) symbols = c(&#39;SPY&#39;, &#39;SHY&#39;) getSymbols(symbols, src = &#39;yahoo&#39;) ## [1] &quot;SPY&quot; &quot;SHY&quot; prices = do.call(cbind, lapply(symbols, function(x) Ad(get(x)))) rets = na.omit(Return.calculate(prices)) 먼저 주식과 현금에 해당하는 ETF 데이터를 다운로드합니다. 주식에 해당하는 ETF로 는 S&amp;P 500 수익률을 추종하는 SPY를 사용하며, 현금에 해당하는 ETF로는 미국 단기채 수익률을 추종하는 SHY를 사용합니다. ep = endpoints(rets, on = &#39;months&#39;) print(ep) ## [1] 0 19 38 60 80 102 123 144 167 186 209 230 250 271 291 ## [16] 311 333 354 375 397 418 439 462 481 503 523 542 564 585 605 ## [31] 627 649 670 691 713 733 755 774 793 816 837 857 879 900 922 ## [46] 943 964 985 1007 1027 1046 1069 1089 1110 1132 1152 1175 1196 1217 1238 ## [61] 1259 1279 1299 1321 1341 1363 1384 1405 1428 1447 1468 1489 1509 1530 1549 ## [76] 1569 1591 1613 1633 1655 1677 1697 1720 1740 1761 1782 1801 1822 1843 1864 ## [91] 1885 1907 1928 1949 1972 1991 2013 2033 2052 2074 2095 2115 2137 2159 2180 ## [106] 2201 2223 2243 2265 2284 2304 2326 2347 2368 2390 2410 2433 2454 2475 2496 ## [121] 2517 2537 2556 2579 2598 2620 2642 2662 2685 2705 2727 2748 2768 2789 2808 ## [136] 2829 2850 2872 2893 2914 2937 2956 2979 3000 3019 3040 3059 3080 3101 3123 ## [151] 3143 3165 3187 3207 3230 3250 3271 3292 3311 3333 3354 3374 3396 3418 3439 ## [166] 3460 3482 3502 3524 3543 3562 3585 3606 3626 3648 3669 3691 3712 3733 3737 wts = list() lookback = 10 먼저 xts 패키지의 endpoints() 함수를 이용해 매월 말일의 위치를 구합니다. 해당 함수는 endpoints(x, on= 'months', k=1)의 형태로 이루어지며 x는 시계열 데이터, on은 원하는 기간, k는 구간 길이를 의미합니다. 즉, 시계열 데이터에서 월말에 해당하는 부분의 위치를 반환하며, 매월이 아닌 weeks, quarters, years도 입력이 가능합니다. 결과적으로 ep에는 rets의 인덱스 중 매월 말일에 해당하는 부분의 위치가 구해집니다. 각 시점별 비중이 입력될 wts를 공백의 리스트 형식으로 저장해주며, n개월 이동평균값에 해당하는 lookback 변수는 10을 입력합니다. i = lookback + 1 sub_price = prices[ep[i-lookback] : ep[i] , 1] head(sub_price, 3) ## SPY.Adjusted ## 2007-01-03 105.4 ## 2007-01-04 105.7 ## 2007-01-05 104.8 tail(sub_price, 3) ## SPY.Adjusted ## 2007-10-26 116.1 ## 2007-10-29 116.5 ## 2007-10-30 115.7 sma = mean(sub_price) wt = rep(0, 2) wt[1] = ifelse(last(sub_price) &gt; sma, 1, 0) wt[2] = 1 - wt[1] wts[[i]] = xts(t(wt), order.by = index(rets[ep[i]])) 해당 전략은 for loop 구문을 통해, 매월 말 과거 10개월 이동평균을 구한 후 매수 혹은 매도를 선택한 후 비중을 계산합니다. 예시를 위해 첫 번째 시점의 테스트 과정을 살펴보며, 과거 10개월에 해당하는 가격의 이동평균이 필요하므로 처음 시작은 i+1 인 11부터 가능합니다. 주가는 일별 데이터이며, 현재부터 과거 10개월에 해당하는 주가를 선택해야 합니다. 앞서 endpoints() 함수를 통해 주가에서 월말 기준점의 위치를 찾았으며, ep[i]는 현재시점 주가의 위치를, ep[i-lookback]는 현재부터 10개월 전 주가 위치를 의미합니다. 이를 통해 과거 10개월 간 주가를 찾은 후 sub_price에 저장합니다. mean()을 통해 10개월 주가의 평균을 계산합니다. rep(0, 2)를 통해 비중이 들어갈 0벡터를 생성합니다. ifelse() 구문을 통해 해당 전략의 조건에 맞는 비중을 계산합니다. wt[1]은 주식의 투자비중이며, 만일 현재 주가가 10개월 이동평균보다 클 경우 주식에 해당하는 비중은 1을, 그렇지 않을 경우 0을 부여합니다. wt[2]는 현금의 투자비중이며, 1에서 주식의 투자비중을 뺀 값을 입력합니다. 표 12.4는 해당 규칙이 요약되어 있습니다. 위에서 만들어진 벡터를 xts()를 통해 시계열 형태로 바꾼 후, wts의 i번째 리스트에 저장해줍니다. 표 12.4: 시점선택 조건 별 비중 자산 현재주가 &gt; 10개월 이동평균 현재 주가 &lt; 10개월 이동평균 주식비중 wt[1] = 1 wt[1] = 0 현금비중 wt[2] = 0 wt[2] = 1 위 과정을 for loop 구문을 통해 전체 기간에 적용한 백테스트는 다음과 같습니다. ep = endpoints(rets, on = &#39;months&#39;) wts = list() lookback = 10 for (i in (lookback+1) : length(ep)) { sub_price = prices[ep[i-lookback] : ep[i] , 1] sma = mean(sub_price) wt = rep(0, 2) wt[1] = ifelse(last(sub_price) &gt; sma, 1, 0) wt[2] = 1 - wt[1] wts[[i]] = xts(t(wt), order.by = index(rets[ep[i]])) } wts = do.call(rbind, wts) 매월 말 과거 10개월 이동평균을 구한 후 현재 주가와 비교해 주식 혹은 현금 투자비중을 구한 후 wts 리스트에 저장합니다. 그 후 do.call() 함수를 통해 리스트를 테이블로 묶어줍니다. 수익률 데이터와 비중 데이터가 구해졌으므로 Return.portfolio() 함수를 통해 포트폴리오의 수익률을 계산합니다. Tactical = Return.portfolio(rets, wts, verbose = TRUE) portfolios = na.omit(cbind(rets[,1], Tactical$returns)) %&gt;% setNames(c(&#39;매수 후 보유&#39;, &#39;시점 선택 전략&#39;)) charts.PerformanceSummary(portfolios, main = &quot;Buy &amp; Hold vs Tactical&quot;) 수익률 데이터와 비중 데이터의 입력을 통해 백테스트를 실행합니다. cbind() 함수를 통해 SPY 데이터와 포트폴리오 수익률을 합쳐줍니다. 시점 선택 포트폴리오의 경우 lookback 기간인 초기 10개월에 대한 수익률이 없어 NA로 표시되므로 na.omit()을 통해 해당 부분을 제거합니다. charts.PerformanceSummary() 함수를 통해 수익률을 그래프로 나타냅니다. 검은색 그래프는 S&amp;P 500 에 매수 후 보유 시 수익률이고, 주황색 그래프는 시점 선택 전략을 적용한 수익률입니다. 2008년과 같은 하락장에서 낙폭이 훨씬 낮음이 확인됩니다. turnover = xts(rowSums(abs(Tactical$BOP.Weight - timeSeries::lag(Tactical$EOP.Weight)), na.rm = TRUE), order.by = index(Tactical$BOP.Weight)) chart.TimeSeries(turnover) 해당 전략의 회전율을 확인해보면, 몇 년간 매매가 없는 경우도 있습니다. 그러나 매매가 발생할 시 매수와 매도 포지션 양쪽의 매매로 인해 200%의 회전율이 발생하게 됩니다. 12.4 동적 자산배분 백테스트 마지막으로 기존에 배웠던 것들을 응용해 동적 자산배분의 백테스트를 수행하겠습니다. 일반적인 자산배분이 주식과 채권, 대체자산에 투자비중을 사전에 정해놓고 약간의 비율만 수정하는 정적 자산배분인 반면, 동적 자산배분이란 투자비중에 대한 제한이 없이 동적으로 포트폴리오를 구성하는 방법입니다. (Butler et al. 2012) 동적 자산배분을 이용한 포트폴리오는 다음과 같이 구성됩니다. 글로벌 10개 자산 중 과거 12개월 수익률이 높은 5개 자산을 선택합니다. 최소분산 포트폴리오를 구성하며, 개별 투자비중은 최소 10%, 최대 30% 제약조건을 설정합니다. 매월 리밸런싱을 실시합니다. library(quantmod) library(PerformanceAnalytics) library(RiskPortfolios) library(tidyr) library(dplyr) library(ggplot2) symbols = c(&#39;SPY&#39;, # 미국 주식 &#39;IEV&#39;, # 유럽 주식 &#39;EWJ&#39;, # 일본 주식 &#39;EEM&#39;, # 이머징 주식 &#39;TLT&#39;, # 미국 장기채 &#39;IEF&#39;, # 미국 중기채 &#39;IYR&#39;, # 미국 리츠 &#39;RWX&#39;, # 글로벌 리츠 &#39;GLD&#39;, # 금 &#39;DBC&#39; # 상품 ) getSymbols(symbols, src = &#39;yahoo&#39;) prices = do.call(cbind, lapply(symbols, function(x) Ad(get(x)))) %&gt;% setNames(symbols) rets = Return.calculate(prices) %&gt;% na.omit() 먼저 이전 CHAPTER와 동일하게 글로벌 자산을 대표하는 ETF 데이터를 다운로드한 후 수정주가의 수익률을 계산합니다. ep = endpoints(rets, on = &#39;months&#39;) wts = list() lookback = 12 wt_zero = rep(0, 10) %&gt;% setNames(colnames(rets)) 백테스트에 사용되는 각종 값을 사전에 정의합니다. endpoints() 함수를 통해 매월 말일의 위치를 구합니다. 매월의 투자비중이 들어갈 빈 리스트를 wts에 설정합니다. 수익률을 측정할 과거 n기간을 12개월로 설정합니다. rep() 함수를 통해 비중이 들어갈 0으로 이루어진 벡터를 만들며 이름을 설정합니다. 다음은 매월 말 투자 규칙에 따라 포트폴리오의 비중을 구하는 백테스트 과정입니다. for (i in (lookback+1) : length(ep)) { sub_ret = rets[ep[i-lookback] : ep[i] , ] cum = Return.cumulative(sub_ret) K = rank(-cum) &lt;= 5 covmat = cov(sub_ret[, K]) wt = wt_zero wt[K] = optimalPortfolio(covmat, control = list(type = &#39;minvol&#39;, constraint = &#39;user&#39;, LB = rep(0.10, 5), UB = rep(0.30, 5))) wts[[i]] = xts(t(wt), order.by = index(rets[ep[i]])) } wts = do.call(rbind, wts) for loop 구문을 통해 매월 말 과거 12개월 수익률을 구한 후 비중을 계산하므로, 처음 시작은 i+1인 13부터 가능합니다. ep[i]는 현재시점 수익률의 위치를, ep[i-lookback]는 현재부터 12개월 전 수익률의 위치를 의미합니다. 이를 통해 과거 12개월 간 수익률을 찾은 후 sub_ret에 저장합니다. Return.cumulative() 함수를 통해 해당 기간의 자산별 누적수익률을 구합니다. rank() 함수를 통해 수익률 상위 5개 자산을 선택하며, 내림차순으로 정렬해야하므로 마이너스(-)를 붙여줍니다. cov() 함수를 통해 수익률 상위 5개 자산의 분산-공분산 행렬을 구하도록 합니다. 임시로 비중이 저장될 wt 변수에 위에서 만든 0벡터(wt_zero)를 입력한 후 optimalPortfolio() 함수를 통해 최소분산 포트폴리오를 구성하는 해를 찾습니다. 개별 투자비중의 제한은 최소 10%, 최대 30%를 설정하며, 구해진 해를 wt의 K번째 값에 입력합니다. 위에서 만들어진 벡터를 xts()를 통해 시계열 형태로 바꾼 후 wts의 i번째 리스트에 저장합니다. for loop 구문이 끝난 후 do.call() 함수를 통해 투자비중이 저장된 리스트를 테이블 형태로 바꿔줍니다. 이를 통해 동적 자산배분의 투자 규칙에 맞는 매월 말 투자비중이 계산되었습니다. GDAA = Return.portfolio(rets, wts, verbose = TRUE) charts.PerformanceSummary(GDAA$returns, main = &#39;동적자산배분&#39;) 수익률과 비중 데이터가 있으므로 Return.portfolio() 함수를 통해 백테스트 수익률을 계산할 수 있습니다. charts.PerformanceSummary() 함수를 통해 누적수익률을 확인하면 해당 전략을 이용한 포트폴리오가 꾸준히 우상향하는 모습을 보이게됩니다. wts %&gt;% fortify.zoo() %&gt;% gather(key, value, -Index) %&gt;% mutate(Index = as.Date(Index)) %&gt;% mutate(key = factor(key, levels = unique(key))) %&gt;% ggplot(aes(x = Index, y = value)) + geom_area(aes(color = key, fill = key), position = &#39;stack&#39;) + xlab(NULL) + ylab(NULL) + theme_bw() + scale_x_date(date_breaks=&quot;years&quot;, date_labels=&quot;%Y&quot;, expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + theme(plot.title = element_text(hjust = 0.5, size = 12), legend.position = &#39;bottom&#39;, legend.title = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1, size = 8), panel.grid.minor.x = element_blank()) + guides(color = guide_legend(byrow = TRUE)) 반면 자산별 투자비중의 변화가 많은 것을 알 수 있습니다. 그 원인은 수익률 상위 5개에 해당하는 자산이 매월 말 바뀌며, 최소분산 포트폴리오를 구성하는 비중이 계속해서 바뀌기 때문입니다. 회전율이 상대적으로 낮았던 기존 백테스트에서는 매매비용, 세금, 기타비용 등을 고려하지 않아도 수익률에 크게 영향이 없지만, 회전율이 상대적으로 높은 전략에서는 이러한 것들을 무시하지 않을 수 없습니다. GDAA$turnover = xts( rowSums(abs(GDAA$BOP.Weight - timeSeries::lag(GDAA$EOP.Weight)), na.rm = TRUE), order.by = index(GDAA$BOP.Weight)) chart.TimeSeries(GDAA$turnover) 기존에 살펴본 방법으로 회전율을 계산한다면 매월 상당한 매매회전이 발생함이 확인됩니다. fee = 0.0030 GDAA$net = GDAA$returns - GDAA$turnover*fee 매수 혹은 매도당 발생하는 세금, 수수료, 시장충격 등 총 비용을 0.3%로 가정합니다. 포트폴리오 수익률에서 회전율과 총 비용의 곱을 빼면, 비용 후 포트폴리오의 순수익률이 계산됩니다. cbind(GDAA$returns, GDAA$net) %&gt;% setNames(c(&#39;No Fee&#39;, &#39;After Fee&#39;)) %&gt;% charts.PerformanceSummary(main = &#39;GDAA&#39;) 기존 비용을 고려하지 않은 포트폴리오(검은색)에 비해, 비용을 차감한 포트폴리오(붉은색)의 수익률이 시간이 지남에 따라 서서히 감소합니다. 이러한 차이는 비용이 크거나 매매회전율이 높을수록 더욱 벌어지게 됩니다. References "],["성과-및-위험-평가.html", "Chapter 13 성과 및 위험 평가 13.1 결과 측정 지표 13.2 팩터 회귀분석 및 테이블로 나타내기", " Chapter 13 성과 및 위험 평가 백테스트를 통해 포트폴리오 수익률을 구했다면, 이를 바탕으로 각종 성과 및 위험을 평가해야 합니다. 아무리 성과가 좋은 전략이라도 위험이 너무 크다면 투자를 하기 부담스럽습니다. 또한 전략의 수익률이 지속적으로 감소하는 추세라면 경쟁이 치열해져 더 이상 작동하지 않는 전략일 가능성도 있습니다. 이 CHAPTER에서는 포트폴리오의 예시로 퀄리티 팩터를 종합적으로 고려한 QMJ(Quality Minus Junk) 팩터(Asness, Frazzini, and Pedersen 2019)의 수익률을 이용하겠습니다. QMJ 팩터란 우량성이 높은 종목들을 매수하고, 우량성이 낮은 종목들을 공매도하는 전략을 지수의 형태로 나타낸 것입니다. 해당 팩터의 수익률을 통해 성과 및 위험을 평가해보고, 회귀분석을 통해 다른 팩터와의 관계도 살펴보겠습니다. QMJ 팩터의 수익률은 AQR Capital Management의 Datasets18에서 엑셀 파일을 다운로 드한 후 가공할 수도 있습니다. 그러나 해당 작업을 매번 하는 것은 지나치게 번거로우므로, R에서 엑셀 파일을 다운로드한 후 가공하겠습니다. library(dplyr) library(readxl) library(xts) library(timetk) url = &#39;https://images.aqr.com/-/media/AQR/Documents/Insights/Data-Sets/Quality-Minus-Junk-Factors-Monthly.xlsx&#39; tf = tempfile(fileext = &#39;.xlsx&#39;) download.file(url, tf, mode = &#39;wb&#39;) excel_sheets(tf) ## [1] &quot;QMJ Factors&quot; &quot;Definition&quot; ## [3] &quot;Data Sources&quot; &quot;--&gt; Additional Global Factors&quot; ## [5] &quot;MKT&quot; &quot;SMB&quot; ## [7] &quot;HML FF&quot; &quot;HML Devil&quot; ## [9] &quot;UMD&quot; &quot;ME(t-1)&quot; ## [11] &quot;RF&quot; &quot;Sources and Definitions&quot; ## [13] &quot;Disclosures&quot; 해당 데이터의 엑셀 url을 저장합니다. tempfile() 함수 내 .xlsx 인자를 입력함으로써, 임시로 엑셀 파일을 만들도록 합니다. download.file() 함수를 통해 url 파일을 tf 파일명에 저장하며, 엑셀 파일은 바이너리 파일이므로 wb 인자를 입력합니다. readxl 패키지의 excel_sheets() 함수를 통해 해당 엑셀의 시트명들을 확인합니다. 우리가 필요한 데이터는 수익률을 계산할 QMJ Factors, 회귀분석에 필요한 MKT, SMB, HML Devil, UMD, 무위험 이자율인 RF 시트의 데이터입니다. df_QMJ = read_xlsx(tf, sheet = &#39;QMJ Factors&#39;, skip = 18) %&gt;% select(DATE, Global) df_MKT = read_xlsx(tf, sheet = &#39;MKT&#39;, skip = 18) %&gt;% select(DATE, Global) df_SMB = read_xlsx(tf, sheet = &#39;SMB&#39;, skip = 18) %&gt;% select(DATE, Global) df_HML_Devil = read_xlsx(tf, sheet = &#39;HML Devil&#39;, skip = 18) %&gt;% select(DATE, Global) df_UMD = read_xlsx(tf, sheet = &#39;UMD&#39;, skip = 18) %&gt;% select(DATE, Global) df_RF = read_xlsx(tf, sheet = &#39;RF&#39;, skip = 18) readxl 패키지의 read_xlsx() 함수를 통해 엑셀 데이터를 읽어올 수 있으며, 시트명을 정해줄 수도 있습니다. 또한 각 시트 내 18행까지는 데이터를 설명하는 텍스트이므로, skip 인자를 통해 해당 부분은 읽어오지 않도록 합니다. 그 후 select() 함수를 통해 날짜에 해당하는 DATE와 수익률에 해당하는 Global 열만을 선택합니다. df = Reduce(function(x, y) inner_join(x, y, by = &#39;DATE&#39;), list(df_QMJ, df_MKT, df_SMB, df_HML_Devil,df_UMD, df_RF)) %&gt;% setNames(c(&#39;DATE&#39;,&#39;QMJ&#39;, &#39;MKT&#39;, &#39;SMB&#39;, &#39;HML&#39;, &#39;UMD&#39;, &#39;RF&#39;)) %&gt;% na.omit() %&gt;% mutate(DATE = as.Date(DATE, &quot;%m/%d/%Y&quot;), R_excess = QMJ - RF, Mkt_excess = MKT - RF) %&gt;% tk_xts(date_var = DATE) inner_join() 함수를 통해 DATE를 기준으로 데이터를 묶어주어야 합니다. 해당 함수는 한 번에 두 개 테이블만을 선택할 수 있으므로, Reduce() 함수를 통해 모든 데이터에 inner_join() 함수를 적용합니다. setNames() 함수를 통해 열 이름을 입력합니다. 각 팩터별 시작시점이 다르므로 na.omit() 함수를 통해 NA 데이터를 삭제해줍니다. mutate() 함수를 통해 데이터를 변형해줍니다. DATE 열은 mm/dd/yy의 문자열 형식이므로 이를 날짜 형식으로 변경해줍니다. QMJ 팩터 수익률에서 무위험 수익률을 차감해 초과수익률을 구해주며, 시장 수익률에서 무위험 수익률을 차감해 시장위험 프리미엄을 계산해줍니다. tk_xts() 함수를 이용해 티블 형태를 시계열 형태로 변경하며, 인덱스는 DATE 열을 설정합니다. 형태를 변경한 후 해당 열은 자동으로 삭제됩니다. 위 과정을 통해 구한 데이터를 바탕으로 성과 및 위험을 평가하겠습니다. 13.1 결과 측정 지표 포트폴리오의 평가에서 가장 중요한 지표는 수익률과 위험입니다. 수익률은 누적수익률과 연율화 수익률, 연도별 수익률이 주요 지표이며, 위험은 변동성과 낙폭이 주요 지표입니다. 이 외에도 승률, 롤링 윈도우 값 등 다양한 지표를 살펴보기도 합니다. 이러한 지표를 수식을 이용해 직접 계산할 수도 있지만, PerformanceAnalytics 패키지에서 제공하는 다양한 함수들을 이용해 편하게 계산할 수 있습니다. 13.1.1 수익률 및 변동성 library(PerformanceAnalytics) chart.CumReturns(df$QMJ) 먼저 chart.CumReturns() 함수를 이용해 QMJ 팩터의 누적수익률을 그래프로 나타내봅니다. 1989-07-31부터 2021-09-30까지 장기간동안 우상향하는 모습을 보이고 있습니다. prod((1+df$QMJ)) - 1 # 누적수익률 ## [1] 3.966 mean(df$QMJ) * 12 # 연율화 수익률(산술) ## [1] 0.05251 (prod((1+df$QMJ)))^(12 / nrow(df$QMJ)) - 1 # 연율화 수익률(기하) ## [1] 0.05095 수익률 중 가장 많이보는 지표는 누적 수익률, 연율화 수익률(산술), 연율화 수익률(기하)입니다. 각 수익률을 구하는 법은 다음과 같습니다. 누적 수익률: \\((1+r_1) \\times (1+r_2) \\times \\dots \\ \\times (1+r_n) - 1 = \\{\\prod_{i=1}^n(1+r_i)\\}-1\\), 연율화 수익률(산술): \\(\\frac{(r_1 + r_2 + \\dots + r_i)}{n} \\times scale\\) 연율화 수익률(기하): \\(\\{\\prod_{i=1}^n(1+r_i)\\}^{scale / Days} - 1\\) 먼저 누적수익률은 각 수익률에 1을 더한 값을 모두 곱한 후 1을 빼면 됩니다. 연율화 수익률(산술)은 단순히 수익률의 평균을 구한 후 연율화를 위한 조정값(\\(scale\\))을 곱해주면 됩니다. 데이터가 일간일 경우 조정값은 252, 주간일 경우 52, 월간일 경우 12입니다. 현재 데이터는 월간 기준이므로 조정값은 12가 됩니다. 마지막으로 연율화 수익률(기하)은 각 수익률에 1을 더한 값의 곱을 구한 후 연율화를 위해 승수를 적용한 후 1을 빼주며, Days는 시계열의 관측 기간입니다. 마지막으로 연율화 수익률(기하)의 경우 각 수익률에 1을 더한 값의 곱을 구한 후, 연율화를 위해 승수를 곱한 후 1을 빼주면 되며, \\(Days\\)는 시계열의 관측 기간입니다. Return.cumulative(df$QMJ) # 누적수익률 ## QMJ ## Cumulative Return 3.966 Return.annualized(df$QMJ, geometric = FALSE) # 연율화 수익률(산술) ## QMJ ## Annualized Return 0.05251 Return.annualized(df$QMJ) # 연율화 수익률(기하) ## QMJ ## Annualized Return 0.05095 수식에 맞게 값을 입력해 계산할 수도 있지만, 함수를 이용하면 더욱 손쉽게 계산이 가능하며 실수할 가능성도 줄어듭니다. 누적수익률은 Return.cumulative() 함수를 통해, 연율화 수익률(산술)은 Return.annualized() 함수 내 geometric 인자를 FALSE로 선택해줌으로써, 연율화 수익률(기하)는 Return.annualized() 함수를 통해 계산이 가능합니다. 수식으로 계산한 값과 함수를 통해 계산한 값을 비교하면 동일함이 확인됩니다. sd(df$QMJ) * sqrt(12) # 연율화 변동성 ## [1] 0.07392 StdDev.annualized(df$QMJ) # 연율화 변동성 ## QMJ ## Annualized Standard Deviation 0.07392 SharpeRatio.annualized(df$QMJ, Rf = df$RF, geometric = TRUE) ## QMJ ## Annualized Sharpe Ratio (Rf=2.7%) 0.3171 위험으로 가장 많이 사용되는 지표는 변동성입니다. 연율화 변동성은 sd() 함수를 통해 변동성을 계산한 후 조정값을 곱해 계산합니다. 그러나 StdDev.annualized() 함수를 사용해 더욱 쉽게 계산할 수도 있습니다. 수익을 위험으로 나누어 위험 조정 수익률을 보는 지표가 샤프 지수(Sharpe Ratio)입니다. 해당 지수는 \\(\\frac {R_i - R_f}{\\sigma_i}\\)로 계산되며, 분자에는 포트폴리오 수익률에서 무위험 수익률을 차감한 값이, 분모에는 포트폴리오의 변동성이 오게 됩니다. SharpeRatio.annualized() 함수를 이용하면 포트폴리오 수익률에서 무위험 수익률을 차감한 값을 연율화로 변경한 후 연율화 변동성으로 나누어 샤프 지수를 계산합니다. geometric을 TRUE로 설정하면 기하평균 기준 연율화 수익률을, FALSE로 설정하면 산술평균 기준 연율화 수익률을 계산합니다. 13.1.2 낙폭과 최대낙폭 먼저 낙폭(Drawdown)은 수익률이 하락한 후 반등하기 전까지 얼마나 하락했는지를 나타냅니다. 최대낙폭(Maximum Drawdown)은 이러한 낙폭 중 가장 값이 큰 값으로서, 최고점에서 최저점까지 얼마나 손실을 보는지를 나타냅니다. 투자를 함에 있어 수익률이 하락하는 것은 어쩔 수 없지만, 최대낙폭이 지나치게 큰 전략에 투자하는 것은 매우 위험한 선택이 될 수 있습니다. 그림 13.1: 낙폭과 최대낙폭 table.Drawdowns(df$QMJ) ## From Trough To Depth Length To Trough Recovery ## 1 2002-10-31 2004-01-31 2008-08-31 -0.2135 71 16 55 ## 2 2009-03-31 2009-09-30 2011-12-31 -0.1998 34 7 27 ## 3 2020-04-30 2021-02-28 &lt;NA&gt; -0.1488 19 11 NA ## 4 1992-11-30 1993-08-31 1997-01-31 -0.1408 51 10 41 ## 5 1998-10-31 1999-04-30 2000-05-31 -0.0869 20 7 13 maxDrawdown(df$QMJ) ## [1] 0.2135 chart.Drawdown(df$QMJ) 이러한 낙폭에 대한 지표들은 손으로 계산하기 번거롭지만, 패키지 내 함수를 사용한 다면 매우 손쉽게 계산할 수 있습니다. 먼저 table.Drawdowns() 함수를 이용하면 역대 낙폭이 가 장 심했던 순서대로 낙폭 정도, 하락 기간과 상승 기간, 원금 회복 기간 등을 테이블로 나타내줍니다. maxDrawdown() 함수는 포트폴리오의 최대낙폭을 계산해주며, chart.Drawdown() 함수는 낙폭만을 그래프로 그려줍니다. CalmarRatio(df$QMJ) ## QMJ ## Calmar Ratio 0.2387 위험 조정 수익률 중 사용되는 지표 중 칼마 지수(Calmar Ratio)도 있습니다. 칼마 지수는 연율화 수익률을 최대낙폭으로 나눈 값으로서, 특히나 안정적인 절대 수익률을 추구하는 헤지펀드에서 많이 참조하는 지표입니다. 13.1.3 연도별 수익률 apply.yearly(df$QMJ, Return.cumulative) %&gt;% head() ## QMJ ## 1989-12-31 0.07695 ## 1990-12-31 0.21974 ## 1991-12-31 0.01088 ## 1992-12-31 0.02983 ## 1993-12-31 -0.09299 ## 1994-12-31 0.03885 apply.yearly() 함수 내 계산 함수를 Return.cumulative로 설정한다면 연도별 수익률을 계산할 수 있습니다. library(lubridate) library(tidyr) library(ggplot2) R.yr = apply.yearly(df$QMJ, Return.cumulative) %&gt;% fortify.zoo() %&gt;% mutate(Index = year(Index)) %&gt;% gather(key, value, -Index) %&gt;% mutate(key = factor(key, levels = unique(key))) ggplot(R.yr, aes(x = Index, y = value, fill = key)) + geom_bar(position = &quot;dodge&quot;, stat = &quot;identity&quot;) + ggtitle(&#39;Yearly Return&#39;) + xlab(NULL) + ylab(NULL) + theme_bw() + scale_y_continuous(expand = c(0.03, 0.03)) + scale_x_continuous(breaks = R.yr$Index, expand = c(0.01, 0.01)) + theme(plot.title = element_text(hjust = 0.5, size = 12), legend.position = &#39;bottom&#39;, legend.title = element_blank(), legend.text = element_text(size=7), axis.text.x = element_text(angle = 45, hjust = 1, size = 8), panel.grid.minor.x = element_blank() ) + guides(fill = guide_legend(byrow = TRUE)) + geom_text(aes(label = paste(round(value * 100, 2), &quot;%&quot;), vjust = ifelse(value &gt;= 0, -0.5, 1.5)), position = position_dodge(width = 1), size = 3) apply.yearly() 함수를 통해 계산한 연도별 수익률에 ggplot() 함수를 응용하면 막대 그래프로 나타낼 수도 있으며, 시각화를 통해 포트폴리오의 수익률 추이가 더욱 쉽게 확인됩니다. 13.1.4 승률 및 롤링 윈도우 값 승률이란 포트폴리오가 벤치마크 대비 높은 성과를 기록한 비율을 의미하며 다음과 같이 계산됩니다. \\[\\frac {(포트폴리오\\,수익률 &gt; 벤치마크)\\,일수}{전체\\,기간}\\] 벤치마크가 S&amp;P 500 지수, KOSPI 200 지수처럼 구체적으로 존재하는 경우도 있지만, 절대수익을 추구하는 경우에는 이러한 벤치마크가 0 혹은 무위험 수익률이 되기도 합니다. UpsideFrequency(df$QMJ, MAR = 0) ## [1] 0.5891 UpsideFrequency() 함수는 벤치마크 대비 승률을 계산해줍니다. MAR 인자는 0이 기본값으로 설정되어 있으며, 원하는 벤치마크가 있을 시 이를 입력해주면 됩니다. QMJ 팩터는 월간 기준 수익률이 플러스를 기록했던 비율이 58.91%입니다. 위에서 구한 각종 지표들은 투자자가 포트폴리오의 시작부터 현재까지 투자를 했다는 전제 하에 계산됩니다. 그러나 투자를 시작하는 시점은 사람마다 다르기에, 무작위 시점에 투자했을 때 향후 n개월 후 승률 혹은 연율화 수익률 등을 계산할 필요도 있습니다. 이러한 기법을 롤링 윈도우라고 합니다. roll_12 = df$QMJ %&gt;% apply.monthly(., Return.cumulative) %&gt;% rollapply(., 12, Return.annualized) %&gt;% na.omit() %&gt;% UpsideFrequency() roll_24 = df$QMJ %&gt;% apply.monthly(., Return.cumulative) %&gt;% rollapply(., 24, Return.annualized) %&gt;% na.omit() %&gt;% UpsideFrequency() roll_36 = df$QMJ %&gt;% apply.monthly(., Return.cumulative) %&gt;% rollapply(., 36, Return.annualized) %&gt;% na.omit() %&gt;% UpsideFrequency() roll_win = cbind(roll_12, roll_24, roll_36) print(roll_win) ## roll_12 roll_24 roll_36 ## [1,] 0.7394 0.7802 0.8778 롤링 윈도우 승률은 무작위 시점에 투자했을 시 미래 n개월 동안의 연율화 수익률을 구하고, 해당 값이 벤치마크 대비 수익이 높았던 비율을 계산합니다. 만일 12개월 롤링 윈도우 승률이 100%라면, 어떠한 시점에 투자해도 12개월 후에는 언제나 벤치마크를 이겼음을 의미합니다. 반면 아무리 연율화 수익률이 높은 전략도 이러한 롤링 윈도우 승률이 지나치게 낮다면, 단순히 한 번의 운으로 인해 수익률이 높은 것처럼 보일수 있습니다. 함수를 이용해 해당 값을 구하는 과정은 다음과 같습니다. apply.*() 함수를 이용해 원하는 기간의 수익률로 변경하며, 위 예제에서는 월간 수익률로 변경했습니다. rollapply() 함수를 통해 원하는 기간의 롤링 윈도우 통곗값을 구해줍니다. 각각 12개월, 24개월, 36개월 기간에 대해 연율화 수익률을 계산해줍니다. 계산에 필요한 n개월 동안은 수익률이 없으므로 na.omit()을 통해 삭제해줍니다. UpsideFrequency() 함수를 통해 승률을 계산합니다. 해당 과정을 통해 계산된 12개월, 24개월, 36개월 롤링 승률은 각각 73.94%, 78.02%, 87.78%이며, 투자 기간이 길어질수록 승률이 높아집니다. df$QMJ %&gt;% apply.monthly(., Return.cumulative) %&gt;% rollapply(., 12, Return.annualized) %&gt;% na.omit() %&gt;% fortify.zoo() %&gt;% ggplot(aes(x = Index, y = QMJ)) + geom_line() + geom_hline(aes(yintercept = 0), color = &#39;red&#39;) + xlab(NULL) + ylab(NULL) 롤링 윈도우 연율화 수익률 역시 매우 중요한 지표입니다. 해당 값이 지속적으로 하락할 경우 전략이 더 이상 동작하지 않는 것인지 혹은 가장 험난한 시기를 지났기에 인내심을 갖고 기다려야 할지 판단해야 합니다. 13.2 팩터 회귀분석 및 테이블로 나타내기 포트폴리오 수익률에 대한 성과 평가만큼 중요한 것이, 수익률이 어디에서 발생했는가에 대한 요인을 분석하는 것입니다. 베타를 통한 개별 주식과 주식시장과의 관계를 시작으로, 수익률을 설명하기 위한 여러 모형들이 개발되고 발표되었습니다. 그중 일반적으로 많이 사용되는 모형은 기존의 CAPM에 사이즈 팩터(SMB), 밸류 팩터(HML)를 추가한 파마-프렌치의 3팩터 모형(Fama and French 1993), 그리고 3팩터 모형에 모멘텀 팩터(UMD)를 추가한 카하트의 4팩터 모형(Carhart 1997)입니다. QMJ 팩터를 위 4개 팩터에 회귀분석한 결과를 토대로, 퀄리티 팩터의 수익률에 대한 요인 분석을 해보겠습니다. reg = lm(R_excess ~ Mkt_excess + SMB + HML + UMD, data = df) # summary(reg) summary(reg)$coefficient ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.002776 0.0007128 3.894 1.165e-04 ## Mkt_excess -0.257632 0.0165542 -15.563 1.206e-42 ## SMB -0.364936 0.0364449 -10.013 4.108e-21 ## HML -0.095386 0.0325221 -2.933 3.560e-03 ## UMD 0.078488 0.0267841 2.930 3.589e-03 먼저 우리가 구한 데이터를 통해 다음과 같은 회귀분석을 실시합니다. 즉 QMJ 팩터의 초과수익률을 시장위험 프리미엄, 사이즈 팩터, 밸류 팩터, 모멘텀 팩터에 회귀분석을 수행합니다. \\[QMJ - R_f= \\beta_m \\times \\ [R_m - R_f] + \\beta_{SMB} \\times R_{SMB} + \\beta_{HML} \\times R_{HML} + \\beta_{UMD} \\times R_{UMD}\\] lm() 함수 내에서 R_excess는 \\(QMJ - R_f\\)와 동일하며, Mkt_excess는 \\(R_m - R_f\\)와 동일합니다. 베타의 절댓값이 크다는 의미는 QMJ 팩터의 수익률이 해당 팩터와의 관계가 높다는 의미이며, 양수일 경우에는 양의 관계가, 음수일 경우에는 음의 관계가 높다는 의미입니다. 또한 t값 혹은 P값을 통해 관계가 얼마나 유의한지도 확인할 수 있습니다. 시장 베타에 해당하는 \\(\\beta_m\\)은 -0.258로 음숫값을 보이며, 퀄리티 팩터의 경우 시장과 역의 관계에 있다고 볼 수 있습니다. 또한 t값이 -15.563로 충분히 유의합니다. 사이즈 베타에 해당하는 \\(\\beta_{SMB}\\)는 -0.365이며 역시나 음숫값을 보입니다. 즉 퀄리티 팩터는 소형주보다는 대형주 수익률과 관계가 있으며, t값 역시 -10.013로 충분히 유의합니다. 밸류 베타에 해당하는 \\(\\beta_{HML}\\)은 -0.095이며 이 역시 음숫값을 보입니다. 즉 퀄리티와 밸류 간의 관계에서 살펴본 것처럼, 두 팩터는 서로 역의 관계가 있습니다. t값 역시 -2.933로 유의합니다. 모멘텀 베타에 해당하는 \\(\\beta_{UMD}\\)는 0.078로 양의 관계가 있으며, 모멘텀 팩터가 좋은 시기에 퀄리티 팩터도 좋을 수 있습니다. t값은 2.93로 유의하다고 볼 수 있습니다. 이러한 설명변수를 제외하고도 월간 초과수익률에 해당하는 계숫값이 0.003이며, t값은 3.894로 유의합니다. 즉, 퀄리티 팩터는 기존의 여러 팩터들로 설명되지 않는 새로운 팩터라고도 볼 수 있습니다. library(broom) tidy(reg) ## # A tibble: 5 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 0.00278 0.000713 3.89 1.16e- 4 ## 2 Mkt_excess -0.258 0.0166 -15.6 1.21e-42 ## 3 SMB -0.365 0.0364 -10.0 4.11e-21 ## 4 HML -0.0954 0.0325 -2.93 3.56e- 3 ## 5 UMD 0.0785 0.0268 2.93 3.59e- 3 broom 패키지의 tidy() 함수를 사용하면 분석 결과 중 계수에 해당하는 값만을 요약해서 볼 수 있습니다. library(stargazer) stargazer(reg, type = &#39;text&#39;, out = &#39;data/reg_table.html&#39;) ## ## =============================================== ## Dependent variable: ## --------------------------- ## R_excess ## ----------------------------------------------- ## Mkt_excess -0.258*** ## (0.017) ## ## SMB -0.365*** ## (0.036) ## ## HML -0.095*** ## (0.033) ## ## UMD 0.078*** ## (0.027) ## ## Constant 0.003*** ## (0.001) ## ## ----------------------------------------------- ## Observations 387 ## R2 0.623 ## Adjusted R2 0.619 ## Residual Std. Error 0.013 (df = 382) ## F Statistic 157.800*** (df = 4; 382) ## =============================================== ## Note: *p&lt;0.1; **p&lt;0.05; ***p&lt;0.01 stargazer 패키지를 사용하면, 회귀분석 결과를 논문에서 많이 사용되는 테이블 형식으로 손쉽게 출력과 저장을 할 수 있습니다.테이블이 출력과 함께 data 폴더 내에 reg_table.html 이름으로 HTML 파일도 저장됩니다. References "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
